<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Leetcode-Construct Binary Tree from Preorder and Inorder Traversal(Java)]]></title>
      <url>http://yoursite.com/2016/01/26/Leetcode-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Java/</url>
      <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>You may assume that duplicates do not exist in the tree.</p>
<p><strong>Thinking:</strong></p>
<p>This question is similar with Construct Binary Tree from Inorder and Postorder Traversal. We should understand the differences and the sequences of these three methods. And divide into three parts- root, left child and right child.</p>
<p><strong>Solution:</strong></p>
<pre><code>public TreeNode buildTree(int[] preorder, int[] inorder) {
    int l = preorder.length;
    if (l == 0)
        return null;


    return dp(preorder, inorder, 0, l-1, 0, l-1);
    }

    private TreeNode dp(int[] preorder, int[] inorder, int preStart, int preEnd, int inStart, int inEnd){
    if (preStart &gt; preEnd || preEnd &gt;= preorder.length || inEnd &gt;= preorder.length)
        return null;
    TreeNode root = new TreeNode(preorder[preStart]);
    int index = inStart;
    for (; index &lt; inEnd; index++){
        if (inorder[index] == preorder[preStart])
            break;
    }

    TreeNode left = dp(preorder, inorder, preStart+1, preStart+index-inStart, inStart, index-1);
    TreeNode right = dp(preorder, inorder,preStart+index-inStart+1, preEnd, index+1, inEnd);
    root.left = left;
    root.right = right;

    return root;
}    
</code></pre><p>This method can be improved by using HashMap to make it faster when fiding the index of root.<br>Reference:<a href="http://blog.csdn.net/linhuanmars/article/details/24389549" target="_blank" rel="external">http://blog.csdn.net/linhuanmars/article/details/24389549</a><br>Code:</p>
<pre><code>static HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
public TreeNode buildTree(int[] preorder, int[] inorder) {
    int l = preorder.length;
    if (l == 0)
        return null;
    for (int i = 0; i &lt; l; i++)
        map.put(inorder[i], i);

    return dp(preorder, inorder, 0, l-1, 0, l-1);
}

private TreeNode dp(int[] preorder, int[] inorder, int preStart, int preEnd, int inStart, int inEnd){
    if (preStart &gt; preEnd || inStart &gt; inEnd)
        return null;
    TreeNode root = new TreeNode(preorder[preStart]);

    int index = map.get(preorder[preStart]);

    TreeNode left = dp(preorder, inorder, preStart+1, preStart+index-inStart, inStart, index-1);
    TreeNode right = dp(preorder, inorder,preStart+index-inStart+1, preEnd, index+1, inEnd);
    root.left = left;
    root.right = right;

    return root;
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-Pow(x, n)(Java)]]></title>
      <url>http://yoursite.com/2016/01/26/Leetcode-Pow-x-n-Java/</url>
      <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Implement pow(x, n).</p>
<p><strong>Thinking:</strong></p>
<p>It’s a simple but not simple question. There are many solutions for this problem. But how can we find the most effienct one. We can use recursion to reduce the times of multipling and check the bound of data to reduce the times of recursions. Finally, the code is below:</p>
<pre><code>static boolean negflag = false;
public double myPow(double x, int n) {
    if (n &lt; 0){
        negflag = true;
        return 1 / dp(x, -n);
    }
    else
        return dp(x, n);

}
private double dp(double x, int n){
    if (n == 0)
        return 1;
    if (n == 1)
        return x;
    if (n == 2)
        return x * x;

    int m = n / 2;
    int k = n % 2;
    double v = dp(x, m);
    if (negflag == true &amp;&amp; v &gt; 100000)
        return 100000;
    if (negflag == false &amp;&amp; v &lt; 0.00001)
        return 0;

    if (k == 0)
        return v * v;
    else
        return v * v * x;
}
</code></pre><p>By the way, I have to metion that my python solution is like, lol:</p>
<pre><code>def myPow(self, x, n):
    return x**n
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-Jump Game(Java)]]></title>
      <url>http://yoursite.com/2016/01/26/Leetcode-Jump-Game-Java/</url>
      <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<p>For example:<br>A = [2,3,1,1,4], return true.</p>
<p>A = [3,2,1,0,4], return false.</p>
<p><strong>Thinking:</strong></p>
<p>It’s a problem can be solved in greedy algorithm. Because we should go as far as possible in current position until we can’t go father. And we should gurantee the value of current position + i (steps can be reached from current postion) + nums[cur + i] be as big as possible.</p>
<p><strong>Solution:</strong></p>
<pre><code>public boolean canJump(int[] nums) {
    int l = nums.length;
    if (nums[0] == 0 &amp;&amp; l &gt; 1)
        return false;
    int cur = 0;
    int temp = nums[0];
    int step = nums[0];
    int max = nums[0];
    int tempcur = 0;

    while (cur + step &lt; l-1){
        for (int i = 1; i &lt;= step; i++){
            temp = cur + i + nums[cur + i];
            if (temp &gt;= max){//current max greedy value
                max = temp;
                if (max &gt;= l)
                    return true;
                tempcur = cur + i;
            }
        }
        if (cur == tempcur)
            return false;
        cur = tempcur;
        step = nums[cur];
    }

    if (max &gt;= l-1)
        return true;
    else
        return false;
}
</code></pre><p>What’s more, we can make it easier by max the value of index. </p>
<pre><code>public boolean canJump(int[] nums) {
    if(nums.length &lt;= 1)
        return true;

    int max = nums[0]; //max stands for the largest index that can be reached.

    for(int i=0; i&lt;nums.length; i++){
        //if not enough to go to next
        if(max &lt;= i &amp;&amp; nums[i] == 0) 
            return false;

        //update max    
        if(i + nums[i] &gt; max){
            max = i + nums[i];
        }

        //max is enough to reach the end
        if(max &gt;= nums.length-1) 
            return true;
    }

    return false;    
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-3Sum Closest(Java)]]></title>
      <url>http://yoursite.com/2016/01/26/Leetcode-3Sum-Closest-Java/</url>
      <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<p>For example, given array S = {-1 2 1 -4}, and target = 1.</p>
<p>The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</p>
<p><strong>Thinking:</strong></p>
<p>In order to improve the performance of algorithm, we should sort the array. Because of that, we can determine where to go using current result.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int threeSumClosest(int[] nums, int target) {
    int l = nums.length;
    if (l &lt; 3)
        return 0;
    int min = Integer.MAX_VALUE;
    int res = 0;
    Arrays.sort(nums);

    for (int i = 0; i &lt; l; i++){
        int j = i + 1;
        int k = l - 1;

        while (j &lt; k){
            int sum = nums[i] + nums[j] + nums[k];
            if (sum == target)
                return sum;
            int diff = Math.abs(sum - target);
            if (diff &lt; min){
                min = diff;
                res = sum;
            }
            if (sum &gt; target)
                k--;
            else
                j++;
        }

    }
    return res;
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-Construct Binary Tree from Inorder and Postorder Traversal(Java)]]></title>
      <url>http://yoursite.com/2016/01/26/Leetcode-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-Java/</url>
      <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>You may assume that duplicates do not exist in the tree.</p>
<p><strong>Thinking:</strong></p>
<p>Inorder traversal will search in order: left, root, right;</p>
<p>Postorder travelsal will search in order: left, right, root.</p>
<p>So we can find the root in postorder and search it in inorder by the value. And find root’s left child and right child node by recursion.</p>
<pre><code>public TreeNode buildTree(int[] inorder, int[] postorder) {
    int l = inorder.length;
    if (l == 0)
        return null;
    TreeNode root = new TreeNode(postorder[l-1]);
    TreeNode left = null;
    TreeNode right = null;
    int index = 0;
    for (; index &lt; l; index++){
        if (inorder[index] == postorder[l-1])
            break;
    }


    if (index &gt; 0){
        int[] leftinorder = new int[index];
        int[] leftpostorder = new int[index];
        System.arraycopy(inorder, 0, leftinorder, 0, index);
        System.arraycopy(postorder, 0, leftpostorder, 0, index);
        left = buildTree(leftinorder, leftpostorder);
    }
    if (index &lt; l-1){
        int[] rightinorder = new int[l-index-1];
        int[] rightpostorder = new int[l-index-1];
        System.arraycopy(inorder, index+1, rightinorder, 0, l-index-1);
        System.arraycopy(postorder, index, rightpostorder, 0, l-index-1);
        right = buildTree(rightinorder, rightpostorder);
    }
    root.left = left;
    root.right = right;

    return root;
}
</code></pre><p>By the way, this code can be improved because in Java we can not easily get the subarray and I use the System.arraycopy. It can be replaced by recording the postion of array.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-Lowest Common Ancestor of a Binary Tree(Java)]]></title>
      <url>http://yoursite.com/2016/01/26/Leetcode-Lowest-Common-Ancestor-of-a-Binary-Tree-Java/</url>
      <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”</p>
<pre><code>           _______3______
         /              \
  ___5__           ___1___
    /      \         /          \
6        2       0         8
         /  \
        7    4
</code></pre><p>For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</p>
<p><strong>Thinking:</strong></p>
<p>The point to find the lowest common ancestor is to find a node whose left and right childs both have the node we want to find. Because if it’s not the lowest, the node will only belong to one of their child. If search in a pre-order from the root, if one node’s left child and right child both have the keynode or if the node itself is one of the keynode which means the other node will in lower level of this node, it’s the answer we want.</p>
<p><strong>Solution:</strong></p>
<pre><code>public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null)
        return root;

    if (root.equals(q) || root.equals(p)){
        return root;
    }

    TreeNode l = lowestCommonAncestor(root.left, p, q);
    TreeNode r = lowestCommonAncestor(root.right, p, q);
    if (l != null &amp;&amp; r != null)
        return root;

    return l == null? r: l;
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Node.js study note]]></title>
      <url>http://yoursite.com/2016/01/25/Node-js-study-note/</url>
      <content type="html"><![CDATA[<p><strong>Survey:</strong></p>
<p>Node.js is an open-source, cross-platform runtime environment for developing server-side Web applications. Node.js is not a JavaScript framework,[3] but its applications are written in JavaScript and can be run within the Node.js runtime on a wide variety of platforms.</p>
<p>This is my first time to learn Node.js, and I’ll write casully about the process and experience of learning.</p>
<hr>
<p><strong>Content:</strong></p>
<p>–1– Argument variables with process.argv</p>
<pre><code>app.js

function grab(flag){
    var index = process.argv.indexOf(flag);
    return (index === -1) ? null : process.argv[index+1];
}

var greeting = grab(&apos;--greeting&apos;);
var user = grab(&apos;--user&apos;);

if (!user || !greeting) {
    console.log(&quot;You blew it!&quot;);
} else {
    console.log(`Welcome, ${user}, ${greeting}`);
}
</code></pre><p>In this code, we grab the arguments from shell and print it out on the console.</p>
<p>For example, if in the shell:</p>
<pre><code>$node app --user Martin --greeting &quot;hello hello&quot;
</code></pre><p>Then in the console:</p>
<pre><code>Welcome, Martin, hello hello
</code></pre><p>And in this code, I also learned string temple which uses backticks<code>.</code>Welcome, ${user}, ${greeting}` will contain variable user and greeting.</p>
<hr>
<p>–2– Standard input and standard output</p>
<pre><code> var questions = [
&quot;What is your name?&quot;,
&quot;What is your favorite hobby?&quot;,
&quot;What is your preferred programming language?&quot;
];

var answers = [];

function ask(i) {
    process.stdout.write(`\n\n\n\n ${questions[i]}`);
    process.stdout.write(&quot;  &gt;  &quot;);
}

process.stdin.on(&apos;data&apos;, function(data){

    answers.push(data.toString().trim());

    if (answers.length &lt; questions.length) {
        ask(answers.length);
    } else {
        process.exit();
    }
});

process.on(&apos;exit&apos;, function(){

    process.stdout.write(&quot;\n\n\n\n&quot;);

    process.stdout.write(`Go ${answers[1]} ${answers[0]} you can finish writing ${answers[2]} later`);

    process.stdout.write(&quot;\n\n\n\n&quot;);

});

ask(0);
</code></pre><p>In the shell:</p>
<pre><code>What is your name?  &gt;  Martin




 What is your favorite hobby?  &gt;  play games




 What is your preferred programming language?  &gt;  python




Go play games Martin you can finish writing python later
</code></pre><p>Is that funny:)?</p>
<hr>
<p>–3– Globla timing functions</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-Insertion Sort List(Java)]]></title>
      <url>http://yoursite.com/2016/01/24/Leetcode-Insertion-Sort-List-Java/</url>
      <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Sort a linked list using insertion sort.</p>
<p><strong>Thinking:</strong></p>
<p>As the question state, we should apply the insertion sort method to linked list. So we create a ListNode for hold the sorted list, and scan the unsorted list and pick up element to compare the element in the sorted list. Then determine when to insert the value.</p>
<p><strong>Solution:</strong></p>
<pre><code>public class Solution {
    public ListNode insertionSortList(ListNode head) {
        if (head == null || head.next == null)
            return head;
        ListNode res = new ListNode(-1);
        res.next = head;
        ListNode p = res;
        ListNode next = head.next;
        head.next = null;
        head = next;
        while (head != null){
            while (p.next != null){
                //if the value is smaller than one of the sorted list, insert behind it
                if (head.val &lt; p.next.val){
                    next = head.next;
                    head.next = p.next;
                    p.next = head;
                    head = next;
                    p = res;
                    break;
                }
                p = p.next;
            }
            //if the value is bigger than anyone of the sorted list, insert after the whole list
            if (p.next == null){
                next = head.next;
                p.next = head;
                head.next = null;
                head = next;
                p = res;
            }
        }

        return res.next;
    }
}
</code></pre><p>I also copy a refining version of this algorithm from reference: <a href="http://www.cnblogs.com/springfor/p/3862468.html" target="_blank" rel="external">http://www.cnblogs.com/springfor/p/3862468.html</a></p>
<pre><code>public ListNode insertionSortList(ListNode head) {  
    if(head == null||head.next == null)  
        return head;  
    ListNode sortedlisthead = new ListNode(0);  
    ListNode cur = head;
    while(cur!=null){  
        ListNode next = cur.next;  
        ListNode pre = sortedlisthead;  
        while(pre.next!=null &amp;&amp; pre.next.val&lt;cur.val)  
            pre = pre.next;  
        cur.next = pre.next;  
        pre.next = cur;  
        cur = next;  
    }  
    return sortedlisthead.next;  
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Sort Algorithms]]></title>
      <url>http://yoursite.com/2016/01/24/Sort-Algorithms/</url>
      <content type="html"><![CDATA[<h2 id="Survey_3A"><a href="#Survey_3A" class="headerlink" title="Survey:"></a>Survey:</h2><p>This time, we talk about eight kinds of sort algorithms: insertion sort, shell’s sort, simple selection sort, heap sort, bubble sort, quick sort, merge sort and radix sort.</p>
<h2 id="Insertion_sort_3A"><a href="#Insertion_sort_3A" class="headerlink" title="Insertion sort:"></a>Insertion sort:</h2><p><strong>Main Idea:</strong></p>
<p>From the beginning of the list, get one value at a time and insert the value into right position of sorted list until all the values are sorted. And insertion sort is stalbe.</p>
<p><strong>Process:</strong> (From Wikimedia)</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/4/42/Insertion_sort.gif" alt=""></p>
<p><strong>Pseudocode:</strong></p>
<pre><code>for i ← 1 to length(A) - 1
    j ← i
    while j &gt; 0 and A[j-1] &gt; A[j]
        swap A[j] and A[j-1]
        j ← j - 1
    end while
end for
</code></pre><p><strong>Implemention in Java:</strong></p>
<pre><code>public static void InsertionSort(int[] num)
{
     int j;
     int key;
     int i;  

     for (j = 1; j &lt; num.length; j++){
        key = num[j];
        for(i = j - 1; (i &gt;= 0) &amp;&amp; (num[i] &lt; key); i--){
            num[i+1] = num[i];
        }
        num[i+1] = key;
    }
}
</code></pre><p><strong>Complexity:</strong></p>
<p><em>Runtime</em>: O(n^2)</p>
<p><em>Memery</em>: O(1)</p>
<hr>
<h2 id="ShellSort_3A"><a href="#ShellSort_3A" class="headerlink" title="ShellSort:"></a>ShellSort:</h2><p><strong>Main Idea:</strong></p>
<p>The method starts by sorting pairs of elements far apart from each other, then progressively reducing the gap between elements to be compared. Starting with far apart elements can move some out-of-place elements into position faster than a simple nearest neighbor exchange.</p>
<p><strong>Process:</strong>(From Wikimedia)</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/d/d8/Sorting_shellsort_anim.gif" alt=""></p>
<p><strong>Pesedocode:</strong></p>
<pre><code>gaps = [701, 301, 132, 57, 23, 10, 4, 1]

foreach (gap in gaps)
{
    # Do a gapped insertion sort for this gap size.
    # The first gap elements a[0..gap-1] are already in gapped order
    # keep adding one more element until the entire array is gap sorted
    for (i = gap; i &lt; n; i += 1)
    {
        # add a[i] to the elements that have been gap sorted
        # save a[i] in temp and make a hole at position i
        temp = a[i]
        # shift earlier gap-sorted elements up until the correct location for a[i] is found
        for (j = i; j &gt;= gap and a[j - gap] &gt; temp; j -= gap)
        {
            a[j] = a[j - gap]
        }
        # put temp (the original a[i]) in its correct location
        a[j] = temp
        }
    }
</code></pre><p> <strong>Implemention in Java:</strong></p>
<pre><code>public void shellSort() {
    int inner, outer;
    long temp;
    //find initial value of h
    int h = 1;
    while (h &lt;= len / 3)
      h = h * 3 + 1; // (1, 4, 13, 40, 121, ...)

    while (h &gt; 0) // decreasing h, until h=1
    {
      // h-sort the file
      for (outer = h; outer &lt; len; outer++) {
        temp = data[outer];
        inner = outer;
        // one subpass (eg 0, 4, 8)
        while (inner &gt; h - 1 &amp;&amp; data[inner - h] &gt;= temp) {
          data[inner] = data[inner - h];
          inner -= h;
        }
        data[inner] = temp;
      }
      h = (h - 1) / 3; // decrease h
    }
}
</code></pre><hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-Search for a Range(Java)]]></title>
      <url>http://yoursite.com/2016/01/24/Leetcode-Search-for-a-Range-Java/</url>
      <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a sorted array of integers, find the starting and ending position of a given target value.</p>
<p>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
<p>If the target is not found in the array, return [-1, -1].</p>
<p>For example,<br>Given [5, 7, 7, 8, 8, 10] and target value 8,<br>return [3, 4].</p>
<p><strong>Thinking:</strong></p>
<p>It’s question which should use binary search because it give us a sorted array and it requires O(log n) runtime complexity. Only thing difference between this algorithm and classical binary search is that we should make the range smaller while finding the target instead of returning the index.</p>
<p><strong>Solution:</strong></p>
<pre><code>public class Solution {
    public int[] searchRange(int[] nums, int target) {
        int low = 0;
        int high = nums.length - 1;
        int mid;
        int resl = -1;
        int resr = -1;
        while (low &lt;= high){
            mid = (low + high) / 2;
            if (nums[mid] == target){
                if (nums[low] == target){
                    resl = low;
                    if (resr != -1)
                        break;
                }    
                else
                    low++;

                if (nums[high] == target){
                    resr = high;
                    if (resl != -1)
                        break;
                }
                else
                    high--;
            }
            else if(nums[mid] &gt; target)
                high = mid - 1;
            else
                low = mid + 1;
        }
        int[] res = {resl, resr};
        return res;
    }

}
</code></pre><p>But the algorithm is not so effienct when finding the target so early. In order to make sure the runtime complexity is O(log n), we should also use binary search to find the lower bound and upper bound when finding the target in the array.<br>Reference: <a href="http://www.cnblogs.com/springfor/p/3857704.html" target="_blank" rel="external">http://www.cnblogs.com/springfor/p/3857704.html</a></p>
<p>Code:</p>
<pre><code>public int[] searchRange(int[] A, int target) {
    int [] res = {-1,-1};
    if(A == null || A.length == 0)
        return res;

    //first iteration, find target wherever it is
    int low = 0;
    int high = A.length-1;
    int pos = 0;
    while(low &lt;= high){
        int mid = (low + high)/2;
        pos = mid;
        if(A[mid] &gt; target)
            high = mid - 1;
        else if(A[mid] &lt; target)
            low = mid + 1;
        else{
            res[0] = pos;
            res[1] = pos;
            break;
        }
    }

    if(A[pos] != target)
        return res;

    //second iteration, find the right boundary of this target
    int newlow = pos;
    int newhigh = A.length-1;
    while(newlow &lt;= newhigh){
        int newmid = (newlow+newhigh)/2;
        if(A[newmid] == target)
            newlow = newmid + 1;
        else
            newhigh = newmid - 1;
    }
    res[1] = newhigh;

    //third iteration, find the left boundary of this target
    newlow = 0;
    newhigh = pos;
    while(newlow &lt;= newhigh){
        int newmid = (newlow+newhigh)/2;
        if(A[newmid] == target)
            newhigh = newmid - 1;
        else
            newlow = newmid + 1;
    }
    res[0] = newlow;

    return res;
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-Partition List(Java)]]></title>
      <url>http://yoursite.com/2016/01/24/Leetcode-Partition-List/</url>
      <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p>
<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p>For example,<br>Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,<br>return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.</p>
<p><strong>Thinking:</strong></p>
<p>We should preserve the original relative order of the nodes. So we need two points, one is for recording where to insert the less value node, and the other is for searching the less value node.</p>
<p><strong>Solution1:</strong></p>
<pre><code>public class Solution {
    public ListNode partition(ListNode head, int x) {
        if (head == null)
            return null;
        ListNode prehead = new ListNode(0);
        prehead.next = head;
        ListNode s = prehead;
        ListNode l = prehead;
        while(s != null &amp;&amp; l != null){
            while(s.next != null){
                if (s.next.val &gt;= x)
                    break;
                s = s.next;
            }
            l = s.next;
            if (l == null)
                break;
            while(l.next != null){
                if (l.next.val &lt; x)
                    break;
                l = l.next;
            }
            if (l.next == null)
                break;
            ListNode tmp = l.next;
            l.next = l.next.next;
            tmp.next = s.next;
            s.next = tmp;
        }

        return prehead.next;
    }

}
</code></pre><p>And there is another solution, which uses two lists. One is for recording less value node, and the other is for recording greater value node. And connect them:</p>
<pre><code>public ListNode partition(ListNode head, int x) {
        if(head==null||head.next==null)
            return head;

        ListNode small = new ListNode(-1);
        ListNode newsmallhead = small;
        ListNode big = new ListNode(-1);
        ListNode newbighead = big;

        while(head!=null){
            if(head.val&lt;x){
                small.next = head;
                small = small.next;
            }else{
                big.next = head;
                big = big.next;
            }
            head = head.next;
        }
        big.next = null;

        small.next = newbighead.next;

        return newsmallhead.next;
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-Flatten Binary Tree to Linked List(Java)]]></title>
      <url>http://yoursite.com/2016/01/24/leetcode-flatten-binary-tree-to-linked-list/</url>
      <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<pre><code>    1
   / \
  2   5
 / \   \
3   4   6
</code></pre><p>The flattened tree should look like:</p>
<pre><code>1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
</code></pre><p>Hint:<br>If you notice carefully in the flattened tree, each node’s right child points to the next node of a pre-order traversal.</p>
<p><strong>Thinking:</strong> </p>
<p>It’s a simple dfs question and it’s pre-order. So we need to make the left-child become right-child of root and make right-child become whole left-child’s right-child. </p>
<p><strong>Solution:</strong></p>
<pre><code>public class Solution {
    public void flatten(TreeNode root) {
        if (root == null)
            return;
        dfs(root);
    }

    public TreeNode dfs(TreeNode root){

        if (root.left == null &amp;&amp; root.right == null){
            return root;
        }

        TreeNode left = null;
        TreeNode right = null;
        TreeNode preleft = root.left;
        TreeNode preright = root.right;
        if (preleft == null){
            return dfs(preright);
        }
        else if(preright == null){
            root.left = null;
            root.right = preleft;
            return dfs(preleft);
        }
        else{
            left = dfs(preleft);
            right = dfs(preright);
            root.left = null;
            root.right = preleft;
            left.right = preright;
            return right;
        }
    }
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-Triangle(Java)]]></title>
      <url>http://yoursite.com/2016/01/24/Leetcode-Triangle/</url>
      <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>
<p>For example, given the following triangle:</p>
<pre><code>[
       [2],
     [3,4],
    [6,5,7],
   [4,1,8,3]
]
</code></pre><p>The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</p>
<p>Note:<br>Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</p>
<p><strong>Thinking:</strong><br>It’s a simple dynamic programming question. The expression is dp[i][j] = min(d[i-1][j-1], d[i][j]) + triangle[i][j].</p>
<p>But the first time, my code is time exceed:</p>
<pre><code>public class Solution {
    public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) {
        int lr = triangle.size();
        if(lr == 0){
            return 0;
        }
        int lc = triangle.get(lr-1).size();
        int min = 100000;
        for(int i = 0; i &lt; lc; i++){
            int tmp = dp(triangle, lr-1, i);
            if(tmp &lt; min)
                min = tmp;
        }
        return min;
    }

    public int dp(List&lt;List&lt;Integer&gt;&gt; triangle, int row, int column){
        if(row == 0){
            return triangle.get(0).get(0);
        }
        int value = triangle.get(row).get(column);
        int size = triangle.get(row-1).size();
        if(column &gt;= size){
            return dp(triangle, row-1, column-1) + value;
        }
        else if(column - 1 &lt; 0){
            return dp(triangle, row-1, column) + value;
        }
        else{
            int res1 = dp(triangle, row-1, column-1) + value;
            int res2 = dp(triangle, row-1, column) + value;
            if(res1 &lt; res2){
                return res1;
            }
            else{
                return res2;
            }
        }
    }
}
</code></pre><p>Then I noticed the bonus, so I change my mind to use <em>iteration</em>:</p>
<pre><code>public class Solution{
    public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle){
        int lr = triangle.size();
        int[] min = new int[lr];
        int[] tempmin = new int[lr];
        min[0] = triangle.get(0).get(0);
        for(int i = 1; i &lt; lr; i++){
            tempmin[0] = min[0] + triangle.get(i).get(0);
            tempmin[i] = min[i-1] + triangle.get(i).get(i);
            for(int j = 1; j &lt; i; j++){
                int res1 = min[j-1] + triangle.get(i).get(j);
                int res2 = min[j] + triangle.get(i).get(j);
                if(res1 &lt; res2)
                    tempmin[j] = res1;
                else
                    tempmin[j] = res2;
            }
            for(int k = 0; k &lt; i+1; k++){
                min[k] = tempmin[k];
            }
        }
        int m = 100000;
        for(int i = 0; i &lt; lr; i++){
            if(min[i] &lt; m)
                m = min[i];
        }
        return m;
    }
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-Unique Paths II(Java)]]></title>
      <url>http://yoursite.com/2016/01/24/Leetcode-Unique-Paths-II-Java/</url>
      <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Follow up for “Unique Paths”:</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<p>An obstacle and empty space is marked as 1 and 0 respectively in the grid.</p>
<p>For example,<br>There is one obstacle in the middle of a 3x3 grid as illustrated below.</p>
<pre><code>[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
</code></pre><p>The total number of unique paths is 2.</p>
<p>Note: m and n will be at most 100.</p>
<p><strong>Thinking:</strong></p>
<p>This question is similar with Unique Paths, and it’s the same methed to use dynamic programming. Only one difference is that we should check if it’s a obstacle. And if it’s a obstacle, its value of dp should be 0.</p>
<p><strong>Solution:</strong></p>
<pre><code>public class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int lr = obstacleGrid.length;
        if (lr == 0)
            return 0;
        int lc = obstacleGrid[0].length;
        int[][] dp = new int[lr][lc];
        if (obstacleGrid[0][0] == 1){
            return 0;
        }
        dp[0][0] = 1;

        for (int i = 1; i &lt; lr; i++){
            if (obstacleGrid[i][0] == 1)
                break;
            dp[i][0] = 1;
        }
        for (int i = 1; i &lt; lc; i++){
            if (obstacleGrid[0][i] == 1)
                break;
            dp[0][i] = 1;
        }

        for (int i = 1; i &lt; lr; i++)
            for (int j = 1; j &lt; lc; j++){
                if(obstacleGrid[i][j] == 1)
                    continue;
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }

        return dp[lr-1][lc-1];
    }
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-Unique Binary Search Trees II(Java)]]></title>
      <url>http://yoursite.com/2016/01/24/Unique-Binary-Search-Trees-II/</url>
      <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given n, generate all structurally unique BST’s (binary search trees) that store values 1…n.</p>
<p>For example,<br>Given n = 3, your program should return all 5 unique BST’s shown below.</p>
<pre><code>1         3     3      2      1
 \       /     /      / \      \
  3     2     1      1   3      2
 /     /       \                 \
2     1         2                 3
</code></pre><p><strong>Thinking:</strong> </p>
<p>It’s a simple dynamic programming question. For n numbers, we should consider the situation that every one become the root, and delete it from the sets and do the same thing for their children.</p>
<p><strong>Solution:</strong></p>
<pre><code>public class Solution {
    public List&lt;TreeNode&gt; generateTrees(int n) {
        return dp(1, n);
    }

    public List&lt;TreeNode&gt; dp(int low, int high){
        List&lt;TreeNode&gt; res = new ArrayList&lt;TreeNode&gt;();
        if (low == high){
            TreeNode n = new TreeNode(low);
            res.add(n);
            return res;
        }
        for (int i = low; i &lt;= high; i++){
            TreeNode n = new TreeNode(i);
            if (i == low){
                for (TreeNode p: dp(low+1, high)){
                    n.right = p;
                    res.add(n);
                    n = new TreeNode(i);
                }
            }
            else if (i == high){
                for (TreeNode p: dp(low, high-1)){
                    n.left = p;
                    res.add(n);
                    n = new TreeNode(i);
                }
            }
            else{
                for (TreeNode p: dp(low, i-1)){
                    for (TreeNode q: dp(i+1, high)){
                        n.left = p;
                        n.right = q;
                        res.add(n);
                        n = new TreeNode(i);
                    }
                }
            }
        }

        return res;
    }
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-Bitwise AND of Numbers Range(Java)]]></title>
      <url>http://yoursite.com/2016/01/24/Leetcode-Bitwise-AND-of-Numbers-Range/</url>
      <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive.</p>
<p>For example, given the range [5, 7], you should return 4.</p>
<p><strong>Thinking:</strong></p>
<p>It’s bitwise operation question. Some other questions like are Single Number, Single Number II, Reverse Bits, Repeated DNA Sequences, Grey Code and so on and so forth. This question’s point is to find all the numbers between the range and use the bitwise AND on them. </p>
<p>For example, in the range of [5, 7], there are three numbers:<br>101        110        111<br>Result of thier bitwise is 100. </p>
<p>What’s more, in the example of [26, 30]:<br>11010        11011        11100        11101        11110<br>The result is 11000.</p>
<p><em>Because bits are incresing from the right</em> (low digits), the left of all the numbers are not going to change in the process. The thing we need to do is finding the common part of the left. There are two solutions:</p>
<p><strong>Solution1:</strong></p>
<p>Idea: State a variable and make it all 1 in all digits. Make the variable left shift every time to check if it’s equal between m and n of their bitwise AND. Finally, the result of m bitwise AND with the variable is the answer.<br>Code:</p>
<pre><code>class Solution {
public int rangeBitwiseAnd(int m, int n) {
        int d = Integer.MAX_VALUE;
        while ((m &amp; d) != (n &amp; d)) {
            d &lt;&lt;= 1;
        }
        return m &amp; d;
    }
};
</code></pre><p><strong>Solution2:</strong></p>
<p>Idea:Let m and n make left shift each time if they are different and record the times i they shift. When they are equal, the result of m left shift i is the answer.<br>Code:</p>
<pre><code>class Solution {
public int rangeBitwiseAnd(int m, int n) {
        int i = 0;
        while (m != n) {
            m &gt;&gt;= 1;
            n &gt;&gt;= 1;
            ++i;
        }
        return (m &lt;&lt; i);
    }
};
</code></pre><p>Reference: <a href="http://www.cnblogs.com/grandyang/p/4431646.html" target="_blank" rel="external">http://www.cnblogs.com/grandyang/p/4431646.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://yoursite.com/2016/01/24/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start"><a href="#Quick_Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create_a_new_post"><a href="#Create_a_new_post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server"><a href="#Run_server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files"><a href="#Generate_static_files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites"><a href="#Deploy_to_remote_sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
