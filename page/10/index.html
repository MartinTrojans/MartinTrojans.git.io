<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 10 頁 | Martin&#39;s Blog</title>
  <meta name="author" content="Martin">
  
  <meta name="description" content="A rookie write something just for fun.">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Martin&#39;s Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">Martin&#39;s Blog</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header">
  <h1>Martin&#39;s Blog</h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">
      <i class="fa fa-heart"></i>
      Yet another bootstrap theme.
</div>    
		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-01-24 </div>
			<div class="article-title"><a href="/2016/01/24/Leetcode-Search-for-a-Range-Java/" >Leetcode-Search for a Range(Java)</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p><strong>Question:</strong></p>
<p>Given a sorted array of integers, find the starting and ending position of a given target value.</p>
<p>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
<p>If the target is not found in the array, return [-1, -1].</p>
<p>For example,<br>Given [5, 7, 7, 8, 8, 10] and target value 8,<br>return [3, 4].</p>
<p><strong>Thinking:</strong></p>
<p>It’s question which should use binary search because it give us a sorted array and it requires O(log n) runtime complexity. Only thing difference between this algorithm and classical binary search is that we should make the range smaller while finding the target instead of returning the index.</p>
<p><strong>Solution:</strong></p>
<pre><code>public class Solution {
    public int[] searchRange(int[] nums, int target) {
        int low = 0;
        int high = nums.length - 1;
        int mid;
        int resl = -1;
        int resr = -1;
        while (low &lt;= high){
            mid = (low + high) / 2;
            if (nums[mid] == target){
                if (nums[low] == target){
                    resl = low;
                    if (resr != -1)
                        break;
                }    
                else
                    low++;

                if (nums[high] == target){
                    resr = high;
                    if (resl != -1)
                        break;
                }
                else
                    high--;
            }
            else if(nums[mid] &gt; target)
                high = mid - 1;
            else
                low = mid + 1;
        }
        int[] res = {resl, resr};
        return res;
    }

}
</code></pre><p>But the algorithm is not so effienct when finding the target so early. In order to make sure the runtime complexity is O(log n), we should also use binary search to find the lower bound and upper bound when finding the target in the array.<br>Reference: <a href="http://www.cnblogs.com/springfor/p/3857704.html" target="_blank" rel="external">http://www.cnblogs.com/springfor/p/3857704.html</a></p>
<p>Code:</p>
<pre><code>public int[] searchRange(int[] A, int target) {
    int [] res = {-1,-1};
    if(A == null || A.length == 0)
        return res;

    //first iteration, find target wherever it is
    int low = 0;
    int high = A.length-1;
    int pos = 0;
    while(low &lt;= high){
        int mid = (low + high)/2;
        pos = mid;
        if(A[mid] &gt; target)
            high = mid - 1;
        else if(A[mid] &lt; target)
            low = mid + 1;
        else{
            res[0] = pos;
            res[1] = pos;
            break;
        }
    }

    if(A[pos] != target)
        return res;

    //second iteration, find the right boundary of this target
    int newlow = pos;
    int newhigh = A.length-1;
    while(newlow &lt;= newhigh){
        int newmid = (newlow+newhigh)/2;
        if(A[newmid] == target)
            newlow = newmid + 1;
        else
            newhigh = newmid - 1;
    }
    res[1] = newhigh;

    //third iteration, find the left boundary of this target
    newlow = 0;
    newhigh = pos;
    while(newlow &lt;= newhigh){
        int newmid = (newlow+newhigh)/2;
        if(A[newmid] == target)
            newhigh = newmid - 1;
        else
            newlow = newmid + 1;
    }
    res[0] = newlow;

    return res;
}
</code></pre>
	
	</div>
  <a type="button" href="/2016/01/24/Leetcode-Search-for-a-Range-Java/#more" class="btn btn-default more">閱讀本文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-01-24 </div>
			<div class="article-title"><a href="/2016/01/24/Leetcode-Partition-List/" >Leetcode-Partition List(Java)</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p><strong>Question:</strong></p>
<p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p>
<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p>For example,<br>Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,<br>return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.</p>
<p><strong>Thinking:</strong></p>
<p>We should preserve the original relative order of the nodes. So we need two points, one is for recording where to insert the less value node, and the other is for searching the less value node.</p>
<p><strong>Solution1:</strong></p>
<pre><code>public class Solution {
    public ListNode partition(ListNode head, int x) {
        if (head == null)
            return null;
        ListNode prehead = new ListNode(0);
        prehead.next = head;
        ListNode s = prehead;
        ListNode l = prehead;
        while(s != null &amp;&amp; l != null){
            while(s.next != null){
                if (s.next.val &gt;= x)
                    break;
                s = s.next;
            }
            l = s.next;
            if (l == null)
                break;
            while(l.next != null){
                if (l.next.val &lt; x)
                    break;
                l = l.next;
            }
            if (l.next == null)
                break;
            ListNode tmp = l.next;
            l.next = l.next.next;
            tmp.next = s.next;
            s.next = tmp;
        }

        return prehead.next;
    }

}
</code></pre><p>And there is another solution, which uses two lists. One is for recording less value node, and the other is for recording greater value node. And connect them:</p>
<pre><code>public ListNode partition(ListNode head, int x) {
        if(head==null||head.next==null)
            return head;

        ListNode small = new ListNode(-1);
        ListNode newsmallhead = small;
        ListNode big = new ListNode(-1);
        ListNode newbighead = big;

        while(head!=null){
            if(head.val&lt;x){
                small.next = head;
                small = small.next;
            }else{
                big.next = head;
                big = big.next;
            }
            head = head.next;
        }
        big.next = null;

        small.next = newbighead.next;

        return newsmallhead.next;
}
</code></pre>
	
	</div>
  <a type="button" href="/2016/01/24/Leetcode-Partition-List/#more" class="btn btn-default more">閱讀本文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-01-24 </div>
			<div class="article-title"><a href="/2016/01/24/Leetcode-Unique-Paths-II-Java/" >Leetcode-Unique Paths II(Java)</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p><strong>Question:</strong></p>
<p>Follow up for “Unique Paths”:</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<p>An obstacle and empty space is marked as 1 and 0 respectively in the grid.</p>
<p>For example,<br>There is one obstacle in the middle of a 3x3 grid as illustrated below.</p>
<pre><code>[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
</code></pre><p>The total number of unique paths is 2.</p>
<p>Note: m and n will be at most 100.</p>
<p><strong>Thinking:</strong></p>
<p>This question is similar with Unique Paths, and it’s the same methed to use dynamic programming. Only one difference is that we should check if it’s a obstacle. And if it’s a obstacle, its value of dp should be 0.</p>
<p><strong>Solution:</strong></p>
<pre><code>public class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int lr = obstacleGrid.length;
        if (lr == 0)
            return 0;
        int lc = obstacleGrid[0].length;
        int[][] dp = new int[lr][lc];
        if (obstacleGrid[0][0] == 1){
            return 0;
        }
        dp[0][0] = 1;

        for (int i = 1; i &lt; lr; i++){
            if (obstacleGrid[i][0] == 1)
                break;
            dp[i][0] = 1;
        }
        for (int i = 1; i &lt; lc; i++){
            if (obstacleGrid[0][i] == 1)
                break;
            dp[0][i] = 1;
        }

        for (int i = 1; i &lt; lr; i++)
            for (int j = 1; j &lt; lc; j++){
                if(obstacleGrid[i][j] == 1)
                    continue;
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }

        return dp[lr-1][lc-1];
    }
}
</code></pre>
	
	</div>
  <a type="button" href="/2016/01/24/Leetcode-Unique-Paths-II-Java/#more" class="btn btn-default more">閱讀本文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-01-24 </div>
			<div class="article-title"><a href="/2016/01/24/Unique-Binary-Search-Trees-II/" >Leetcode-Unique Binary Search Trees II(Java)</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p><strong>Question:</strong></p>
<p>Given n, generate all structurally unique BST’s (binary search trees) that store values 1…n.</p>
<p>For example,<br>Given n = 3, your program should return all 5 unique BST’s shown below.</p>
<pre><code>1         3     3      2      1
 \       /     /      / \      \
  3     2     1      1   3      2
 /     /       \                 \
2     1         2                 3
</code></pre><p><strong>Thinking:</strong> </p>
<p>It’s a simple dynamic programming question. For n numbers, we should consider the situation that every one become the root, and delete it from the sets and do the same thing for their children.</p>
<p><strong>Solution:</strong></p>
<pre><code>public class Solution {
    public List&lt;TreeNode&gt; generateTrees(int n) {
        return dp(1, n);
    }

    public List&lt;TreeNode&gt; dp(int low, int high){
        List&lt;TreeNode&gt; res = new ArrayList&lt;TreeNode&gt;();
        if (low == high){
            TreeNode n = new TreeNode(low);
            res.add(n);
            return res;
        }
        for (int i = low; i &lt;= high; i++){
            TreeNode n = new TreeNode(i);
            if (i == low){
                for (TreeNode p: dp(low+1, high)){
                    n.right = p;
                    res.add(n);
                    n = new TreeNode(i);
                }
            }
            else if (i == high){
                for (TreeNode p: dp(low, high-1)){
                    n.left = p;
                    res.add(n);
                    n = new TreeNode(i);
                }
            }
            else{
                for (TreeNode p: dp(low, i-1)){
                    for (TreeNode q: dp(i+1, high)){
                        n.left = p;
                        n.right = q;
                        res.add(n);
                        n = new TreeNode(i);
                    }
                }
            }
        }

        return res;
    }
}
</code></pre>
	
	</div>
  <a type="button" href="/2016/01/24/Unique-Binary-Search-Trees-II/#more" class="btn btn-default more">閱讀本文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-01-24 </div>
			<div class="article-title"><a href="/2016/01/24/Leetcode-Bitwise-AND-of-Numbers-Range/" >Leetcode-Bitwise AND of Numbers Range(Java)</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p><strong>Question:</strong></p>
<p>Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive.</p>
<p>For example, given the range [5, 7], you should return 4.</p>
<p><strong>Thinking:</strong></p>
<p>It’s bitwise operation question. Some other questions like are Single Number, Single Number II, Reverse Bits, Repeated DNA Sequences, Grey Code and so on and so forth. This question’s point is to find all the numbers between the range and use the bitwise AND on them. </p>
<p>For example, in the range of [5, 7], there are three numbers:<br>101        110        111<br>Result of thier bitwise is 100. </p>
<p>What’s more, in the example of [26, 30]:<br>11010        11011        11100        11101        11110<br>The result is 11000.</p>
<p><em>Because bits are incresing from the right</em> (low digits), the left of all the numbers are not going to change in the process. The thing we need to do is finding the common part of the left. There are two solutions:</p>
<p><strong>Solution1:</strong></p>
<p>Idea: State a variable and make it all 1 in all digits. Make the variable left shift every time to check if it’s equal between m and n of their bitwise AND. Finally, the result of m bitwise AND with the variable is the answer.<br>Code:</p>
<pre><code>class Solution {
public int rangeBitwiseAnd(int m, int n) {
        int d = Integer.MAX_VALUE;
        while ((m &amp; d) != (n &amp; d)) {
            d &lt;&lt;= 1;
        }
        return m &amp; d;
    }
};
</code></pre><p><strong>Solution2:</strong></p>
<p>Idea:Let m and n make left shift each time if they are different and record the times i they shift. When they are equal, the result of m left shift i is the answer.<br>Code:</p>
<pre><code>class Solution {
public int rangeBitwiseAnd(int m, int n) {
        int i = 0;
        while (m != n) {
            m &gt;&gt;= 1;
            n &gt;&gt;= 1;
            ++i;
        }
        return (m &lt;&lt; i);
    }
};
</code></pre><p>Reference: <a href="http://www.cnblogs.com/grandyang/p/4431646.html" target="_blank" rel="external">http://www.cnblogs.com/grandyang/p/4431646.html</a></p>

	
	</div>
  <a type="button" href="/2016/01/24/Leetcode-Bitwise-AND-of-Numbers-Range/#more" class="btn btn-default more">閱讀本文</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">
<ul class="pagination">
	 
		
    	<li class="prev"><a href="/page/9/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i> 上一頁</a></li>
  		

        <li><a href="/"><i class="fa fa-home"></i>Home</a></li>

		
          <li class="next disabled"><a>下一頁<i class="fa fa-arrow-circle-o-right"></i></a></li>
        
	
</ul>
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="搜尋" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
	<div class="widget">
		<h4>分類</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/Algorithm/">Algorithm<span>2</span></a></li>
		
			<li><a href="/categories/Leetcode/">Leetcode<span>41</span></a></li>
		
			<li><a href="/categories/Network/">Network<span>1</span></a></li>
		
			<li><a href="/categories/Web/">Web<span>1</span></a></li>
		
			<li><a href="/categories/uncategoried/">uncategoried<span>1</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>標籤雲</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/String/">String<span>2</span></a></li>
		
			<li><a href="/tags/Backtracing/">Backtracing<span>4</span></a></li>
		
			<li><a href="/tags/Divide-and-Conquer/">Divide and Conquer<span>1</span></a></li>
		
			<li><a href="/tags/Stack/">Stack<span>1</span></a></li>
		
			<li><a href="/tags/Tree/">Tree<span>1</span></a></li>
		
			<li><a href="/tags/Hash-Table/">Hash Table<span>3</span></a></li>
		
			<li><a href="/tags/Array/">Array<span>7</span></a></li>
		
			<li><a href="/tags/Bit-Manipulation/">Bit Manipulation<span>1</span></a></li>
		
			<li><a href="/tags/Topological-Sort/">Topological Sort<span>1</span></a></li>
		
			<li><a href="/tags/Heap/">Heap<span>2</span></a></li>
		
			<li><a href="/tags/BFS/">BFS<span>4</span></a></li>
		
			<li><a href="/tags/Two-Pointers/">Two Pointers<span>1</span></a></li>
		
			<li><a href="/tags/Two-Points/">Two Points<span>2</span></a></li>
		
			<li><a href="/tags/Design/">Design<span>2</span></a></li>
		
			<li><a href="/tags/Binary-Search/">Binary Search<span>2</span></a></li>
		
			<li><a href="/tags/Graph/">Graph<span>3</span></a></li>
		
			<li><a href="/tags/Math/">Math<span>2</span></a></li>
		
			<li><a href="/tags/Trie/">Trie<span>1</span></a></li>
		
			<li><a href="/tags/DFS/">DFS<span>2</span></a></li>
		
			<li><a href="/tags/Greedy/">Greedy<span>2</span></a></li>
		
		
		   <li><a href="/tags">...<span>23</span></a></li>
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>最新文章</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2016/02/10/Leetcode-Majority-Element-II-Java/" ><i class="fa fa-file-o"></i>Leetcode-Majority Element I...</a>
      </li>
    
      <li>
        <a href="/2016/02/10/Leetcode-Implement-Trie-Prefix-Tree-Java/" ><i class="fa fa-file-o"></i>Leetcode-Implement Trie (Pr...</a>
      </li>
    
      <li>
        <a href="/2016/02/10/Leetcode-Sqrt-x-Java/" ><i class="fa fa-file-o"></i>Leetcode-Sqrt(x)(Java)...</a>
      </li>
    
      <li>
        <a href="/2016/02/10/Leetcode-Course-Schedule-Java/" ><i class="fa fa-file-o"></i>Leetcode-Course Schedule(Ja...</a>
      </li>
    
      <li>
        <a href="/2016/02/09/Leetcode-Minimum-Height-Trees-Java/" ><i class="fa fa-file-o"></i>Leetcode-Minimum Height Tre...</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>鏈接</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="https://github.com/wzpan/hexo-theme-freemind" title="Freemind's Github repository." target="_blank"]);">Freemind</a></li>
	
		<li><i class="fa fa-github"></i><a href="https://github.com/MartinTrojans" title="My Github account." target="_blank"]);">My Github</a></li>
	
		<li><i class="fa fa-linkedin"></i><a href="http://www.linkedin.com/in/hahack" title="My Linkin account." target="_blank"]);">My LinkedIn</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2016 Martin
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
