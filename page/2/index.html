<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Martin&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="A rookie write something just for fun.">
<meta property="og:type" content="website">
<meta property="og:title" content="Martin's Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Martin's Blog">
<meta property="og:description" content="A rookie write something just for fun.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Martin's Blog">
<meta name="twitter:description" content="A rookie write something just for fun.">
  
    <link rel="alternate" href="/atom.xml" title="Martin&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Martin&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Leetcode-Lowest-Common-Ancestor-of-a-Binary-Tree-Java" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/26/Leetcode-Lowest-Common-Ancestor-of-a-Binary-Tree-Java/" class="article-date">
  <time datetime="2016-01-26T23:18:55.000Z" itemprop="datePublished">2016-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/26/Leetcode-Lowest-Common-Ancestor-of-a-Binary-Tree-Java/">Leetcode-Lowest Common Ancestor of a Binary Tree(Java)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>Question:</strong></p>
<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”</p>
<pre><code>           _______3______
         /              \
  ___5__           ___1___
    /      \         /          \
6        2       0         8
         /  \
        7    4
</code></pre><p>For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</p>
<p><strong>Thinking:</strong></p>
<p>The point to find the lowest common ancestor is to find a node whose left and right childs both have the node we want to find. Because if it’s not the lowest, the node will only belong to one of their child. If search in a pre-order from the root, if one node’s left child and right child both have the keynode or if the node itself is one of the keynode which means the other node will in lower level of this node, it’s the answer we want.</p>
<p><strong>Solution:</strong></p>
<pre><code>public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null)
        return root;

    if (root.equals(q) || root.equals(p)){
        return root;
    }

    TreeNode l = lowestCommonAncestor(root.left, p, q);
    TreeNode r = lowestCommonAncestor(root.right, p, q);
    if (l != null &amp;&amp; r != null)
        return root;

    return l == null? r: l;
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/26/Leetcode-Lowest-Common-Ancestor-of-a-Binary-Tree-Java/" data-id="cijwghzd6000e3yowr7l64u6d" class="article-share-link">Share</a>
      
        <a href="http://yoursite.com/2016/01/26/Leetcode-Lowest-Common-Ancestor-of-a-Binary-Tree-Java/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Node-js-study-note" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/25/Node-js-study-note/" class="article-date">
  <time datetime="2016-01-26T05:11:55.000Z" itemprop="datePublished">2016-01-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/25/Node-js-study-note/">Node.js study note</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>Survey:</strong></p>
<p>Node.js is an open-source, cross-platform runtime environment for developing server-side Web applications. Node.js is not a JavaScript framework,[3] but its applications are written in JavaScript and can be run within the Node.js runtime on a wide variety of platforms.</p>
<p>This is my first time to learn Node.js, and I’ll write casully about the process and experience of learning.</p>
<hr>
<p><strong>Content:</strong></p>
<p>–1– Argument variables with process.argv</p>
<pre><code>app.js

function grab(flag){
    var index = process.argv.indexOf(flag);
    return (index === -1) ? null : process.argv[index+1];
}

var greeting = grab(&apos;--greeting&apos;);
var user = grab(&apos;--user&apos;);

if (!user || !greeting) {
    console.log(&quot;You blew it!&quot;);
} else {
    console.log(`Welcome, ${user}, ${greeting}`);
}
</code></pre><p>In this code, we grab the arguments from shell and print it out on the console.</p>
<p>For example, if in the shell:</p>
<pre><code>$node app --user Martin --greeting &quot;hello hello&quot;
</code></pre><p>Then in the console:</p>
<pre><code>Welcome, Martin, hello hello
</code></pre><p>And in this code, I also learned string temple which uses backticks<code>.</code>Welcome, ${user}, ${greeting}` will contain variable user and greeting.</p>
<hr>
<p>–2– Standard input and standard output</p>
<pre><code> var questions = [
&quot;What is your name?&quot;,
&quot;What is your favorite hobby?&quot;,
&quot;What is your preferred programming language?&quot;
];

var answers = [];

function ask(i) {
    process.stdout.write(`\n\n\n\n ${questions[i]}`);
    process.stdout.write(&quot;  &gt;  &quot;);
}

process.stdin.on(&apos;data&apos;, function(data){

    answers.push(data.toString().trim());

    if (answers.length &lt; questions.length) {
        ask(answers.length);
    } else {
        process.exit();
    }
});

process.on(&apos;exit&apos;, function(){

    process.stdout.write(&quot;\n\n\n\n&quot;);

    process.stdout.write(`Go ${answers[1]} ${answers[0]} you can finish writing ${answers[2]} later`);

    process.stdout.write(&quot;\n\n\n\n&quot;);

});

ask(0);
</code></pre><p>In the shell:</p>
<pre><code>What is your name?  &gt;  Martin




 What is your favorite hobby?  &gt;  play games




 What is your preferred programming language?  &gt;  python




Go play games Martin you can finish writing python later
</code></pre><p>Is that funny:)?</p>
<hr>
<p>–3– Globla timing functions</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/25/Node-js-study-note/" data-id="cijwghzcr00083yowwrdvn4ok" class="article-share-link">Share</a>
      
        <a href="http://yoursite.com/2016/01/25/Node-js-study-note/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Leetcode-Insertion-Sort-List-Java" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/24/Leetcode-Insertion-Sort-List-Java/" class="article-date">
  <time datetime="2016-01-25T05:07:32.000Z" itemprop="datePublished">2016-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/24/Leetcode-Insertion-Sort-List-Java/">Leetcode-Insertion Sort List(Java)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>Question:</strong></p>
<p>Sort a linked list using insertion sort.</p>
<p><strong>Thinking:</strong></p>
<p>As the question state, we should apply the insertion sort method to linked list. So we create a ListNode for hold the sorted list, and scan the unsorted list and pick up element to compare the element in the sorted list. Then determine when to insert the value.</p>
<p><strong>Solution:</strong></p>
<pre><code>public class Solution {
    public ListNode insertionSortList(ListNode head) {
        if (head == null || head.next == null)
            return head;
        ListNode res = new ListNode(-1);
        res.next = head;
        ListNode p = res;
        ListNode next = head.next;
        head.next = null;
        head = next;
        while (head != null){
            while (p.next != null){
                //if the value is smaller than one of the sorted list, insert behind it
                if (head.val &lt; p.next.val){
                    next = head.next;
                    head.next = p.next;
                    p.next = head;
                    head = next;
                    p = res;
                    break;
                }
                p = p.next;
            }
            //if the value is bigger than anyone of the sorted list, insert after the whole list
            if (p.next == null){
                next = head.next;
                p.next = head;
                head.next = null;
                head = next;
                p = res;
            }
        }

        return res.next;
    }
}
</code></pre><p>I also copy a refining version of this algorithm from reference: <a href="http://www.cnblogs.com/springfor/p/3862468.html" target="_blank" rel="external">http://www.cnblogs.com/springfor/p/3862468.html</a></p>
<pre><code>public ListNode insertionSortList(ListNode head) {  
    if(head == null||head.next == null)  
        return head;  
    ListNode sortedlisthead = new ListNode(0);  
    ListNode cur = head;
    while(cur!=null){  
        ListNode next = cur.next;  
        ListNode pre = sortedlisthead;  
        while(pre.next!=null &amp;&amp; pre.next.val&lt;cur.val)  
            pre = pre.next;  
        cur.next = pre.next;  
        pre.next = cur;  
        cur = next;  
    }  
    return sortedlisthead.next;  
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/24/Leetcode-Insertion-Sort-List-Java/" data-id="cijwghzda000g3yowyinz4zn7" class="article-share-link">Share</a>
      
        <a href="http://yoursite.com/2016/01/24/Leetcode-Insertion-Sort-List-Java/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Sort-Algorithms" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/24/Sort-Algorithms/" class="article-date">
  <time datetime="2016-01-25T04:07:31.000Z" itemprop="datePublished">2016-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/24/Sort-Algorithms/">Sort Algorithms</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Survey_3A"><a href="#Survey_3A" class="headerlink" title="Survey:"></a>Survey:</h2><p>This time, we talk about eight kinds of sort algorithms: insertion sort, shell’s sort, simple selection sort, heap sort, bubble sort, quick sort, merge sort and radix sort.</p>
<h2 id="Insertion_sort_3A"><a href="#Insertion_sort_3A" class="headerlink" title="Insertion sort:"></a>Insertion sort:</h2><p><strong>Main Idea:</strong></p>
<p>From the beginning of the list, get one value at a time and insert the value into right position of sorted list until all the values are sorted. And insertion sort is stalbe.</p>
<p><strong>Process:</strong> (From Wikimedia)</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/4/42/Insertion_sort.gif" alt=""></p>
<p><strong>Pseudocode:</strong></p>
<pre><code>for i ← 1 to length(A) - 1
    j ← i
    while j &gt; 0 and A[j-1] &gt; A[j]
        swap A[j] and A[j-1]
        j ← j - 1
    end while
end for
</code></pre><p><strong>Implemention in Java:</strong></p>
<pre><code>public static void InsertionSort(int[] num)
{
     int j;
     int key;
     int i;  

     for (j = 1; j &lt; num.length; j++){
        key = num[j];
        for(i = j - 1; (i &gt;= 0) &amp;&amp; (num[i] &lt; key); i--){
            num[i+1] = num[i];
        }
        num[i+1] = key;
    }
}
</code></pre><p><strong>Complexity:</strong></p>
<p><em>Runtime</em>: O(n^2)</p>
<p><em>Memery</em>: O(1)</p>
<hr>
<h2 id="ShellSort_3A"><a href="#ShellSort_3A" class="headerlink" title="ShellSort:"></a>ShellSort:</h2><p><strong>Main Idea:</strong></p>
<p>The method starts by sorting pairs of elements far apart from each other, then progressively reducing the gap between elements to be compared. Starting with far apart elements can move some out-of-place elements into position faster than a simple nearest neighbor exchange.</p>
<p><strong>Process:</strong>(From Wikimedia)</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/d/d8/Sorting_shellsort_anim.gif" alt=""></p>
<p><strong>Pesedocode:</strong></p>
<pre><code>gaps = [701, 301, 132, 57, 23, 10, 4, 1]

foreach (gap in gaps)
{
    # Do a gapped insertion sort for this gap size.
    # The first gap elements a[0..gap-1] are already in gapped order
    # keep adding one more element until the entire array is gap sorted
    for (i = gap; i &lt; n; i += 1)
    {
        # add a[i] to the elements that have been gap sorted
        # save a[i] in temp and make a hole at position i
        temp = a[i]
        # shift earlier gap-sorted elements up until the correct location for a[i] is found
        for (j = i; j &gt;= gap and a[j - gap] &gt; temp; j -= gap)
        {
            a[j] = a[j - gap]
        }
        # put temp (the original a[i]) in its correct location
        a[j] = temp
        }
    }
</code></pre><p> <strong>Implemention in Java:</strong></p>
<pre><code>public void shellSort() {
    int inner, outer;
    long temp;
    //find initial value of h
    int h = 1;
    while (h &lt;= len / 3)
      h = h * 3 + 1; // (1, 4, 13, 40, 121, ...)

    while (h &gt; 0) // decreasing h, until h=1
    {
      // h-sort the file
      for (outer = h; outer &lt; len; outer++) {
        temp = data[outer];
        inner = outer;
        // one subpass (eg 0, 4, 8)
        while (inner &gt; h - 1 &amp;&amp; data[inner - h] &gt;= temp) {
          data[inner] = data[inner - h];
          inner -= h;
        }
        data[inner] = temp;
      }
      h = (h - 1) / 3; // decrease h
    }
}
</code></pre><hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/24/Sort-Algorithms/" data-id="cijwghzcq00073yowt2t406gj" class="article-share-link">Share</a>
      
        <a href="http://yoursite.com/2016/01/24/Sort-Algorithms/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Leetcode-Search-for-a-Range-Java" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/24/Leetcode-Search-for-a-Range-Java/" class="article-date">
  <time datetime="2016-01-25T03:50:20.000Z" itemprop="datePublished">2016-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/24/Leetcode-Search-for-a-Range-Java/">Leetcode-Search for a Range(Java)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>Question:</strong></p>
<p>Given a sorted array of integers, find the starting and ending position of a given target value.</p>
<p>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
<p>If the target is not found in the array, return [-1, -1].</p>
<p>For example,<br>Given [5, 7, 7, 8, 8, 10] and target value 8,<br>return [3, 4].</p>
<p><strong>Thinking:</strong></p>
<p>It’s question which should use binary search because it give us a sorted array and it requires O(log n) runtime complexity. Only thing difference between this algorithm and classical binary search is that we should make the range smaller while finding the target instead of returning the index.</p>
<p><strong>Solution:</strong></p>
<pre><code>public class Solution {
    public int[] searchRange(int[] nums, int target) {
        int low = 0;
        int high = nums.length - 1;
        int mid;
        int resl = -1;
        int resr = -1;
        while (low &lt;= high){
            mid = (low + high) / 2;
            if (nums[mid] == target){
                if (nums[low] == target){
                    resl = low;
                    if (resr != -1)
                        break;
                }    
                else
                    low++;

                if (nums[high] == target){
                    resr = high;
                    if (resl != -1)
                        break;
                }
                else
                    high--;
            }
            else if(nums[mid] &gt; target)
                high = mid - 1;
            else
                low = mid + 1;
        }
        int[] res = {resl, resr};
        return res;
    }

}
</code></pre><p>But the algorithm is not so effienct when finding the target so early. In order to make sure the runtime complexity is O(log n), we should also use binary search to find the lower bound and upper bound when finding the target in the array.<br>Reference: <a href="http://www.cnblogs.com/springfor/p/3857704.html" target="_blank" rel="external">http://www.cnblogs.com/springfor/p/3857704.html</a></p>
<p>Code:</p>
<pre><code>public int[] searchRange(int[] A, int target) {
    int [] res = {-1,-1};
    if(A == null || A.length == 0)
        return res;

    //first iteration, find target wherever it is
    int low = 0;
    int high = A.length-1;
    int pos = 0;
    while(low &lt;= high){
        int mid = (low + high)/2;
        pos = mid;
        if(A[mid] &gt; target)
            high = mid - 1;
        else if(A[mid] &lt; target)
            low = mid + 1;
        else{
            res[0] = pos;
            res[1] = pos;
            break;
        }
    }

    if(A[pos] != target)
        return res;

    //second iteration, find the right boundary of this target
    int newlow = pos;
    int newhigh = A.length-1;
    while(newlow &lt;= newhigh){
        int newmid = (newlow+newhigh)/2;
        if(A[newmid] == target)
            newlow = newmid + 1;
        else
            newhigh = newmid - 1;
    }
    res[1] = newhigh;

    //third iteration, find the left boundary of this target
    newlow = 0;
    newhigh = pos;
    while(newlow &lt;= newhigh){
        int newmid = (newlow+newhigh)/2;
        if(A[newmid] == target)
            newhigh = newmid - 1;
        else
            newlow = newmid + 1;
    }
    res[0] = newlow;

    return res;
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/24/Leetcode-Search-for-a-Range-Java/" data-id="cijwghzcz000b3yowy885v6p2" class="article-share-link">Share</a>
      
        <a href="http://yoursite.com/2016/01/24/Leetcode-Search-for-a-Range-Java/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/01/26/Leetcode-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Java/">Leetcode-Construct Binary Tree from Preorder and Inorder Traversal(Java)</a>
          </li>
        
          <li>
            <a href="/2016/01/26/Leetcode-Pow-x-n-Java/">Leetcode-Pow(x, n)(Java)</a>
          </li>
        
          <li>
            <a href="/2016/01/26/Leetcode-Jump-Game-Java/">Leetcode-Jump Game(Java)</a>
          </li>
        
          <li>
            <a href="/2016/01/26/Leetcode-3Sum-Closest-Java/">Leetcode-3Sum Closest(Java)</a>
          </li>
        
          <li>
            <a href="/2016/01/26/Leetcode-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-Java/">Leetcode-Construct Binary Tree from Inorder and Postorder Traversal(Java)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Martin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'communitydeveloper';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>