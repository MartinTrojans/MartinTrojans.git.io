<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 2 頁 | Martin&#39;s Blog</title>
  <meta name="author" content="Martin">
  
  <meta name="description" content="A rookie write something just for fun.">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Martin&#39;s Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">Martin&#39;s Blog</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header">
  <h1>Martin&#39;s Blog</h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">
      <i class="fa fa-heart"></i>
      Yet another bootstrap theme.
</div>    
		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-02-10 </div>
			<div class="article-title"><a href="/2016/02/10/Leetcode-Sqrt-x-Java/" >Leetcode-Sqrt(x)(Java)</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p><strong>Question:</strong></p>
<p>Implement int sqrt(int x).</p>
<p>Compute and return the square root of x.</p>
<p><strong>Thinking:</strong></p>
<p>We can get the answer using bianry search from the range of integer.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int mySqrt(int x) {
    if ( x &lt;= 1 )
        return x;
    int low = 1;
    int high = Integer.MAX_VALUE;
    while (true){
        int mid = low + (high - low) / 2; //in order to avoid overflow
        if (mid &gt; x / mid){
            high = mid - 1;
        }else{
            if ( (mid+1) &gt; x/(mid+1))
                return mid;
            low = mid + 1;
        }
    }
}
</code></pre>
	
	</div>
  <a type="button" href="/2016/02/10/Leetcode-Sqrt-x-Java/#more" class="btn btn-default more">閱讀本文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-02-10 </div>
			<div class="article-title"><a href="/2016/02/10/Leetcode-Course-Schedule-Java/" >Leetcode-Course Schedule(Java)</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p><strong>Question:</strong></p>
<p>There are a total of n courses you have to take, labeled from 0 to n - 1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p>
<p>For example:</p>
<p>2, [[1,0]]<br>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.</p>
<p>2, [[1,0],[0,1]]<br>There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</p>
<p>Note:<br>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.</p>
<p>click to show more hints.</p>
<p>Hints:<br>This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.<br>Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.<br>Topological sort could also be done via BFS.</p>
<p><strong>Thinking:</strong></p>
<p>We can search it from a arbitary node, can search by DFS. If there is a cycle, we will meet the visited nodes once DFS. So we need a array to hold the visited record. By the way, if we want a topological sort, we can hold a current value which is number of nodes initially and decrese one only when meet a sink node.</p>
<p>For BFS, we can find the nodes whose indegree or outdegree is zero, and search from them. If there is a cycle, the number of nodes searched will less than the exact number because in a cycle no nodes’ indegree or outdegree is zero.</p>
<p><strong>Solution:</strong></p>
<p>DFS:</p>
<pre><code>public boolean canFinish(int numCourses, int[][] prerequisites) {
    if (numCourses &lt;= 1)
        return true;
    ArrayList&lt;HashSet&lt;Integer&gt;&gt; edges = new ArrayList&lt;HashSet&lt;Integer&gt;&gt;(numCourses);
    boolean[] visited = new boolean[numCourses];

    for (int i = 0; i &lt; numCourses; i++)
        edges.add(new HashSet&lt;Integer&gt;());

    for (int[] pre: prerequisites){
        edges.get(pre[0]).add(pre[1]);
    }

    for (int i = 0; i &lt; numCourses; i++){
        if (edges.get(i).size() != 0)
            if (!dfs(edges, i, visited))
                return false;
    }

    return true;
}

private boolean dfs(ArrayList&lt;HashSet&lt;Integer&gt;&gt; edges, int i, boolean[] visited){
    if (visited[i] == true)
        return false;
    visited[i] = true;
    while (edges.get(i).size() != 0){
        int j = edges.get(i).iterator().next();

        if (!dfs(edges, j, visited))
            return false;

        edges.get(i).remove(j);
    }
    visited[i] = false; //there is a cycle only when once DFS, so we change it back when onece DFS is finished
    return true;
}
</code></pre><p>BFS:</p>
<pre><code>    public boolean canFinishBFS(int numCourses, int[][] prerequisites) {
    if (numCourses &lt;= 1)
        return true;
    ArrayList&lt;HashSet&lt;Integer&gt;&gt; edges = new ArrayList&lt;HashSet&lt;Integer&gt;&gt;(numCourses);
    int[] inDegree = new int[numCourses];
    Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;();
    int count = 0;

    for (int i = 0; i &lt; numCourses; i++)
        edges.add(new HashSet&lt;Integer&gt;());

    for (int[] pre: prerequisites){
        if (!edges.get(pre[0]).contains(pre[1])){
            edges.get(pre[0]).add(pre[1]);
            inDegree[pre[1]]++;
        }
    }

    for (int i = 0; i &lt; inDegree.length; i++)
        if (inDegree[i] == 0)
            q.add(i);

    while (!q.isEmpty()){
        int i = q.poll();
        count++;
        while (edges.get(i).size() != 0){
            int j = edges.get(i).iterator().next();
            if (--inDegree[j] == 0)
                q.add(j);
            edges.get(i).remove(j);
        }
    }

    return count == numCourses;
}
</code></pre><p>Simpler and more concise BFS solution:</p>
<p>Reference: <a href="https://leetcode.com/discuss/35578/easy-bfs-topological-sort-java" target="_blank" rel="external">https://leetcode.com/discuss/35578/easy-bfs-topological-sort-java</a></p>
<pre><code>public boolean canFinish(int numCourses, int[][] prerequisites) {
    int[][] matrix = new int[numCourses][numCourses]; // i -&gt; j
    int[] indegree = new int[numCourses];

    for (int i=0; i&lt;prerequisites.length; i++) {
        int ready = prerequisites[i][0];
        int pre = prerequisites[i][1];
        if (matrix[pre][ready] == 0)
            indegree[ready]++; //duplicate case
        matrix[pre][ready] = 1;
    }

    int count = 0;
    Queue&lt;Integer&gt; queue = new LinkedList();
    for (int i=0; i&lt;indegree.length; i++) {
        if (indegree[i] == 0) queue.offer(i);
    }
    while (!queue.isEmpty()) {
        int course = queue.poll();
        count++;
        for (int i=0; i&lt;numCourses; i++) {
            if (matrix[course][i] != 0) {
                if (--indegree[i] == 0)
                    queue.offer(i);
            }
        }
    }
    return count == numCourses;
}
</code></pre>
	
	</div>
  <a type="button" href="/2016/02/10/Leetcode-Course-Schedule-Java/#more" class="btn btn-default more">閱讀本文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-02-09 </div>
			<div class="article-title"><a href="/2016/02/09/Leetcode-Minimum-Height-Trees-Java/" >Leetcode-Minimum Height Trees(Java)</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p><strong>Question:</strong></p>
<p>For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.</p>
<p>Format<br>The graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels).</p>
<p>You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.</p>
<p>Example 1:</p>
<p>Given n = 4, edges = [[1, 0], [1, 2], [1, 3]]</p>
<pre><code>  0
  |
  1
 / \
2   3
</code></pre><p>return [1]</p>
<p>Example 2:</p>
<p>Given n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</p>
<pre><code>0  1  2
 \ | /
   3
   |
   4
   |
   5
</code></pre><p>return [3, 4]</p>
<p>Hint:</p>
<p>How many MHTs can a graph have at most?<br>Note:</p>
<p>(1) According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.”</p>
<p>(2) The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.</p>
<p><strong>Thinking:</strong></p>
<p>We should track the path from every leaves until there are only one or two nodes left. In other words, in the middle of the graph will be the root of the minimum height tree.</p>
<p><strong>Solution:</strong></p>
<pre><code>public List&lt;Integer&gt; findMinHeightTrees(int n, int[][] edges) {
    if (n == 1){
        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
        res.add(0);
        return res;
    }
    List&lt;Integer&gt; leaves = new ArrayList&lt;Integer&gt;();
    List&lt;Set&lt;Integer&gt;&gt; adj = new ArrayList&lt;Set&lt;Integer&gt;&gt;(n);
    for (int i = 0; i &lt; n; i++)
        adj.add(new HashSet&lt;Integer&gt;());
    for (int[] edge: edges){
        adj.get(edge[0]).add(edge[1]);
        adj.get(edge[1]).add(edge[0]);
    }
    for (int i = 0; i &lt; n; i++){
        if (adj.get(i).size() == 1)
            leaves.add(i);
    }

    while (n &gt; 2){
        n -= leaves.size();
        List&lt;Integer&gt; newLeaves = new ArrayList&lt;Integer&gt;();
        for (int i: leaves){
            int j = adj.get(i).iterator().next();
            adj.get(j).remove(i);
            if (adj.get(j).size() == 1)
                newLeaves.add(j);
        }
        leaves = newLeaves;
    }

    return leaves;
}
</code></pre><p>Reference:<a href="https://leetcode.com/discuss/71763/share-some-thoughts" target="_blank" rel="external">https://leetcode.com/discuss/71763/share-some-thoughts</a></p>
<p>My previous code(LTE):</p>
<pre><code>public List&lt;Integer&gt; findMinHeightTrees(int n, int[][] edges) {
    List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
    int min = Integer.MAX_VALUE;
    int res1 = -1;
    int res2 = -1;

    for (int i = 0; i &lt; n; i++){
        int temp = bfs(n, i, edges);
        if (temp &lt; min){
            min = temp;
            res1 = i;
        }
        else if (temp == min){
            res2 = i;
        }
    }

    if (res1 != -1)
        res.add(res1);
    if (res2 != -1)
        res.add(res2);

    return res;
}

private int bfs(int n, int i, int[][] edges){
    int height = 0;
    boolean[] used = new boolean[edges.length];
    Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;();
    q.add(i);

    while (!q.isEmpty()){
        int num = q.size();
        while (num &gt; 0){
            int temp = q.poll();
            for (int j = 0; j &lt; edges.length; j++){
                if (edges[j][0] == temp || edges[j][1] == temp){
                    if (used[j] == false){
                        if (edges[j][0] == temp)
                            q.add(edges[j][1]);
                        else
                            q.add(edges[j][0]);
                        used[j] = true;
                    }
                }
            }
            num--;
        }
        height++;
    }

    return height;
}
</code></pre>
	
	</div>
  <a type="button" href="/2016/02/09/Leetcode-Minimum-Height-Trees-Java/#more" class="btn btn-default more">閱讀本文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-02-09 </div>
			<div class="article-title"><a href="/2016/02/09/Leetcode-Next-Permutation-Java/" >Leetcode-Next Permutation(Java)</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p><strong>Question:</strong></p>
<p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place, do not allocate extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
<pre><code>1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
</code></pre><p><strong>Thinking:</strong></p>
<p>The method can be described as below:</p>
<p><img src="http://4.bp.blogspot.com/-4zN0u5JG0vs/UN0xPEkP5yI/AAAAAAAAG9Q/O48ZfwB1i_c/s640/Picture4.png" alt=""></p>
<p><strong>Solution:</strong></p>
<pre><code>public void nextPermutation(int[] nums) {
    if (nums == null || nums.length == 0)
        return;
    int i = nums.length - 2;
    while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i+1]){
        i--;
    }

    if (i == -1){
        reverse(nums, 0, nums.length-1);
        return;
    }

    int j = i+1;
    while (j &lt; nums.length &amp;&amp; nums[j] &gt; nums[i]){
        j++;
    }
    j--;
    swap(nums, i, j);
    reverse(nums, i+1, nums.length-1);

    return;
}
private void swap(int[] nums, int i, int j){
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
private void reverse(int[] nums, int i, int j){
    while (i &lt; j){
        swap(nums, i++, j--);
    }
}
</code></pre><p>Reference:<a href="http://fisherlei.blogspot.com/2012/12/leetcode-next-permutation.html" target="_blank" rel="external">http://fisherlei.blogspot.com/2012/12/leetcode-next-permutation.html</a><br><a href="http://www.cnblogs.com/springfor/p/3896245.html" target="_blank" rel="external">http://www.cnblogs.com/springfor/p/3896245.html</a></p>

	
	</div>
  <a type="button" href="/2016/02/09/Leetcode-Next-Permutation-Java/#more" class="btn btn-default more">閱讀本文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-02-09 </div>
			<div class="article-title"><a href="/2016/02/09/Leetcode-Minimum-Size-Subarray-Sum-Java/" >Leetcode-Minimum Size Subarray Sum(Java)</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p><strong>Question:</strong></p>
<p>Given an array of n positive integers and a positive integer s, find the minimal length of a subarray of which the sum ≥ s. If there isn’t one, return 0 instead.</p>
<p>For example, given the array [2,3,1,2,4,3] and s = 7,<br>the subarray [4,3] has the minimal length under the problem constraint.</p>
<p>click to show more practice.</p>
<p>More practice:<br>If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).</p>
<p><strong>Thinking:</strong></p>
<p>My method is to hold two pointers, one for current index and the other is for the start pointer. Once we find the sum is bigger than target, we increse the startIndex until its sum is smaller than target. Do it while find the minmun of the length.</p>
<p>But there is still more effienct way to solve this problem. We don’t need to reset the startIndex and sum, we just keep it. And it will be the O(n) solution. (Which called a minmum window method I suppose.)</p>
<p>What’s more, binary search is also valid for this problem. Since all elements are positive, the cumulative sum must be strictly increasing. Then, a subarray sum can expressed as the difference between two cumulative sum. Hence, given a start index for the cumulative sum array, the other end index can be searched using binary search.</p>
<p><strong>Solution:</strong></p>
<p>First version:</p>
<pre><code>public int minSubArrayLen(int s, int[] nums) {
    int min = Integer.MAX_VALUE;
    boolean flag = false;
    int temp = 0;
    int startIndex = 0;

    for ( int i = 0; i &lt; nums.length; i++ ){
         temp += nums[i];
         if (temp &gt;= s){
             while (temp &gt;= s){
                 flag = true;
                 temp -= nums[startIndex++];
             }
             int len = i - startIndex + 2;
             i = startIndex-1;
             if (len &lt; min)
                 min = len;
             temp = 0;
         }

    }
    if (flag)
        return min;
    else
        return 0;
}
</code></pre><p>Revised version:</p>
<pre><code>public int minSubArrayLen(int s, int[] nums) {
    int min = Integer.MAX_VALUE;
    boolean flag = false;
    int temp = 0;
    int startIndex = 0;

    for ( int i = 0; i &lt; nums.length; i++ ){
         temp += nums[i];
         if (temp &gt;= s){
             while (temp &gt;= s){
                 flag = true;
                 temp -= nums[startIndex++];
             }
             int len = i - startIndex + 2;
             if (len &lt; min)
                 min = len;
         }

    }
    if (flag)
        return min;
    else
        return 0;
}
</code></pre><p>Reference Code:(Including O(n) and O(nlgn))<br>Reference:<a href="https://leetcode.com/discuss/35378/solutions-java-with-time-complexity-nlogn-with-explanation" target="_blank" rel="external">https://leetcode.com/discuss/35378/solutions-java-with-time-complexity-nlogn-with-explanation</a></p>
<pre><code>public int minSubArrayLen(int s, int[] nums) {
    return solveNLogN(s, nums);
}

private int solveN(int s, int[] nums) {
    int start = 0, end = 0, sum = 0, minLen = Integer.MAX_VALUE;
    while (end &lt; nums.length) {
        while (end &lt; nums.length &amp;&amp; sum &lt; s) sum += nums[end++];
        if (sum &lt; s) break;
        while (start &lt; end &amp;&amp; sum &gt;= s) sum -= nums[start++];
        if (end - start + 1 &lt; minLen) minLen = end - start + 1;
    }
    return minLen == Integer.MAX_VALUE ? 0 : minLen;
}

private int solveNLogN(int s, int[] nums) {
    int[] sums = new int[nums.length + 1];
    for (int i = 1; i &lt; sums.length; i++) sums[i] = sums[i - 1] + nums[i - 1];
    int minLen = Integer.MAX_VALUE;
    for (int i = 0; i &lt; sums.length; i++) {
        int end = binarySearch(i + 1, sums.length - 1, sums[i] + s, sums);
        if (end == sums.length) break;
        if (end - i &lt; minLen) minLen = end - i;
    }
    return minLen == Integer.MAX_VALUE ? 0 : minLen;
}

private int binarySearch(int lo, int hi, int key, int[] sums) {
    while (lo &lt;= hi) {
       int mid = (lo + hi) / 2;
       if (sums[mid] &gt;= key){
           hi = mid - 1;
       } else {
           lo = mid + 1;
       }
    }
    return lo;
}
</code></pre>
	
	</div>
  <a type="button" href="/2016/02/09/Leetcode-Minimum-Size-Subarray-Sum-Java/#more" class="btn btn-default more">閱讀本文</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">
<ul class="pagination">
	 
		
    	<li class="prev"><a href="/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i> 上一頁</a></li>
  		

        <li><a href="/"><i class="fa fa-home"></i>Home</a></li>

		
		   <li class="next"> <a href="/page/3/" class="alignright next">下一頁<i class="fa fa-arrow-circle-o-right"></i></a> </li>          
        
	
</ul>
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="搜尋" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
	<div class="widget">
		<h4>分類</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/Algorithm/">Algorithm<span>2</span></a></li>
		
			<li><a href="/categories/Leetcode/">Leetcode<span>42</span></a></li>
		
			<li><a href="/categories/Network/">Network<span>1</span></a></li>
		
			<li><a href="/categories/Web/">Web<span>1</span></a></li>
		
			<li><a href="/categories/uncategoried/">uncategoried<span>1</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>標籤雲</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/BFS/">BFS<span>4</span></a></li>
		
			<li><a href="/tags/Bit-Manipulation/">Bit Manipulation<span>1</span></a></li>
		
			<li><a href="/tags/Hash-Table/">Hash Table<span>3</span></a></li>
		
			<li><a href="/tags/Binary-Search/">Binary Search<span>2</span></a></li>
		
			<li><a href="/tags/Greedy/">Greedy<span>2</span></a></li>
		
			<li><a href="/tags/Two-Points/">Two Points<span>2</span></a></li>
		
			<li><a href="/tags/Divide-and-Conquer/">Divide and Conquer<span>1</span></a></li>
		
			<li><a href="/tags/Two-Pointers/">Two Pointers<span>1</span></a></li>
		
			<li><a href="/tags/DFS/">DFS<span>2</span></a></li>
		
			<li><a href="/tags/Array/">Array<span>7</span></a></li>
		
			<li><a href="/tags/Trie/">Trie<span>1</span></a></li>
		
			<li><a href="/tags/Union-Find/">Union Find<span>1</span></a></li>
		
			<li><a href="/tags/Linked-List/">Linked List<span>2</span></a></li>
		
			<li><a href="/tags/Dynamic-Programming/">Dynamic Programming<span>2</span></a></li>
		
			<li><a href="/tags/Backtracing/">Backtracing<span>4</span></a></li>
		
			<li><a href="/tags/Math/">Math<span>2</span></a></li>
		
			<li><a href="/tags/Design/">Design<span>2</span></a></li>
		
			<li><a href="/tags/Topological-Sort/">Topological Sort<span>1</span></a></li>
		
			<li><a href="/tags/Graph/">Graph<span>3</span></a></li>
		
			<li><a href="/tags/String/">String<span>2</span></a></li>
		
		
		   <li><a href="/tags">...<span>23</span></a></li>
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>最新文章</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2016/02/14/Leetcode-Coin-Change-Java/" ><i class="fa fa-file-o"></i>Leetcode-Coin Change(Java)...</a>
      </li>
    
      <li>
        <a href="/2016/02/13/Some-basic-problems/" ><i class="fa fa-file-o"></i>Some basic problems...</a>
      </li>
    
      <li>
        <a href="/2016/02/13/Some-thoughts-about-interview/" ><i class="fa fa-file-o"></i>Some thoughts about intervi...</a>
      </li>
    
      <li>
        <a href="/2016/02/10/Leetcode-Majority-Element-II-Java/" ><i class="fa fa-file-o"></i>Leetcode-Majority Element I...</a>
      </li>
    
      <li>
        <a href="/2016/02/10/Leetcode-Implement-Trie-Prefix-Tree-Java/" ><i class="fa fa-file-o"></i>Leetcode-Implement Trie (Pr...</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>鏈接</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="https://github.com/wzpan/hexo-theme-freemind" title="Freemind's Github repository." target="_blank"]);">Freemind</a></li>
	
		<li><i class="fa fa-github"></i><a href="https://github.com/MartinTrojans" title="My Github account." target="_blank"]);">My Github</a></li>
	
		<li><i class="fa fa-linkedin"></i><a href="http://www.linkedin.com/in/hahack" title="My Linkin account." target="_blank"]);">My LinkedIn</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2016 Martin
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
