<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 5 頁 | Martin&#39;s Blog</title>
  <meta name="author" content="Martin">
  
  <meta name="description" content="A rookie write something just for fun.">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Martin&#39;s Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">Martin&#39;s Blog</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header">
  <h1>Martin&#39;s Blog</h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">
      <i class="fa fa-heart"></i>
      Yet another bootstrap theme.
</div>    
		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-02-02 </div>
			<div class="article-title"><a href="/2016/02/02/Patching-Array-Java/" >Patching Array(Java)</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p><strong>Question:</strong></p>
<p>Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.</p>
<p>Example 1:<br>nums = [1, 3], n = 6<br>Return 1.</p>
<p>Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.<br>Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].<br>Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].<br>So we only need 1 patch.</p>
<p>Example 2:<br>nums = [1, 5, 10], n = 20<br>Return 2.<br>The two patches can be [2, 4].</p>
<p>Example 3:<br>nums = [1, 2, 2], n = 5<br>Return 0.</p>
<p><strong>Thinking:</strong></p>
<p>The first range we can cover of an array is total, then if we add a new element to this array and this element add &lt;= total, then the new range is [1, add+total). We should also care about the java maxint value, so if we use bit manipulation, it means it is bigger than maxint if total is smaller than zero.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int minPatches(int[] nums, int n) {
    int total = 1; //total is the upper bound of the sum
    int count = 0;
    int index = 0;
    int len = nums.length;

    while (total &lt;= n) {
        if (index &lt; len &amp;&amp; nums[index] &lt;= total){
            total += nums[index++];
        }
        else{
            total &lt;&lt;= 1;
            count++;
            if (total &lt; 0)
                break;
        }
    }


    return count;
} 
</code></pre>
	
	</div>
  <a type="button" href="/2016/02/02/Patching-Array-Java/#more" class="btn btn-default more">閱讀本文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-02-01 </div>
			<div class="article-title"><a href="/2016/02/01/Leetcode-Verify-Preorder-Serialization-of-a-Binary-Tree-Java/" >Leetcode-Verify Preorder Serialization of a Binary Tree(Java)</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p>One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as #.</p>
<pre><code>     _9_
    /   \
   3     2
  / \   / \
 4   1  #  6
/ \ / \   / \
# # # #   # #
</code></pre><p>For example, the above binary tree can be serialized to the string “9,3,4,#,#,1,#,#,2,#,6,#,#”, where # represents a null node.</p>
<p>Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.</p>
<p>Each comma separated value in the string must be either an integer or a character ‘#’ representing null pointer.</p>
<p>You may assume that the input format is always valid, for example it could never contain two consecutive commas such as “1,,3”.</p>
<p>Example 1:<br>“9,3,4,#,#,1,#,#,2,#,6,#,#”<br>Return true</p>
<p>Example 2:<br>“1,#”<br>Return false</p>
<p>Example 3:<br>“9,#,#,1”<br>Return false</p>
<p><strong>Thinking:</strong></p>
<p>Accroding to the correct answer given, we can find the pattern. We should start from # and use stack to store it. When get two #, we should get another element from the string. </p>
<p><strong>Solution:</strong></p>
<pre><code>public boolean isValidSerialization(String preorder) {
    String[] strlist = preorder.split(&quot;,&quot;);
    Stack&lt;String&gt; stack = new Stack&lt;String&gt;();
    Stack&lt;String&gt; tempstack = new Stack&lt;String&gt;();

    for (String s: strlist) {
        stack.push(s);
    }
    while (!stack.isEmpty()) {
        while (!stack.isEmpty() &amp;&amp; stack.peek().equals(&quot;#&quot;)){
            tempstack.push(stack.pop());
        }
        if (tempstack.size() &lt; 2)
            break;
        while (tempstack.size() &gt;= 2 &amp;&amp; !stack.isEmpty() &amp;&amp; !stack.peek().equals(&quot;#&quot;)){
            tempstack.pop();
            tempstack.pop();
            if (!stack.isEmpty() &amp;&amp; !stack.peek().equals(&quot;#&quot;)){
                stack.pop();
                tempstack.push(&quot;#&quot;);
            }
        }
    }

    if (tempstack.size() == 1 &amp;&amp; stack.isEmpty())
        return true;
    else
        return false;
}
</code></pre><p>There is another simpler solution:</p>
<pre><code>public boolean isValidSerialization(String preorder) {
    String[] p = preorder.split(&quot;,&quot;);
    int idx = 0; // stack
    for (int i = 0; i &lt; p.length; i++) {
    if (p[i].equals(&quot;#&quot;)) {
        idx--;
    } else {
        if (idx &lt; 0) { // check
          return false;
        }
        p[idx++] = p[i];
      }
    }
    return idx == -1; // check
  }
</code></pre><p>Reference: <a href="https://leetcode.com/discuss/83903/share-my-java-solution" target="_blank" rel="external">https://leetcode.com/discuss/83903/share-my-java-solution</a></p>
<p>And another much simplier solution which caculate the indegree and outdegree:</p>
<pre><code>public boolean isValidSerialization2(String preorder) {
    String[] nodes = preorder.split(&quot;,&quot;);
    int diff = 1;
    for (String node: nodes) {
        if (--diff &lt; 0) return false;
        if (!node.equals(&quot;#&quot;)) diff += 2;
    }
    return diff == 0;
}
</code></pre><p>Reference: <a href="https://www.hrwhisper.me/leetcode-algorithm-solution/" target="_blank" rel="external">https://www.hrwhisper.me/leetcode-algorithm-solution/</a></p>

	
	</div>
  <a type="button" href="/2016/02/01/Leetcode-Verify-Preorder-Serialization-of-a-Binary-Tree-Java/#more" class="btn btn-default more">閱讀本文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-02-01 </div>
			<div class="article-title"><a href="/2016/02/01/AI-Note/" >AI Note</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p><strong>Lecture 1:</strong></p>
<p><strong>Lecture 2:</strong></p>
<ol>
<li>What’s Agent?</li>
<li>PEAS</li>
</ol>
<p><strong>Lecture 3:</strong></p>
<ol>
<li>Difference between tree search and graph search:<br> Graph search will record the explored nodes, and won’t explore them again.</li>
</ol>
<p><strong>Lecture 4:</strong></p>
<ol>
<li>DFS, BFS, uniform-cost search, interative deepening search, evaluating search performance about completeness, optimality, time and space complexity</li>
<li>BFS:<br> Completeness: Yes(When b is finite)<br> Optimality: Yes(If path is nondecreasing)<br> Time: O(b^d)<br> Space: O(b^d)</li>
<li>DFS:<br> Completeness: Yes(If graph search version)<br> Optimality: No<br> Time: O(b^m)<br> Space: O(b*m)</li>
<li>Uniform-cost search:<br> Completeness: Yes<br> Optimality: Yes(If path is nondecreasing)<br> Uniform-cost search not optimal if it is terminated when some node in the queue has goal state.</li>
<li>Iterative deepening search:<br> Completeness: Yes<br> Optimality: Yes<br> Time: O(b^d)<br> Space: O(bd)</li>
</ol>
<p><strong>Lecture 5:</strong></p>
<ol>
<li>Uniformed search, bi-directional search, informed search, greedy best first search, A*, interative deepening A*, recursive best first search, simplified memory-bounded A*</li>
<li>Bidirectional search:<br> Search forward from initial state, and backward from goal.<br> Completeness: Yes<br> Optimality: Yes<br> Time: O(b^(d/2)<br> Space: O(b^(d/2)</li>
<li>Greedy best first search:<br> Greedy BFS keeps all the nodes generated in the<br>Frontier, which is sorted based on h(n).<br> Completeness: No<br> Optimality: No<br> Time: O(b^m)<br> Space: O(b^m)</li>
<li>A* Search:<br> Use (approximate) total path cost to guide search<br> Admissible Heurisitic: A heuristic is admissible if it never overestimates the cost to reach the goal<br> e.g. hSLD(n) is admissible because it never overestimates the actual road distance<br> Admissible heuristics does not guarantee that the chosen path is optimal<br> A heuristic is consistent if for every node n and every successor n’ of n generated by any action a<br>h(n) ≤ c(n,a,n’) + h(n’)<br> That is, f(n) is nondecreasing along every path.<br> Completeness: Yes<br> Optimality: Yes(if admissible in tree search or consistent in graph search)</li>
<li>Recursive Best-Frist Search:<br> Keep track of f value (f-limit) of best sibling of path currently exploring<br> Space: O(bd)</li>
<li>Memory-Bounded A*:<br>  I.e., expand best leaves until available memory is full;When full, SMA* drops worst leaf node (highest f-value);Like RBFS, backup forgotten node value to its parent</li>
</ol>

	
	</div>
  <a type="button" href="/2016/02/01/AI-Note/#more" class="btn btn-default more">閱讀本文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-01-31 </div>
			<div class="article-title"><a href="/2016/01/31/Leetcode-Kth-Largest-Element-in-an-Array-Java/" >Leetcode-Kth Largest Element in an Array(Java)</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p><strong>Question:</strong></p>
<p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p>For example,<br>Given [3,2,1,5,6,4] and k = 2, return 5.</p>
<p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p>
<p><strong>Thinking:</strong></p>
<p>There are three ways to solve this problem:</p>
<ol>
<li>The first one is to build a max heap with size n, and get the top of the heap k times.</li>
<li>The second one is to build a min heap with size k, and keep the biggest top k elements of this array. Finally, get the top of it.</li>
<li>The third one is to use a method called quickselect which uses function partition. It first use a pivot to split the array into two parts, then accroding to this index, choose which part to select.</li>
</ol>
<p><strong>Solution:</strong></p>
<p>Max heap:</p>
<pre><code>public int findKthLargest1(int[] nums, int k) {
    int len = nums.length;
    PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;Integer&gt;(len, new HeapComparator());
    for (int i = 0; i &lt; len; i++){
        heap.add(nums[i]);
    }
    for (int i = 0; i &lt; k-1; i++){
        heap.poll();
    }
    return heap.peek();
}

class HeapComparator implements Comparator {

    @Override
    public int compare(Object o1, Object o2) {
        // TODO Auto-generated method stub
        int i1 = (int)o1;
        int i2 = (int)o2;
        if (i1 &gt; i2)
            return -1;
        else if (i1 == i2)
            return 0;
        else
            return 1;
    }

}
</code></pre><p>Min heap:</p>
<pre><code>public int findKthLargest2(int[] nums, int k) {
    int len = nums.length;
    PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;Integer&gt;(k);
    for (int i = 0; i &lt; k; i++){
        heap.add(nums[i]);
    }
    for (int i = k; i &lt; len; i++){
        if (nums[i] &gt; heap.peek()){
            heap.poll();
            heap.add(nums[i]);
        }
    }
    return heap.peek();
}
</code></pre><p>Quickselect:</p>
<pre><code>public int findKthLargest3(int[] nums, int k) {
    int len = nums.length;
    return quickselect(nums, 0, len-1, k);
}

private int quickselect(int[] nums, int left, int right, int k){
    int pivotIndex = partition(nums, left, right, left);
    if (pivotIndex == k-1){
        return nums[pivotIndex];
    }
    else if(pivotIndex &lt; k){
        return quickselect(nums, pivotIndex+1, right, k);
    }
    else{
        return quickselect(nums, left, pivotIndex-1, k);
    }
}

private int partition(int[] nums, int left, int right, int index){
    int pivotvalue = nums[index];
    int storeindex = left;
    nums[index] = nums[right];
    for (int i = left; i &lt; right; i++){
        if (nums[i] &gt; pivotvalue){
            int temp = nums[i];
            nums[i] = nums[storeindex];
            nums[storeindex++] = temp;
        }
    }
    nums[right] = nums[storeindex];
    nums[storeindex] = pivotvalue;
    return storeindex;
}
</code></pre>
	
	</div>
  <a type="button" href="/2016/01/31/Leetcode-Kth-Largest-Element-in-an-Array-Java/#more" class="btn btn-default more">閱讀本文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-01-31 </div>
			<div class="article-title"><a href="/2016/01/31/Leetcode-Permutations-II-Java/" >Leetcode-Permutations II(Java)</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p><strong>Question:</strong></p>
<p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p>For example,<br>[1,1,2] have the following unique permutations:<br>[1,1,2], [1,2,1], and [2,1,1].</p>
<p><strong>Thinking:</strong></p>
<p>It’s very similiar with the question permutation, we should use backtracing to go through all the possibilities. For example, we pick the first element of the array, and get the permutation of the rest of this array, and put the first element in every possible position. The only difference bewteen the permutation is that we don’t allow duplicate. We can use hashset to solve this problem.</p>
<p>By the way, I made a mistake this time which I used to make. It’s that in the loop of this:</p>
<pre><code>for (List&lt;Integer&gt; list: backtracing(nums, index+1)){
    for (int i = 0; i &lt;= list.size(); i++){
        List&lt;Integer&gt; tempres = new ArrayList&lt;Integer&gt;(list);
        tempres.add(i, nums[index]);
        tres.add(tempres);
    }
}
</code></pre><p>I shouldn’t use the temporary variable list to operate, because<br>1) the size of it will change;<br>2) we should use it several times instead of once.<br>Then that means we should build another temporary variable. In this case, it’s tempres.</p>
<p><strong>Solution:</strong></p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {
    return backtracing(nums, 0);
}

private List&lt;List&lt;Integer&gt;&gt; backtracing(int[] nums, int index) {
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    HashSet&lt;List&lt;Integer&gt;&gt; tres = new HashSet&lt;List&lt;Integer&gt;&gt;();
    int len = nums.length;

    if (index &gt;= len){
        return res;
    }

    if (index == len - 1){
        List&lt;Integer&gt; tempres = new ArrayList&lt;Integer&gt;();
        tempres.add(nums[index]);
        res.add(tempres);
        return res;
    }

    for (List&lt;Integer&gt; list: backtracing(nums, index+1)){
        for (int i = 0; i &lt;= list.size(); i++){
            List&lt;Integer&gt; tempres = new ArrayList&lt;Integer&gt;(list);
            tempres.add(i, nums[index]);
            tres.add(tempres);
        }
    }

    res.addAll(tres);
    return res;
}
</code></pre><p>There is another solution is much faster than me. Because it use extra space to record which element is used and use sort to reduce the extra cost to make sure unique. What’s more, the process of adding first and removing after dfs is usually used by people. I suppose I should learn from it.</p>
<p>Code:</p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    if(nums==null || nums.length==0) return res;
    boolean[] used = new boolean[nums.length];
    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
    Arrays.sort(nums);
    dfs(nums, used, list, res);
    return res;
}

public void dfs(int[] nums, boolean[] used, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; res){
    if(list.size()==nums.length){
        res.add(new ArrayList&lt;Integer&gt;(list));
        return;
    }
    for(int i=0;i&lt;nums.length;i++){
        if(used[i]) continue;
        if(i&gt;0 &amp;&amp;nums[i-1]==nums[i] &amp;&amp; !used[i-1]) continue;
        used[i]=true;
        list.add(nums[i]);
        dfs(nums,used,list,res);
        used[i]=false;
        list.remove(list.size()-1);
    }
}
</code></pre>
	
	</div>
  <a type="button" href="/2016/01/31/Leetcode-Permutations-II-Java/#more" class="btn btn-default more">閱讀本文</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">
<ul class="pagination">
	 
		
    	<li class="prev"><a href="/page/4/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i> 上一頁</a></li>
  		

        <li><a href="/"><i class="fa fa-home"></i>Home</a></li>

		
		   <li class="next"> <a href="/page/6/" class="alignright next">下一頁<i class="fa fa-arrow-circle-o-right"></i></a> </li>          
        
	
</ul>
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="搜尋" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
	<div class="widget">
		<h4>分類</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/Algorithm/">Algorithm<span>2</span></a></li>
		
			<li><a href="/categories/Leetcode/">Leetcode<span>42</span></a></li>
		
			<li><a href="/categories/Network/">Network<span>1</span></a></li>
		
			<li><a href="/categories/Web/">Web<span>1</span></a></li>
		
			<li><a href="/categories/uncategoried/">uncategoried<span>1</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>標籤雲</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/Topological-Sort/">Topological Sort<span>1</span></a></li>
		
			<li><a href="/tags/Hash-Table/">Hash Table<span>3</span></a></li>
		
			<li><a href="/tags/String/">String<span>2</span></a></li>
		
			<li><a href="/tags/Divide-and-Conquer/">Divide and Conquer<span>1</span></a></li>
		
			<li><a href="/tags/Tree/">Tree<span>1</span></a></li>
		
			<li><a href="/tags/BFS/">BFS<span>4</span></a></li>
		
			<li><a href="/tags/Design/">Design<span>2</span></a></li>
		
			<li><a href="/tags/Two-Points/">Two Points<span>2</span></a></li>
		
			<li><a href="/tags/Backtracing/">Backtracing<span>4</span></a></li>
		
			<li><a href="/tags/Binary-Search/">Binary Search<span>2</span></a></li>
		
			<li><a href="/tags/Stack/">Stack<span>1</span></a></li>
		
			<li><a href="/tags/Graph/">Graph<span>3</span></a></li>
		
			<li><a href="/tags/Bit-Manipulation/">Bit Manipulation<span>1</span></a></li>
		
			<li><a href="/tags/Heap/">Heap<span>2</span></a></li>
		
			<li><a href="/tags/Linked-List/">Linked List<span>2</span></a></li>
		
			<li><a href="/tags/Two-Pointers/">Two Pointers<span>1</span></a></li>
		
			<li><a href="/tags/Greedy/">Greedy<span>2</span></a></li>
		
			<li><a href="/tags/DFS/">DFS<span>2</span></a></li>
		
			<li><a href="/tags/Dynamic-Programming/">Dynamic Programming<span>2</span></a></li>
		
			<li><a href="/tags/Math/">Math<span>2</span></a></li>
		
		
		   <li><a href="/tags">...<span>23</span></a></li>
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>最新文章</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2016/02/14/Leetcode-Coin-Change-Java/" ><i class="fa fa-file-o"></i>Leetcode-Coin Change(Java)...</a>
      </li>
    
      <li>
        <a href="/2016/02/13/Some-basic-problems/" ><i class="fa fa-file-o"></i>Some basic problems...</a>
      </li>
    
      <li>
        <a href="/2016/02/13/Some-thoughts-about-interview/" ><i class="fa fa-file-o"></i>Some thoughts about intervi...</a>
      </li>
    
      <li>
        <a href="/2016/02/10/Leetcode-Majority-Element-II-Java/" ><i class="fa fa-file-o"></i>Leetcode-Majority Element I...</a>
      </li>
    
      <li>
        <a href="/2016/02/10/Leetcode-Implement-Trie-Prefix-Tree-Java/" ><i class="fa fa-file-o"></i>Leetcode-Implement Trie (Pr...</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>鏈接</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="https://github.com/wzpan/hexo-theme-freemind" title="Freemind's Github repository." target="_blank"]);">Freemind</a></li>
	
		<li><i class="fa fa-github"></i><a href="https://github.com/MartinTrojans" title="My Github account." target="_blank"]);">My Github</a></li>
	
		<li><i class="fa fa-linkedin"></i><a href="http://www.linkedin.com/in/hahack" title="My Linkin account." target="_blank"]);">My LinkedIn</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2016 Martin
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
