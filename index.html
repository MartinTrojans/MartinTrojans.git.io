<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Martin&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="A rookie write something just for fun.">
<meta property="og:type" content="website">
<meta property="og:title" content="Martin's Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Martin's Blog">
<meta property="og:description" content="A rookie write something just for fun.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Martin's Blog">
<meta name="twitter:description" content="A rookie write something just for fun.">
  
    <link rel="alternate" href="/atom.xml" title="Martin&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Martin&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Leetcode-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Java" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/26/Leetcode-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Java/" class="article-date">
  <time datetime="2016-01-27T06:28:05.000Z" itemprop="datePublished">2016-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/26/Leetcode-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Java/">Leetcode-Construct Binary Tree from Preorder and Inorder Traversal(Java)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>Question:</strong></p>
<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>You may assume that duplicates do not exist in the tree.</p>
<p><strong>Thinking:</strong></p>
<p>This question is similar with Construct Binary Tree from Inorder and Postorder Traversal. We should understand the differences and the sequences of these three methods. And divide into three parts- root, left child and right child.</p>
<p><strong>Solution:</strong></p>
<pre><code>public TreeNode buildTree(int[] preorder, int[] inorder) {
    int l = preorder.length;
    if (l == 0)
        return null;


    return dp(preorder, inorder, 0, l-1, 0, l-1);
    }

    private TreeNode dp(int[] preorder, int[] inorder, int preStart, int preEnd, int inStart, int inEnd){
    if (preStart &gt; preEnd || preEnd &gt;= preorder.length || inEnd &gt;= preorder.length)
        return null;
    TreeNode root = new TreeNode(preorder[preStart]);
    int index = inStart;
    for (; index &lt; inEnd; index++){
        if (inorder[index] == preorder[preStart])
            break;
    }

    TreeNode left = dp(preorder, inorder, preStart+1, preStart+index-inStart, inStart, index-1);
    TreeNode right = dp(preorder, inorder,preStart+index-inStart+1, preEnd, index+1, inEnd);
    root.left = left;
    root.right = right;

    return root;
}    
</code></pre><p>This method can be improved by using HashMap to make it faster when fiding the index of root.<br>Reference:<a href="http://blog.csdn.net/linhuanmars/article/details/24389549" target="_blank" rel="external">http://blog.csdn.net/linhuanmars/article/details/24389549</a><br>Code:</p>
<pre><code>static HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
public TreeNode buildTree(int[] preorder, int[] inorder) {
    int l = preorder.length;
    if (l == 0)
        return null;
    for (int i = 0; i &lt; l; i++)
        map.put(inorder[i], i);

    return dp(preorder, inorder, 0, l-1, 0, l-1);
}

private TreeNode dp(int[] preorder, int[] inorder, int preStart, int preEnd, int inStart, int inEnd){
    if (preStart &gt; preEnd || inStart &gt; inEnd)
        return null;
    TreeNode root = new TreeNode(preorder[preStart]);

    int index = map.get(preorder[preStart]);

    TreeNode left = dp(preorder, inorder, preStart+1, preStart+index-inStart, inStart, index-1);
    TreeNode right = dp(preorder, inorder,preStart+index-inStart+1, preEnd, index+1, inEnd);
    root.left = left;
    root.right = right;

    return root;
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/26/Leetcode-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Java/" data-id="cijwghzdc000h3yowf0r4t4mx" class="article-share-link">Share</a>
      
        <a href="http://yoursite.com/2016/01/26/Leetcode-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Java/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Leetcode-Pow-x-n-Java" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/26/Leetcode-Pow-x-n-Java/" class="article-date">
  <time datetime="2016-01-27T05:24:27.000Z" itemprop="datePublished">2016-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/26/Leetcode-Pow-x-n-Java/">Leetcode-Pow(x, n)(Java)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>Question:</strong></p>
<p>Implement pow(x, n).</p>
<p><strong>Thinking:</strong></p>
<p>It’s a simple but not simple question. There are many solutions for this problem. But how can we find the most effienct one. We can use recursion to reduce the times of multipling and check the bound of data to reduce the times of recursions. Finally, the code is below:</p>
<pre><code>static boolean negflag = false;
public double myPow(double x, int n) {
    if (n &lt; 0){
        negflag = true;
        return 1 / dp(x, -n);
    }
    else
        return dp(x, n);

}
private double dp(double x, int n){
    if (n == 0)
        return 1;
    if (n == 1)
        return x;
    if (n == 2)
        return x * x;

    int m = n / 2;
    int k = n % 2;
    double v = dp(x, m);
    if (negflag == true &amp;&amp; v &gt; 100000)
        return 100000;
    if (negflag == false &amp;&amp; v &lt; 0.00001)
        return 0;

    if (k == 0)
        return v * v;
    else
        return v * v * x;
}
</code></pre><p>By the way, I have to metion that my python solution is like, lol:</p>
<pre><code>def myPow(self, x, n):
    return x**n
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/26/Leetcode-Pow-x-n-Java/" data-id="cijwghzd2000c3yow588dsikg" class="article-share-link">Share</a>
      
        <a href="http://yoursite.com/2016/01/26/Leetcode-Pow-x-n-Java/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Leetcode-Jump-Game-Java" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/26/Leetcode-Jump-Game-Java/" class="article-date">
  <time datetime="2016-01-27T04:20:54.000Z" itemprop="datePublished">2016-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/26/Leetcode-Jump-Game-Java/">Leetcode-Jump Game(Java)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>Question:</strong></p>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<p>For example:<br>A = [2,3,1,1,4], return true.</p>
<p>A = [3,2,1,0,4], return false.</p>
<p><strong>Thinking:</strong></p>
<p>It’s a problem can be solved in greedy algorithm. Because we should go as far as possible in current position until we can’t go father. And we should gurantee the value of current position + i (steps can be reached from current postion) + nums[cur + i] be as big as possible.</p>
<p><strong>Solution:</strong></p>
<pre><code>public boolean canJump(int[] nums) {
    int l = nums.length;
    if (nums[0] == 0 &amp;&amp; l &gt; 1)
        return false;
    int cur = 0;
    int temp = nums[0];
    int step = nums[0];
    int max = nums[0];
    int tempcur = 0;

    while (cur + step &lt; l-1){
        for (int i = 1; i &lt;= step; i++){
            temp = cur + i + nums[cur + i];
            if (temp &gt;= max){//current max greedy value
                max = temp;
                if (max &gt;= l)
                    return true;
                tempcur = cur + i;
            }
        }
        if (cur == tempcur)
            return false;
        cur = tempcur;
        step = nums[cur];
    }

    if (max &gt;= l-1)
        return true;
    else
        return false;
}
</code></pre><p>What’s more, we can make it easier by max the value of index. </p>
<pre><code>public boolean canJump(int[] nums) {
    if(nums.length &lt;= 1)
        return true;

    int max = nums[0]; //max stands for the largest index that can be reached.

    for(int i=0; i&lt;nums.length; i++){
        //if not enough to go to next
        if(max &lt;= i &amp;&amp; nums[i] == 0) 
            return false;

        //update max    
        if(i + nums[i] &gt; max){
            max = i + nums[i];
        }

        //max is enough to reach the end
        if(max &gt;= nums.length-1) 
            return true;
    }

    return false;    
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/26/Leetcode-Jump-Game-Java/" data-id="cijwghzd8000f3yow5jxkgje1" class="article-share-link">Share</a>
      
        <a href="http://yoursite.com/2016/01/26/Leetcode-Jump-Game-Java/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Leetcode-3Sum-Closest-Java" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/26/Leetcode-3Sum-Closest-Java/" class="article-date">
  <time datetime="2016-01-27T00:38:28.000Z" itemprop="datePublished">2016-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/26/Leetcode-3Sum-Closest-Java/">Leetcode-3Sum Closest(Java)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>Question:</strong></p>
<p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<p>For example, given array S = {-1 2 1 -4}, and target = 1.</p>
<p>The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</p>
<p><strong>Thinking:</strong></p>
<p>In order to improve the performance of algorithm, we should sort the array. Because of that, we can determine where to go using current result.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int threeSumClosest(int[] nums, int target) {
    int l = nums.length;
    if (l &lt; 3)
        return 0;
    int min = Integer.MAX_VALUE;
    int res = 0;
    Arrays.sort(nums);

    for (int i = 0; i &lt; l; i++){
        int j = i + 1;
        int k = l - 1;

        while (j &lt; k){
            int sum = nums[i] + nums[j] + nums[k];
            if (sum == target)
                return sum;
            int diff = Math.abs(sum - target);
            if (diff &lt; min){
                min = diff;
                res = sum;
            }
            if (sum &gt; target)
                k--;
            else
                j++;
        }

    }
    return res;
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/26/Leetcode-3Sum-Closest-Java/" data-id="cijwghzc200003yowdu8mbjay" class="article-share-link">Share</a>
      
        <a href="http://yoursite.com/2016/01/26/Leetcode-3Sum-Closest-Java/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Leetcode-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-Java" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/26/Leetcode-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-Java/" class="article-date">
  <time datetime="2016-01-27T00:00:18.000Z" itemprop="datePublished">2016-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/26/Leetcode-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-Java/">Leetcode-Construct Binary Tree from Inorder and Postorder Traversal(Java)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>Question:</strong></p>
<p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>You may assume that duplicates do not exist in the tree.</p>
<p><strong>Thinking:</strong></p>
<p>Inorder traversal will search in order: left, root, right;</p>
<p>Postorder travelsal will search in order: left, right, root.</p>
<p>So we can find the root in postorder and search it in inorder by the value. And find root’s left child and right child node by recursion.</p>
<pre><code>public TreeNode buildTree(int[] inorder, int[] postorder) {
    int l = inorder.length;
    if (l == 0)
        return null;
    TreeNode root = new TreeNode(postorder[l-1]);
    TreeNode left = null;
    TreeNode right = null;
    int index = 0;
    for (; index &lt; l; index++){
        if (inorder[index] == postorder[l-1])
            break;
    }


    if (index &gt; 0){
        int[] leftinorder = new int[index];
        int[] leftpostorder = new int[index];
        System.arraycopy(inorder, 0, leftinorder, 0, index);
        System.arraycopy(postorder, 0, leftpostorder, 0, index);
        left = buildTree(leftinorder, leftpostorder);
    }
    if (index &lt; l-1){
        int[] rightinorder = new int[l-index-1];
        int[] rightpostorder = new int[l-index-1];
        System.arraycopy(inorder, index+1, rightinorder, 0, l-index-1);
        System.arraycopy(postorder, index, rightpostorder, 0, l-index-1);
        right = buildTree(rightinorder, rightpostorder);
    }
    root.left = left;
    root.right = right;

    return root;
}
</code></pre><p>By the way, this code can be improved because in Java we can not easily get the subarray and I use the System.arraycopy. It can be replaced by recording the postion of array.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/26/Leetcode-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-Java/" data-id="cijwghzde000i3yowot5bk5x3" class="article-share-link">Share</a>
      
        <a href="http://yoursite.com/2016/01/26/Leetcode-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-Java/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/01/26/Leetcode-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Java/">Leetcode-Construct Binary Tree from Preorder and Inorder Traversal(Java)</a>
          </li>
        
          <li>
            <a href="/2016/01/26/Leetcode-Pow-x-n-Java/">Leetcode-Pow(x, n)(Java)</a>
          </li>
        
          <li>
            <a href="/2016/01/26/Leetcode-Jump-Game-Java/">Leetcode-Jump Game(Java)</a>
          </li>
        
          <li>
            <a href="/2016/01/26/Leetcode-3Sum-Closest-Java/">Leetcode-3Sum Closest(Java)</a>
          </li>
        
          <li>
            <a href="/2016/01/26/Leetcode-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-Java/">Leetcode-Construct Binary Tree from Inorder and Postorder Traversal(Java)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Martin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'communitydeveloper';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>