<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Martin's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-01-31T05:29:07.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Martin]]></name>
    <email><![CDATA[martinglory1992@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Leetcode-Binary Tree Zigzag Level Order Traversal(Java)]]></title>
    <link href="http://yoursite.com/2016/01/30/Leetcode-Binary-Tree-Zigzag-Level-Order-Traversal-Java/"/>
    <id>http://yoursite.com/2016/01/30/Leetcode-Binary-Tree-Zigzag-Level-Order-Traversal-Java/</id>
    <published>2016-01-31T05:21:37.000Z</published>
    <updated>2016-01-31T05:29:07.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree {3,9,20,#,#,15,7},</p>
<pre><code>  3
 / \
9  20
  /  \
 15   7
</code></pre><p>return its zigzag level order traversal as:</p>
<pre><code>[
  [3],
  [20,9],
  [15,7]
]
</code></pre><p><strong>Thinking:</strong></p>
<p>It’s a BFS problem. It’s fine if we need use queue, but because we have to record as a zigzag order, it’s more efficient to use stack. What’s more, we should to notice the order of left and right child.</p>
<p><strong>Solution:</strong></p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) {
    int flag = 0;
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();
    Stack&lt;TreeNode&gt; tempstack = new Stack&lt;TreeNode&gt;();
    if (root == null)
        return res;
    stack.add(root);
    while (!stack.isEmpty() || !tempstack.isEmpty()){
        tempstack = new Stack&lt;TreeNode&gt;();
        List&lt;Integer&gt; tempres = new ArrayList&lt;Integer&gt;();
        while (!stack.isEmpty()){
            TreeNode node = stack.pop();
            tempres.add(node.val);
            if (flag == 0){
                if (node.left != null){
                    tempstack.add(node.left);
                }
                if (node.right != null){
                    tempstack.add(node.right);
                }
            }
            else{
                if (node.right != null){
                    tempstack.add(node.right);
                }
                if (node.left != null){
                    tempstack.add(node.left);
                }
            }

        }
        res.add(tempres);
        stack.addAll(tempstack);
        flag ^= 1;
    }

    return res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to ri]]>
    </summary>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-4Sum(Java)]]></title>
    <link href="http://yoursite.com/2016/01/30/Leetcode-4Sum-Java/"/>
    <id>http://yoursite.com/2016/01/30/Leetcode-4Sum-Java/</id>
    <published>2016-01-31T04:33:10.000Z</published>
    <updated>2016-01-31T04:42:45.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>
<p>Note:<br>Elements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d)<br>The solution set must not contain duplicate quadruplets.<br>    For example, given array S = {1 0 -1 0 -2 2}, and target = 0.</p>
<pre><code>A solution set is:
(-1,  0, 0, 1)
(-2, -1, 1, 2)
(-2,  0, 0, 2)
</code></pre><p><strong>Thinking</strong>:</p>
<p>This questions is very similar with 2Sum and 3Sum. There are several way to solve it. </p>
<p><strong>Solution1:</strong></p>
<p>The most common method may use the method of 3Sum, and do that n times.</p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; fourSum1(int[] nums, int target) {
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    Set&lt;List&lt;Integer&gt;&gt; tres = new HashSet&lt;List&lt;Integer&gt;&gt;();
    Arrays.sort(nums);
    int len = nums.length;


    for (int i = 0; i &lt; len-3; i++){
        for (int j = i+1; j &lt; len-2; j++){
            for (int k = j+1; k &lt; len-1; k++){
                int l = len-1;
                while (k &lt; l){
                    int sum = nums[i] + nums[j] + nums[k] + nums[l];
                    if (sum == target){
                        List&lt;Integer&gt; tempres = new ArrayList&lt;Integer&gt;();
                        tempres.add(nums[i]);
                        tempres.add(nums[j]);
                        tempres.add(nums[k]);
                        tempres.add(nums[l]);
                        tres.add(tempres);
                        k++;
                        l--;
                    }
                    else if (sum &gt; target){
                        l--;
                    }
                    else{
                        k++;
                    }
                    while (k &lt; l &amp;&amp; nums[k+1] == nums[k]){
                        k++;
                    }
                    while (k &lt; l &amp;&amp; nums[l-1] == nums[l]){
                        l--;
                    }
                }
            }
        }
    }

    res.addAll(tres);
    return res;
}
</code></pre><p><strong>Solution2:</strong></p>
<p>The second solution is to combine every two numbers as a pair, and make it as a 2sum problem. But for implementing this method, we have to define the data structure by ourself and implement the interface of Comparator to sort the sum of them.</p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; fourSum2(int[] nums, int target){
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    int len = nums.length;
    if (len &lt; 4)
        return res;
    Pair[] pairSum = new Pair[len*(len-1)/2];
    Set&lt;List&lt;Integer&gt;&gt; tres = new HashSet&lt;List&lt;Integer&gt;&gt;();

    int count = 0;
    for (int i = 0; i &lt; len-1; i++){
        for (int j = i+1; j &lt; len; j++){
            Pair ele = new Pair(nums[i], nums[j], i, j);
            pairSum[count++] = ele;
        }
    }
    Arrays.sort(pairSum, new SumComparator());

    int left = 0;
    int right = pairSum.length - 1;
    while (left &lt; right){
        int sum = pairSum[left].getSum() + pairSum[right].getSum();
        if (sum == target){
            int endl = left;
            int endr = right;
            while (pairSum[endl].getSum() == pairSum[endl+1].getSum() &amp;&amp; endl+1 &lt; endr){
                endl++;
            }
            while (pairSum[endr].getSum() == pairSum[endr-1].getSum() &amp;&amp; endl &lt; endr-1){
                endr--;
            }
            for (int i = left; i &lt;= endl; i++){
                for (int j = right; j&gt;= endr; j--){
                    int i1 = pairSum[i].geti();
                    int i2 = pairSum[j].geti();
                    int j1 = pairSum[i].getj();
                    int j2 = pairSum[j].getj();
                    if (i1 == i2 || i1 == j2 || j1 == i2 || j1 == j2){
                        continue;
                    }
                    int[] temp = new int[4];
                    temp[0] = pairSum[i].getN1();
                    temp[1] = pairSum[i].getN2();
                    temp[2] = pairSum[j].getN1();
                    temp[3] = pairSum[j].getN2();
                    Arrays.sort(temp);
                    List&lt;Integer&gt; tempres = new ArrayList&lt;Integer&gt;();
                    tempres.add(temp[0]);
                    tempres.add(temp[1]);
                    tempres.add(temp[2]);
                    tempres.add(temp[3]);
                    tres.add(tempres);
                }
            }
            left = endl+1;
            right = endr-1;
        }
        else if (sum &gt; target){
            right--;
        }
        else{
            left++;
        }
    }

    res.addAll(tres);
    return res;
}

class SumComparator implements Comparator{

    @Override
    public final int compare(Object o1, Object o2) {
        // TODO Auto-generated method stub
        Pair l1 = (Pair)o1;
        Pair l2 = (Pair)o2;
        if (l1.getSum() &gt; l2.getSum())
            return 1;
        else if (l1.getSum() &lt; l2.getSum())
            return -1;
        else
            return 0;
    }
}

class Pair{
    int i;
    int j;
    int n1;
    int n2;
    int sum;
    Pair(int num1, int num2, int i, int j){
        this.n1 = num1;
        this.n2 = num2;
        this.sum = num1 + num2;
        this.i = i;
        this.j = j;
    }
    public int getSum(){
        return this.sum;
    }
    public int getN1(){
        return this.n1;
    }
    public int getN2(){
        return this.n2;
    }
    public int geti(){
        return this.i;
    }
    public int getj(){
        return this.j;
    }
}
</code></pre><p>Reference: <a href="http://blog.csdn.net/linhuanmars/article/details/24826871" target="_blank" rel="external">http://blog.csdn.net/linhuanmars/article/details/24826871</a></p>
<p><strong>Solution3:</strong></p>
<p>The third method is the most efficient method. It has two loop of two points and use some method to break or return early. It really improve the performance of time running.</p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; fourSum3(int[] nums, int target) {
    List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    Arrays.sort(nums);
    int second = 0, third = 0, nexti = 0, nextj = 0;
    for(int i=0, L=nums.length; i&lt;L-3; i++) {
        if(nums[i]&lt;&lt;2 &gt; target) return list; // return immediately
        for(int j=L-1; j&gt;i+2; j--) {
            if(nums[j]&lt;&lt;2 &lt; target) break; // break immediately
            int rem = target-nums[i]-nums[j];
            int lo = i+1, hi=j-1;
            while(lo&lt;hi) {
                int sum = nums[lo] + nums[hi];
                if(sum&gt;rem) --hi;
                else if(sum&lt;rem) ++lo;
                else {
                    list.add(Arrays.asList(nums[i],nums[lo],nums[hi],nums[j]));
                    while(++lo&lt;=hi &amp;&amp; nums[lo-1]==nums[lo]) continue; // avoid duplicate results
                    while(--hi&gt;=lo &amp;&amp; nums[hi]==nums[hi+1]) continue; // avoid duplicate results
                }
            }
            while(j&gt;=1 &amp;&amp; nums[j]==nums[j-1]) --j; // skip inner loop
        }
        while(i&lt;L-1 &amp;&amp; nums[i]==nums[i+1]) ++i; // skip outer loop
    }
    return list;
}
</code></pre><p>Reference: <a href="https://leetcode.com/discuss/78276/java-little-bit-faster-than-other-common-methods-9ms-beats-95%25" target="_blank" rel="external">https://leetcode.com/discuss/78276/java-little-bit-faster-than-other-common-methods-9ms-beats-95%25</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Two Points" scheme="http://yoursite.com/tags/Two-Points/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-3Sum(Java)]]></title>
    <link href="http://yoursite.com/2016/01/28/Leetcode-3Sum-Java/"/>
    <id>http://yoursite.com/2016/01/28/Leetcode-3Sum-Java/</id>
    <published>2016-01-29T00:28:55.000Z</published>
    <updated>2016-01-29T00:32:01.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p>Note:<br>Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)<br>The solution set must not contain duplicate triplets.<br>    For example, given array S = {-1 0 1 2 -1 -4},</p>
<pre><code>A solution set is:
(-1, 0, 1)
(-1, -1, 2)
</code></pre><p><strong>Thinking:</strong></p>
<p>Sort the array first. Pick a number from the array, and use other two points to record the position of the array and determine which one should change by the sum of them. What’s more, the result set should has no duplicate, so we can use hashset here.</p>
<p><strong>Solution:</strong></p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
    int l = nums.length;
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    Set&lt;List&lt;Integer&gt;&gt; tres = new HashSet&lt;List&lt;Integer&gt;&gt;();

    if (l &lt; 3)
        return res;

    Arrays.sort(nums);

    for (int i = 0; i &lt; l-2; i++){
        int k = l-1;
        for (int j = i+1; j &lt; l; j++){
            while (j &lt; k){
                int sum = nums[i] + nums[j] + nums[k];
                if (sum == 0){
                    List&lt;Integer&gt; tempres = new ArrayList&lt;Integer&gt;();
                    tempres.add(nums[i]);
                    tempres.add(nums[j]);
                    tempres.add(nums[k]);
                    tres.add(tempres);
                    while (j &lt; k &amp;&amp; nums[j] == tempres.get(1)){
                        j++;
                    }
                    k--;
                }
                else if (sum &gt; 0){
                    k--;
                }
                else{
                    j++;
                }

            }
        }
    }
    res.addAll(tres);

    return res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all uniqu]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Two Points" scheme="http://yoursite.com/tags/Two-Points/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Two Sum(Java)]]></title>
    <link href="http://yoursite.com/2016/01/28/Leetcode-Two-Sum-Java/"/>
    <id>http://yoursite.com/2016/01/28/Leetcode-Two-Sum-Java/</id>
    <published>2016-01-28T22:55:39.000Z</published>
    <updated>2016-01-28T22:58:03.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>
<p>You may assume that each input would have exactly one solution.</p>
<p>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p>
<p><strong>Thinking:</strong></p>
<p>We can use hash map to store the rest of nums[i], and if we find which number is equal to the rest beofore, their sum will be target.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int[] twoSum(int[] nums, int target){
    HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
    int[] res = new int[2];

    for (int i = 0; i &lt; nums.length; i++){
        if (map.containsKey(nums[i])){
            res[0] = map.get(nums[i]) + 1;
            res[1] = i+1;
            break;
        }
        else{
            map.put(target-nums[i], i);
        }
    }

    return res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>
<p>]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Game of Life(Java)]]></title>
    <link href="http://yoursite.com/2016/01/28/Leetcode-Game-of-Life-Java/"/>
    <id>http://yoursite.com/2016/01/28/Leetcode-Game-of-Life-Java/</id>
    <published>2016-01-28T22:17:33.000Z</published>
    <updated>2016-01-28T22:36:18.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>According to the Wikipedia’s article: “The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.”</p>
<p>Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</p>
<p>Any live cell with fewer than two live neighbors dies, as if caused by under-population.<br>Any live cell with two or three live neighbors lives on to the next generation.<br>Any live cell with more than three live neighbors dies, as if by over-population..<br>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.<br>Write a function to compute the next state (after one update) of the board given its current state.</p>
<p>Follow up:<br>Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.<br>In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?</p>
<p><strong>Thinkings:</strong></p>
<p>It’s difficult quesiont, isn’t it? We have to fully understand when cell become live or dead and try to replace them in place. One solution is to present their status using bits, the first bit represents their current status and second bit represents their next status. For example:</p>
<p>current status is live and next status will be dead is 01<br>current status is dead and next status will be live is 10</p>
<p>And then we can get the current status by:</p>
<pre><code>board[i][j] &amp; 1
</code></pre><p>Get the finnaly status by:</p>
<pre><code>board[i][j] &gt;&gt;= 1
</code></pre><p><strong>Solution:</strong></p>
<pre><code>public void gameOfLife(int[][] board) {
    int m = board.length;
    if (m == 0)
        return;
    int n = board[0].length;

    //int[][] temp = new int[m][n];


    for (int i = 0; i &lt; m; i++){
        for (int j = 0; j &lt; n; j++){
            int count = 0;
            for (int p = -1; p &lt; 2; p++)
                for (int q = -1; q &lt; 2; q++){
                    if (i+p&gt;=0 &amp;&amp; i+p&lt;m &amp;&amp; j+q&gt;=0 &amp;&amp; j+q&lt;n &amp;&amp; !(p==0 &amp;&amp; q==0)){
                        if ((board[i+p][j+q] &amp; 1) == 1)
                            count++;
                    }
                }

            if ((board[i][j] &amp; 1) == 0 &amp;&amp; count == 3){
                //temp[i][j] = 1;
                board[i][j] = 2;
            }
            else if ((board[i][j] &amp; 1) == 1 &amp;&amp; count &lt;=3 &amp;&amp; count &gt;= 2){
                    board[i][j] = 3;

            }
        }
    }

    for (int i = 0; i &lt; m; i++){
        for (int j = 0; j &lt; n; j++){
            //board[i][j] = temp[i][j];
            board[i][j] &gt;&gt;= 1;
        }
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>According to the Wikipedia’s article: “The Game of Life, also known simply as Life, is a cellular autom]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Letter Combinations of a Phone Number(Java)]]></title>
    <link href="http://yoursite.com/2016/01/27/Leetcode-Letter-Combinations-of-a-Phone-Number-Java/"/>
    <id>http://yoursite.com/2016/01/27/Leetcode-Letter-Combinations-of-a-Phone-Number-Java/</id>
    <published>2016-01-28T00:11:34.000Z</published>
    <updated>2016-01-28T00:21:10.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a digit string, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below.</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt=""></p>
<pre><code>Input:Digit string &quot;23&quot;
Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].
</code></pre><p>Note:<br>Although the above answer is in lexicographical order, your answer could be in any order you want.</p>
<p><strong>Thinking:</strong></p>
<p>We should get all the possiblities of the comibination so we need use backtracing.</p>
<p><strong>Solution:</strong></p>
<pre><code>import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

public class Solution {
    static private Map&lt;Character, char[]&gt; hmap = new HashMap&lt;Character, char[]&gt;();

    private Character two = new Character(&apos;2&apos;);
    private char[] twoC = {&apos;a&apos;, &apos;b&apos;, &apos;c&apos;};
    private Character three = new Character(&apos;3&apos;);
    private char[] threeC = {&apos;d&apos;, &apos;e&apos;, &apos;f&apos;};
    private Character four = new Character(&apos;4&apos;);
    private char[] fourC = {&apos;g&apos;, &apos;h&apos;, &apos;i&apos;};
    private Character five = new Character(&apos;5&apos;);
    private char[] fiveC = {&apos;j&apos;, &apos;k&apos;, &apos;l&apos;};
    private Character six = new Character(&apos;6&apos;);
    private char[] sixC = {&apos;m&apos;, &apos;n&apos;, &apos;o&apos;};
    private Character seven = new Character(&apos;7&apos;);
    private char[] sevenC = {&apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;};
    private Character eight = new Character(&apos;8&apos;);
    private char[] eightC = {&apos;t&apos;, &apos;u&apos;, &apos;v&apos;};
    private Character nine = new Character(&apos;9&apos;);
    private char[] nineC = {&apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;};

    public Solution(){
        hmap.put(two, twoC);
        hmap.put(three, threeC);
        hmap.put(four, fourC);
        hmap.put(five, fiveC);
        hmap.put(six, sixC);
        hmap.put(seven, sevenC);
        hmap.put(eight, eightC);
        hmap.put(nine, nineC);
    }

    public List&lt;String&gt; letterCombinations(String digits) {
        List&lt;String&gt; res = new ArrayList&lt;String&gt;();

        backTracing(digits, 0, &quot;&quot;, res);

        return res;
    }

    private void backTracing(String digits, int index, String cur, List&lt;String&gt; res){
        int l = digits.length();
        if (l == 0)
            return;
        if (index == l){
            res.add(cur);
            return;
        }


        Character tmpc = new Character(digits.charAt(index));
        if(hmap.containsKey(tmpc)){
            for (char c :hmap.get(tmpc)){
                backTracing(digits, index+1, cur+c, res);
            }
        }

    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a digit string, return all possible letter combinations that the number could represent.</p>
<p>A]]>
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Path Sum II(Java)]]></title>
    <link href="http://yoursite.com/2016/01/27/Leetcode-Path-Sum-II-Java/"/>
    <id>http://yoursite.com/2016/01/27/Leetcode-Path-Sum-II-Java/</id>
    <published>2016-01-27T22:11:58.000Z</published>
    <updated>2016-01-27T23:05:21.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p>
<p>For example:<br>Given the below binary tree and sum = 22,</p>
<pre><code>      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1
</code></pre><p>return</p>
<pre><code>[
      [5,4,11,2],
       [5,8,4,5]
]
</code></pre><p><strong>Thinking:</strong></p>
<p>We should use classic dfs method to solve this problem and record all the results.</p>
<p><strong>Solution:</strong></p>
<p>But my first version of solution is time limit exceeded:</p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) {
    List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();

    return dp(root, sum, res);
}

private List&lt;List&lt;Integer&gt;&gt; dp(TreeNode root, int sum, List&lt;Integer&gt; cur){
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    if (root == null)
        return null;
    if (root.left == null &amp;&amp; root.right == null){
        if (root.val == sum){
            cur.add(root.val);
            res.add(cur);
            return res;
        }
        else{
            return res;
        }
    }
    for (List&lt;Integer&gt; ele: dp(root.left, sum-root.val, cur)){
        if (ele != null){
            ele.add(0, root.val);
            res.add(ele);
        }
    }
    for (List&lt;Integer&gt; ele: dp(root.right, sum-root.val, cur)){
        if (ele != null){
            ele.add(0, root.val);
            res.add(ele);
        }
    }

    return res;
}
</code></pre><p>Then I have to improve the effiency of this algorithm, and the code is below:</p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) {
    List&lt;Integer&gt; cur = new ArrayList&lt;Integer&gt;();
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();

    dp(root, sum, cur, res);

    return res;
}

private void dp(TreeNode root, int sum, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; res){
    if (root == null)
        return;
    //preorder dfs

    sum -= root.val;
    if (root.left == null &amp;&amp; root.right == null){
        if (sum == 0){
            cur.add(root.val);
            List&lt;Integer&gt; tempres = new ArrayList&lt;Integer&gt;();
            tempres.addAll(cur);
            res.add(tempres);
            cur.remove(cur.size() - 1);
        }
        return;
    }
    cur.add(root.val);
    if (root.left != null){
        dp(root.left, sum, cur, res);
    }
    if (root.right != null){
        dp(root.right, sum, cur, res);
    }
    cur.remove(cur.size() - 1);
}
</code></pre><p>It’s very importatn to create a new List while put the current list data to final result, becuase if not we will only copy the address of this variable cur. Then it will be incorrect if we revise cur.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.<]]>
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://yoursite.com/2016/01/27/hello-world/"/>
    <id>http://yoursite.com/2016/01/27/hello-world/</id>
    <published>2016-01-27T22:00:19.000Z</published>
    <updated>2016-01-27T22:00:19.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start"><a href="#Quick_Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create_a_new_post"><a href="#Create_a_new_post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server"><a href="#Run_server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files"><a href="#Generate_static_files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites"><a href="#Deploy_to_remote_sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.]]>
    </summary>
    
      <category term="uncategoried" scheme="http://yoursite.com/categories/uncategoried/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Flatten Binary Tree to Linked List(Java)]]></title>
    <link href="http://yoursite.com/2016/01/27/leetcode-flatten-binary-tree-to-linked-list/"/>
    <id>http://yoursite.com/2016/01/27/leetcode-flatten-binary-tree-to-linked-list/</id>
    <published>2016-01-27T22:00:06.000Z</published>
    <updated>2016-01-27T22:00:06.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<pre><code>    1
   / \
  2   5
 / \   \
3   4   6
</code></pre><p>The flattened tree should look like:</p>
<pre><code>1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
</code></pre><p>Hint:<br>If you notice carefully in the flattened tree, each node’s right child points to the next node of a pre-order traversal.</p>
<p><strong>Thinking:</strong> </p>
<p>It’s a simple dfs question and it’s pre-order. So we need to make the left-child become right-child of root and make right-child become whole left-child’s right-child. </p>
<p><strong>Solution:</strong></p>
<pre><code>public class Solution {
    public void flatten(TreeNode root) {
        if (root == null)
            return;
        dfs(root);
    }

    public TreeNode dfs(TreeNode root){

        if (root.left == null &amp;&amp; root.right == null){
            return root;
        }

        TreeNode left = null;
        TreeNode right = null;
        TreeNode preleft = root.left;
        TreeNode preright = root.right;
        if (preleft == null){
            return dfs(preright);
        }
        else if(preright == null){
            root.left = null;
            root.right = preleft;
            return dfs(preleft);
        }
        else{
            left = dfs(preleft);
            right = dfs(preright);
            root.left = null;
            root.right = preleft;
            left.right = preright;
            return right;
        }
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<pre><code>]]>
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Triangle(Java)]]></title>
    <link href="http://yoursite.com/2016/01/27/Leetcode-Triangle/"/>
    <id>http://yoursite.com/2016/01/27/Leetcode-Triangle/</id>
    <published>2016-01-27T21:58:25.000Z</published>
    <updated>2016-01-27T21:58:25.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>
<p>For example, given the following triangle:</p>
<pre><code>[
       [2],
     [3,4],
    [6,5,7],
   [4,1,8,3]
]
</code></pre><p>The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</p>
<p>Note:<br>Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</p>
<p><strong>Thinking:</strong><br>It’s a simple dynamic programming question. The expression is dp[i][j] = min(d[i-1][j-1], d[i][j]) + triangle[i][j].</p>
<p>But the first time, my code is time exceed:</p>
<pre><code>public class Solution {
    public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) {
        int lr = triangle.size();
        if(lr == 0){
            return 0;
        }
        int lc = triangle.get(lr-1).size();
        int min = 100000;
        for(int i = 0; i &lt; lc; i++){
            int tmp = dp(triangle, lr-1, i);
            if(tmp &lt; min)
                min = tmp;
        }
        return min;
    }

    public int dp(List&lt;List&lt;Integer&gt;&gt; triangle, int row, int column){
        if(row == 0){
            return triangle.get(0).get(0);
        }
        int value = triangle.get(row).get(column);
        int size = triangle.get(row-1).size();
        if(column &gt;= size){
            return dp(triangle, row-1, column-1) + value;
        }
        else if(column - 1 &lt; 0){
            return dp(triangle, row-1, column) + value;
        }
        else{
            int res1 = dp(triangle, row-1, column-1) + value;
            int res2 = dp(triangle, row-1, column) + value;
            if(res1 &lt; res2){
                return res1;
            }
            else{
                return res2;
            }
        }
    }
}
</code></pre><p>Then I noticed the bonus, so I change my mind to use <em>iteration</em>:</p>
<pre><code>public class Solution{
    public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle){
        int lr = triangle.size();
        int[] min = new int[lr];
        int[] tempmin = new int[lr];
        min[0] = triangle.get(0).get(0);
        for(int i = 1; i &lt; lr; i++){
            tempmin[0] = min[0] + triangle.get(i).get(0);
            tempmin[i] = min[i-1] + triangle.get(i).get(i);
            for(int j = 1; j &lt; i; j++){
                int res1 = min[j-1] + triangle.get(i).get(j);
                int res2 = min[j] + triangle.get(i).get(j);
                if(res1 &lt; res2)
                    tempmin[j] = res1;
                else
                    tempmin[j] = res2;
            }
            for(int k = 0; k &lt; i+1; k++){
                min[k] = tempmin[k];
            }
        }
        int m = 100000;
        for(int i = 0; i &lt; lr; i++){
            if(min[i] &lt; m)
                m = min[i];
        }
        return m;
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numb]]>
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTTP method: get and post]]></title>
    <link href="http://yoursite.com/2016/01/26/HTTP-method-get-and-post/"/>
    <id>http://yoursite.com/2016/01/26/HTTP-method-get-and-post/</id>
    <published>2016-01-27T07:08:43.000Z</published>
    <updated>2016-01-27T21:59:18.000Z</updated>
    <content type="html"><![CDATA[<p><strong>HTTP:</strong></p>
<p>HTTP is the foundation of data commnication of the World Wide Web. The basic work method of http is request and response.</p>
<p>There are two methods of HTTP request: Get and Post.</p>
<p>Get - get request data from specific source.<br>Post - Push data which will be dealed to specific source.</p>
<p><strong>GET:</strong></p>
<p>Note that the query string (name/value pairs) is sent in the URL of a GET request:</p>
<pre><code>http://www.w3schools.com/tags/ref_httpmethods.asp
</code></pre><p>Some other notes on GET requests:</p>
<p>GET requests can be cached</p>
<p>GET requests remain in the browser history</p>
<p>GET requests can be bookmarked</p>
<p>GET requests should never be used when dealing with sensitive data</p>
<p>GET requests have length restrictions</p>
<p>GET requests should be used only to retrieve data</p>
<p><strong>POST:</strong></p>
<p>Note that the query string (name/value pairs) is sent in the HTTP message body of a POST request:</p>
<pre><code>POST /test/demo_form.asp HTTP/1.1
Host: w3schools.com
name1=value1&amp;name2=value2
</code></pre><p>Some other notes on POST requests:</p>
<p>POST requests are never cached</p>
<p>POST requests do not remain in the browser history</p>
<p>POST requests cannot be bookmarked</p>
<p>POST requests have no restrictions on data length</p>
<p><strong>Compare GET vs. POST:</strong></p>
<table>
<thead>
<tr>
<th>Tables</th>
<th style="text-align:center">GET</th>
<th style="text-align:right">POST</th>
</tr>
</thead>
<tbody>
<tr>
<td>BACK button/Reload</td>
<td style="text-align:center">Harmless</td>
<td style="text-align:right">Data will be re-submitted</td>
</tr>
<tr>
<td>Bookmarked</td>
<td style="text-align:center">can be bookmarked</td>
<td style="text-align:right">Can not be bookmarked</td>
</tr>
<tr>
<td>Cached</td>
<td style="text-align:center">Can be cached</td>
<td style="text-align:right">Can not be cached</td>
</tr>
<tr>
<td>History</td>
<td style="text-align:center">Parameters remain in browser history</td>
<td style="text-align:right">Parameters are not saved in browser history</td>
</tr>
<tr>
<td>Restrictions on data length</td>
<td style="text-align:center">Yes</td>
<td style="text-align:right">No</td>
</tr>
<tr>
<td>Security</td>
<td style="text-align:center">Less secure</td>
<td style="text-align:right">Safer</td>
</tr>
<tr>
<td>Visibility</td>
<td style="text-align:center">Visible</td>
<td style="text-align:right">Not visible in URL</td>
</tr>
</tbody>
</table>
<p>Reference: <a href="http://www.w3schools.com/tags/ref_httpmethods.asp" target="_blank" rel="external">http://www.w3schools.com/tags/ref_httpmethods.asp</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>HTTP:</strong></p>
<p>HTTP is the foundation of data commnication of the World Wide Web. The basic work method of http is request]]>
    </summary>
    
      <category term="Network" scheme="http://yoursite.com/categories/Network/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Construct Binary Tree from Preorder and Inorder Traversal(Java)]]></title>
    <link href="http://yoursite.com/2016/01/26/Leetcode-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Java/"/>
    <id>http://yoursite.com/2016/01/26/Leetcode-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Java/</id>
    <published>2016-01-27T06:28:05.000Z</published>
    <updated>2016-01-27T21:58:44.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>You may assume that duplicates do not exist in the tree.</p>
<p><strong>Thinking:</strong></p>
<p>This question is similar with Construct Binary Tree from Inorder and Postorder Traversal. We should understand the differences and the sequences of these three methods. And divide into three parts- root, left child and right child.</p>
<p><strong>Solution:</strong></p>
<pre><code>public TreeNode buildTree(int[] preorder, int[] inorder) {
    int l = preorder.length;
    if (l == 0)
        return null;


    return dp(preorder, inorder, 0, l-1, 0, l-1);
    }

    private TreeNode dp(int[] preorder, int[] inorder, int preStart, int preEnd, int inStart, int inEnd){
    if (preStart &gt; preEnd || preEnd &gt;= preorder.length || inEnd &gt;= preorder.length)
        return null;
    TreeNode root = new TreeNode(preorder[preStart]);
    int index = inStart;
    for (; index &lt; inEnd; index++){
        if (inorder[index] == preorder[preStart])
            break;
    }

    TreeNode left = dp(preorder, inorder, preStart+1, preStart+index-inStart, inStart, index-1);
    TreeNode right = dp(preorder, inorder,preStart+index-inStart+1, preEnd, index+1, inEnd);
    root.left = left;
    root.right = right;

    return root;
}    
</code></pre><p>This method can be improved by using HashMap to make it faster when fiding the index of root.<br>Reference:<a href="http://blog.csdn.net/linhuanmars/article/details/24389549" target="_blank" rel="external">http://blog.csdn.net/linhuanmars/article/details/24389549</a><br>Code:</p>
<pre><code>static HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
public TreeNode buildTree(int[] preorder, int[] inorder) {
    int l = preorder.length;
    if (l == 0)
        return null;
    for (int i = 0; i &lt; l; i++)
        map.put(inorder[i], i);

    return dp(preorder, inorder, 0, l-1, 0, l-1);
}

private TreeNode dp(int[] preorder, int[] inorder, int preStart, int preEnd, int inStart, int inEnd){
    if (preStart &gt; preEnd || inStart &gt; inEnd)
        return null;
    TreeNode root = new TreeNode(preorder[preStart]);

    int index = map.get(preorder[preStart]);

    TreeNode left = dp(preorder, inorder, preStart+1, preStart+index-inStart, inStart, index-1);
    TreeNode right = dp(preorder, inorder,preStart+index-inStart+1, preEnd, index+1, inEnd);
    root.left = left;
    root.right = right;

    return root;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>You may assu]]>
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Pow(x, n)(Java)]]></title>
    <link href="http://yoursite.com/2016/01/26/Leetcode-Pow-x-n-Java/"/>
    <id>http://yoursite.com/2016/01/26/Leetcode-Pow-x-n-Java/</id>
    <published>2016-01-27T05:24:27.000Z</published>
    <updated>2016-01-27T21:58:38.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Implement pow(x, n).</p>
<p><strong>Thinking:</strong></p>
<p>It’s a simple but not simple question. There are many solutions for this problem. But how can we find the most effienct one. We can use recursion to reduce the times of multipling and check the bound of data to reduce the times of recursions. Finally, the code is below:</p>
<pre><code>static boolean negflag = false;
public double myPow(double x, int n) {
    if (n &lt; 0){
        negflag = true;
        return 1 / dp(x, -n);
    }
    else
        return dp(x, n);

}
private double dp(double x, int n){
    if (n == 0)
        return 1;
    if (n == 1)
        return x;
    if (n == 2)
        return x * x;

    int m = n / 2;
    int k = n % 2;
    double v = dp(x, m);
    if (negflag == true &amp;&amp; v &gt; 100000)
        return 100000;
    if (negflag == false &amp;&amp; v &lt; 0.00001)
        return 0;

    if (k == 0)
        return v * v;
    else
        return v * v * x;
}
</code></pre><p>By the way, I have to metion that my python solution is like, lol:</p>
<pre><code>def myPow(self, x, n):
    return x**n
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Implement pow(x, n).</p>
<p><strong>Thinking:</strong></p>
<p>It’s a simple but not simple question. Th]]>
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Jump Game(Java)]]></title>
    <link href="http://yoursite.com/2016/01/26/Leetcode-Jump-Game-Java/"/>
    <id>http://yoursite.com/2016/01/26/Leetcode-Jump-Game-Java/</id>
    <published>2016-01-27T04:20:54.000Z</published>
    <updated>2016-01-27T21:58:33.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<p>For example:<br>A = [2,3,1,1,4], return true.</p>
<p>A = [3,2,1,0,4], return false.</p>
<p><strong>Thinking:</strong></p>
<p>It’s a problem can be solved in greedy algorithm. Because we should go as far as possible in current position until we can’t go father. And we should gurantee the value of current position + i (steps can be reached from current postion) + nums[cur + i] be as big as possible.</p>
<p><strong>Solution:</strong></p>
<pre><code>public boolean canJump(int[] nums) {
    int l = nums.length;
    if (nums[0] == 0 &amp;&amp; l &gt; 1)
        return false;
    int cur = 0;
    int temp = nums[0];
    int step = nums[0];
    int max = nums[0];
    int tempcur = 0;

    while (cur + step &lt; l-1){
        for (int i = 1; i &lt;= step; i++){
            temp = cur + i + nums[cur + i];
            if (temp &gt;= max){//current max greedy value
                max = temp;
                if (max &gt;= l)
                    return true;
                tempcur = cur + i;
            }
        }
        if (cur == tempcur)
            return false;
        cur = tempcur;
        step = nums[cur];
    }

    if (max &gt;= l-1)
        return true;
    else
        return false;
}
</code></pre><p>What’s more, we can make it easier by max the value of index. </p>
<pre><code>public boolean canJump(int[] nums) {
    if(nums.length &lt;= 1)
        return true;

    int max = nums[0]; //max stands for the largest index that can be reached.

    for(int i=0; i&lt;nums.length; i++){
        //if not enough to go to next
        if(max &lt;= i &amp;&amp; nums[i] == 0) 
            return false;

        //update max    
        if(i + nums[i] &gt; max){
            max = i + nums[i];
        }

        //max is enough to reach the end
        if(max &gt;= nums.length-1) 
            return true;
    }

    return false;    
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.<]]>
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-3Sum Closest(Java)]]></title>
    <link href="http://yoursite.com/2016/01/26/Leetcode-3Sum-Closest-Java/"/>
    <id>http://yoursite.com/2016/01/26/Leetcode-3Sum-Closest-Java/</id>
    <published>2016-01-27T00:38:28.000Z</published>
    <updated>2016-01-27T21:58:53.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<p>For example, given array S = {-1 2 1 -4}, and target = 1.</p>
<p>The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</p>
<p><strong>Thinking:</strong></p>
<p>In order to improve the performance of algorithm, we should sort the array. Because of that, we can determine where to go using current result.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int threeSumClosest(int[] nums, int target) {
    int l = nums.length;
    if (l &lt; 3)
        return 0;
    int min = Integer.MAX_VALUE;
    int res = 0;
    Arrays.sort(nums);

    for (int i = 0; i &lt; l; i++){
        int j = i + 1;
        int k = l - 1;

        while (j &lt; k){
            int sum = nums[i] + nums[j] + nums[k];
            if (sum == target)
                return sum;
            int diff = Math.abs(sum - target);
            if (diff &lt; min){
                min = diff;
                res = sum;
            }
            if (sum &gt; target)
                k--;
            else
                j++;
        }

    }
    return res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number]]>
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Construct Binary Tree from Inorder and Postorder Traversal(Java)]]></title>
    <link href="http://yoursite.com/2016/01/26/Leetcode-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-Java/"/>
    <id>http://yoursite.com/2016/01/26/Leetcode-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-Java/</id>
    <published>2016-01-27T00:00:18.000Z</published>
    <updated>2016-01-27T21:58:57.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>You may assume that duplicates do not exist in the tree.</p>
<p><strong>Thinking:</strong></p>
<p>Inorder traversal will search in order: left, root, right;</p>
<p>Postorder travelsal will search in order: left, right, root.</p>
<p>So we can find the root in postorder and search it in inorder by the value. And find root’s left child and right child node by recursion.</p>
<pre><code>public TreeNode buildTree(int[] inorder, int[] postorder) {
    int l = inorder.length;
    if (l == 0)
        return null;
    TreeNode root = new TreeNode(postorder[l-1]);
    TreeNode left = null;
    TreeNode right = null;
    int index = 0;
    for (; index &lt; l; index++){
        if (inorder[index] == postorder[l-1])
            break;
    }


    if (index &gt; 0){
        int[] leftinorder = new int[index];
        int[] leftpostorder = new int[index];
        System.arraycopy(inorder, 0, leftinorder, 0, index);
        System.arraycopy(postorder, 0, leftpostorder, 0, index);
        left = buildTree(leftinorder, leftpostorder);
    }
    if (index &lt; l-1){
        int[] rightinorder = new int[l-index-1];
        int[] rightpostorder = new int[l-index-1];
        System.arraycopy(inorder, index+1, rightinorder, 0, l-index-1);
        System.arraycopy(postorder, index, rightpostorder, 0, l-index-1);
        right = buildTree(rightinorder, rightpostorder);
    }
    root.left = left;
    root.right = right;

    return root;
}
</code></pre><p>By the way, this code can be improved because in Java we can not easily get the subarray and I use the System.arraycopy. It can be replaced by recording the postion of array.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>You may ass]]>
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Lowest Common Ancestor of a Binary Tree(Java)]]></title>
    <link href="http://yoursite.com/2016/01/26/Leetcode-Lowest-Common-Ancestor-of-a-Binary-Tree-Java/"/>
    <id>http://yoursite.com/2016/01/26/Leetcode-Lowest-Common-Ancestor-of-a-Binary-Tree-Java/</id>
    <published>2016-01-26T23:18:55.000Z</published>
    <updated>2016-01-27T21:59:02.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”</p>
<pre><code>           _______3______
         /              \
  ___5__           ___1___
    /      \         /          \
6        2       0         8
         /  \
        7    4
</code></pre><p>For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</p>
<p><strong>Thinking:</strong></p>
<p>The point to find the lowest common ancestor is to find a node whose left and right childs both have the node we want to find. Because if it’s not the lowest, the node will only belong to one of their child. If search in a pre-order from the root, if one node’s left child and right child both have the keynode or if the node itself is one of the keynode which means the other node will in lower level of this node, it’s the answer we want.</p>
<p><strong>Solution:</strong></p>
<pre><code>public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null)
        return root;

    if (root.equals(q) || root.equals(p)){
        return root;
    }

    TreeNode l = lowestCommonAncestor(root.left, p, q);
    TreeNode r = lowestCommonAncestor(root.right, p, q);
    if (l != null &amp;&amp; r != null)
        return root;

    return l == null? r: l;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>Accor]]>
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Node.js study note]]></title>
    <link href="http://yoursite.com/2016/01/25/Node-js-study-note/"/>
    <id>http://yoursite.com/2016/01/25/Node-js-study-note/</id>
    <published>2016-01-26T05:11:55.000Z</published>
    <updated>2016-01-31T05:21:27.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Survey:</strong></p>
<p>Node.js is an open-source, cross-platform runtime environment for developing server-side Web applications. Node.js is not a JavaScript framework,[3] but its applications are written in JavaScript and can be run within the Node.js runtime on a wide variety of platforms.</p>
<p>This is my first time to learn Node.js, and I’ll write casully about the process and experience of learning.</p>
<hr>
<p><strong>Content:</strong></p>
<p>–1– Argument variables with process.argv</p>
<pre><code>app.js

function grab(flag){
    var index = process.argv.indexOf(flag);
    return (index === -1) ? null : process.argv[index+1];
}

var greeting = grab(&apos;--greeting&apos;);
var user = grab(&apos;--user&apos;);

if (!user || !greeting) {
    console.log(&quot;You blew it!&quot;);
} else {
    console.log(`Welcome, ${user}, ${greeting}`);
}
</code></pre><p>In this code, we grab the arguments from shell and print it out on the console.</p>
<p>For example, if in the shell:</p>
<pre><code>$node app --user Martin --greeting &quot;hello hello&quot;
</code></pre><p>Then in the console:</p>
<pre><code>Welcome, Martin, hello hello
</code></pre><p>And in this code, I also learned string temple which uses backticks<code>.</code>Welcome, ${user}, ${greeting}` will contain variable user and greeting.</p>
<hr>
<p>–2– Standard input and standard output</p>
<pre><code> var questions = [
&quot;What is your name?&quot;,
&quot;What is your favorite hobby?&quot;,
&quot;What is your preferred programming language?&quot;
];

var answers = [];

function ask(i) {
    process.stdout.write(`\n\n\n\n ${questions[i]}`);
    process.stdout.write(&quot;  &gt;  &quot;);
}

process.stdin.on(&apos;data&apos;, function(data){

    answers.push(data.toString().trim());

    if (answers.length &lt; questions.length) {
        ask(answers.length);
    } else {
        process.exit();
    }
});

process.on(&apos;exit&apos;, function(){

    process.stdout.write(&quot;\n\n\n\n&quot;);

    process.stdout.write(`Go ${answers[1]} ${answers[0]} you can finish writing ${answers[2]} later`);

    process.stdout.write(&quot;\n\n\n\n&quot;);

});

ask(0);
</code></pre><p>In the shell:</p>
<pre><code>What is your name?  &gt;  Martin




 What is your favorite hobby?  &gt;  play games




 What is your preferred programming language?  &gt;  python




Go play games Martin you can finish writing python later
</code></pre><p>Is that funny:)?</p>
<hr>
<p>–3– Global timing functions</p>
<p>There are several functions about the timing such as setInterval, setTimeout and clearInterval. It’s useful while developing web interactive program. </p>
<p>Code:</p>
<pre><code>var waitTime = 3000;
var currentTime = 0;
var waitInterval = 10;
var percentWaited = 0;

function writeWaitingPercent(p){
    process.stdout.clearLine();
    process.stdout.cursorTo(0);
    process.stdout.write(`waiting ... ${p}%`);

}


var interval = setInterval(function(){
    currentTime += waitInterval;
    percentWaited = Math.floor((currentTime/    waitTime)*100);
    //console.log(`waiting ${currentTime/1000} seconds`);
    writeWaitingPercent(percentWaited);
}, waitInterval);

setTimeout(function(){

    clearInterval(interval);
    console.log(&quot;\ndone&quot;);
}, waitTime);

process.stdout.write(&quot;\n\n&quot;);
writeWaitingPercent(percentWaited);
</code></pre><p>In the shell:</p>
<pre><code>waiting ... 81%
done
</code></pre><p>–4– Core modules:</p>
<p>Node.js use require function to get modules. This section is going to show some modules of Node.js.</p>
<p>Code:</p>
<pre><code>var path = require(&apos;path&apos;);
var util = require(&apos;util&apos;);
var v8 = require(&apos;v8&apos;)


util.log( path.basename(__filename) );

var dirUploads = path.join(__dirname, &apos;www&apos;, &apos;fileds&apos;, &apos;uploads&apos;);

util.log(dirUploads);

util.log(v8.getHeapStatistics());
</code></pre><p>In the shell:</p>
<pre><code>node core
28 Jan 23:34:37 - core.js
28 Jan 23:34:37 - /Users/Martin/Documents/martin/    Study/Node/www/fileds/uploads
28 Jan 23:34:37 - { total_heap_size: 7523616,
  total_heap_size_executable: 5242880,
  total_physical_size: 7523616,
  total_available_size: 1491271696,
  used_heap_size: 4094992,
  heap_size_limit: 1535115264 }
</code></pre><p>–5– Collecting information with Readline 11m 30s</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Survey:</strong></p>
<p>Node.js is an open-source, cross-platform runtime environment for developing server-side Web applications]]>
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Insertion Sort List(Java)]]></title>
    <link href="http://yoursite.com/2016/01/24/Leetcode-Insertion-Sort-List-Java/"/>
    <id>http://yoursite.com/2016/01/24/Leetcode-Insertion-Sort-List-Java/</id>
    <published>2016-01-25T05:07:32.000Z</published>
    <updated>2016-01-27T21:59:29.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Sort a linked list using insertion sort.</p>
<p><strong>Thinking:</strong></p>
<p>As the question state, we should apply the insertion sort method to linked list. So we create a ListNode for hold the sorted list, and scan the unsorted list and pick up element to compare the element in the sorted list. Then determine when to insert the value.</p>
<p><strong>Solution:</strong></p>
<pre><code>public class Solution {
    public ListNode insertionSortList(ListNode head) {
        if (head == null || head.next == null)
            return head;
        ListNode res = new ListNode(-1);
        res.next = head;
        ListNode p = res;
        ListNode next = head.next;
        head.next = null;
        head = next;
        while (head != null){
            while (p.next != null){
                //if the value is smaller than one of the sorted list, insert behind it
                if (head.val &lt; p.next.val){
                    next = head.next;
                    head.next = p.next;
                    p.next = head;
                    head = next;
                    p = res;
                    break;
                }
                p = p.next;
            }
            //if the value is bigger than anyone of the sorted list, insert after the whole list
            if (p.next == null){
                next = head.next;
                p.next = head;
                head.next = null;
                head = next;
                p = res;
            }
        }

        return res.next;
    }
}
</code></pre><p>I also copy a refining version of this algorithm from reference: <a href="http://www.cnblogs.com/springfor/p/3862468.html" target="_blank" rel="external">http://www.cnblogs.com/springfor/p/3862468.html</a></p>
<pre><code>public ListNode insertionSortList(ListNode head) {  
    if(head == null||head.next == null)  
        return head;  
    ListNode sortedlisthead = new ListNode(0);  
    ListNode cur = head;
    while(cur!=null){  
        ListNode next = cur.next;  
        ListNode pre = sortedlisthead;  
        while(pre.next!=null &amp;&amp; pre.next.val&lt;cur.val)  
            pre = pre.next;  
        cur.next = pre.next;  
        pre.next = cur;  
        cur = next;  
    }  
    return sortedlisthead.next;  
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Sort a linked list using insertion sort.</p>
<p><strong>Thinking:</strong></p>
<p>As the question state]]>
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sort Algorithms]]></title>
    <link href="http://yoursite.com/2016/01/24/Sort-Algorithms/"/>
    <id>http://yoursite.com/2016/01/24/Sort-Algorithms/</id>
    <published>2016-01-25T04:07:31.000Z</published>
    <updated>2016-01-29T00:48:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Survey_3A"><a href="#Survey_3A" class="headerlink" title="Survey:"></a>Survey:</h2><p>This time, we talk about eight kinds of sort algorithms: insertion sort, shell’s sort, simple selection sort, heap sort, bubble sort, quick sort, merge sort and radix sort.</p>
<h2 id="Insertion_sort_3A"><a href="#Insertion_sort_3A" class="headerlink" title="Insertion sort:"></a>Insertion sort:</h2><p><strong>Main Idea:</strong></p>
<p>From the beginning of the list, get one value at a time and insert the value into right position of sorted list until all the values are sorted. And insertion sort is stalbe.</p>
<p><strong>Process:</strong> (From Wikimedia)</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/4/42/Insertion_sort.gif" alt=""></p>
<p><strong>Pseudocode:</strong></p>
<pre><code>for i ← 1 to length(A) - 1
    j ← i
    while j &gt; 0 and A[j-1] &gt; A[j]
        swap A[j] and A[j-1]
        j ← j - 1
    end while
end for
</code></pre><p><strong>Implemention in Java:</strong></p>
<pre><code>public static void InsertionSort(int[] num)
{
     int j;
     int key;
     int i;  

     for (j = 1; j &lt; num.length; j++){
        key = num[j];
        for(i = j - 1; (i &gt;= 0) &amp;&amp; (num[i] &lt; key); i--){
            num[i+1] = num[i];
        }
        num[i+1] = key;
    }
}
</code></pre><p><strong>Complexity:</strong></p>
<p><em>Runtime</em>: O(n^2)</p>
<p><em>Memery</em>: O(1)</p>
<hr>
<h2 id="ShellSort_3A"><a href="#ShellSort_3A" class="headerlink" title="ShellSort:"></a>ShellSort:</h2><p><strong>Main Idea:</strong></p>
<p>The method starts by sorting pairs of elements far apart from each other, then progressively reducing the gap between elements to be compared. Starting with far apart elements can move some out-of-place elements into position faster than a simple nearest neighbor exchange.</p>
<p><strong>Process:</strong>(From Wikimedia)</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/d/d8/Sorting_shellsort_anim.gif" alt=""></p>
<p><strong>Pesedocode:</strong></p>
<pre><code>gaps = [701, 301, 132, 57, 23, 10, 4, 1]

foreach (gap in gaps)
{
    # Do a gapped insertion sort for this gap size.
    # The first gap elements a[0..gap-1] are already in gapped order
    # keep adding one more element until the entire array is gap sorted
    for (i = gap; i &lt; n; i += 1)
    {
        # add a[i] to the elements that have been gap sorted
        # save a[i] in temp and make a hole at position i
        temp = a[i]
        # shift earlier gap-sorted elements up until the correct location for a[i] is found
        for (j = i; j &gt;= gap and a[j - gap] &gt; temp; j -= gap)
        {
            a[j] = a[j - gap]
        }
        # put temp (the original a[i]) in its correct location
        a[j] = temp
        }
    }
</code></pre><p> <strong>Implemention in Java:</strong></p>
<pre><code>public void shellSort() {
    int inner, outer;
    long temp;
    //find initial value of h
    int h = 1;
    while (h &lt;= len / 3)
      h = h * 3 + 1; // (1, 4, 13, 40, 121, ...)

    while (h &gt; 0) // decreasing h, until h=1
    {
      // h-sort the file
      for (outer = h; outer &lt; len; outer++) {
        temp = data[outer];
        inner = outer;
        // one subpass (eg 0, 4, 8)
        while (inner &gt; h - 1 &amp;&amp; data[inner - h] &gt;= temp) {
          data[inner] = data[inner - h];
          inner -= h;
        }
        data[inner] = temp;
      }
      h = (h - 1) / 3; // decrease h
    }
}
</code></pre><hr>
<h2 id="Simple_Selection_Sort"><a href="#Simple_Selection_Sort" class="headerlink" title="Simple Selection Sort"></a>Simple Selection Sort</h2><p><strong>Main Idea:</strong></p>
<p>Find the smallest(biggest) element in array, put it in the first place. Then find the second smallest… Do these until all the element are sorted.(I suppose it’s a little similar with bubble sort)</p>
<p><strong>Process:</strong>(From Wikimedia)</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/4/42/Insertion_sort.gif" alt=""></p>
<p><strong>Pesedocode:</strong></p>
<pre><code>for i ← 1 to length(A) - 1
    j ← i
    while j &gt; 0 and A[j-1] &gt; A[j]
        swap A[j] and A[j-1]
        j ← j - 1
    end while
end for
</code></pre><p><strong>Complexity:</strong></p>
<p><em>Runtime:</em> O(n^2)<br><em>Memery:</em> O(1)</p>
<h2 id="Heapsort"><a href="#Heapsort" class="headerlink" title="Heapsort"></a>Heapsort</h2><p><strong>Main Idea:</strong></p>
<p>Use data structure heap which will store the smallest or biggest value of the array. Then pick up the root of heap   once a time to sort. </p>
<p>Heapsort is a comparison-based sorting algorithm. Heapsort can be thought of as an improved selection sort: like that algorithm, it divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. The improvement consists of the use of a heap data structure rather than a linear-time search to find the maximum.</p>
<p>This sort is the most important part in this article. I’ll talk about the relative operation and its performance and all the code.</p>
<p><strong>Process:</strong>(From Wikimedia)</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/1/1b/Sorting_heapsort_anim.gif" alt=""></p>
<p>In the heap view(an example offered):</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/4/4d/Heapsort-example.gif" alt=""></p>
<p><strong>Data Structure:</strong></p>
<p>Heap:</p>
<p>A heap is built out of the data. The heap is often placed in an array with the layout of a complete binary tree. The complete binary tree maps the binary tree structure into the array indices; each array index represents a node; the index of the node’s parent, left child branch, or right child branch are simple expressions. For a zero-based array, the root node is stored at index 0; if i is the index of the current node, then</p>
<pre><code>iParent(i)     = floor((i-1) / 2)
iLeftChild(i)  = 2*i + 1
iRightChild(i) = 2*i + 2
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Survey_3A"><a href="#Survey_3A" class="headerlink" title="Survey:"></a>Survey:</h2><p>This time, we talk about eight kinds of sort a]]>
    </summary>
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
  </entry>
  
</feed>
