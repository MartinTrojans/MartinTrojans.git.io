<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Martin's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-02-02T23:09:18.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Martin]]></name>
    <email><![CDATA[martinglory1992@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Leetcode-Combination Sum II(Java)]]></title>
    <link href="http://yoursite.com/2016/02/02/Leetcode-Combination-Sum-II-Java/"/>
    <id>http://yoursite.com/2016/02/02/Leetcode-Combination-Sum-II-Java/</id>
    <published>2016-02-02T23:09:18.000Z</published>
    <updated>2016-02-02T23:09:18.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Reverse Linked List II(Java)]]></title>
    <link href="http://yoursite.com/2016/02/02/Leetcode-Reverse-Linked-List-II-Java/"/>
    <id>http://yoursite.com/2016/02/02/Leetcode-Reverse-Linked-List-II-Java/</id>
    <published>2016-02-02T21:50:10.000Z</published>
    <updated>2016-02-02T23:09:54.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p>
<p>For example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,</p>
<p>return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL.</p>
<p>Note:<br>Given m, n satisfy the following condition:<br>1 ≤ m ≤ n ≤ length of list.</p>
<p><strong>Thinking:</strong></p>
<p>It’s similar with Reverse Linked List, only thing different is to limit the range. So we should to find the start of the reversed linked list and record its previous node. Also, we should add a dummy node for easily operator with the first node. Then use three points as usual pre, cur and next to operate and change the nodes’ next pointers.</p>
<p><strong>Solution:</strong></p>
<pre><code>public ListNode reverseBetween(ListNode head, int m, int n) {
    if (m == n)
        return head;
    ListNode prehead = new ListNode(0);//dummy
    prehead.next = head;
    ListNode pre = prehead;
    ListNode cur = head;
    int idx = 1;

    while (idx &lt; m) {
        pre = cur;
        cur = cur.next;
        idx++;
    }
    ListNode prerever = pre;
    ListNode next = null;
    pre = cur;
    cur = cur.next;
    while (idx &lt; n) {
        next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
        idx++;
    }
    prerever.next.next = cur;
    prerever.next = pre;


    return prehead.next;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p>
<p>For example:<br>Give]]>
    </summary>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Patching Array(Java)]]></title>
    <link href="http://yoursite.com/2016/02/02/Patching-Array-Java/"/>
    <id>http://yoursite.com/2016/02/02/Patching-Array-Java/</id>
    <published>2016-02-02T21:13:27.000Z</published>
    <updated>2016-02-02T21:18:49.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.</p>
<p>Example 1:<br>nums = [1, 3], n = 6<br>Return 1.</p>
<p>Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.<br>Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].<br>Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].<br>So we only need 1 patch.</p>
<p>Example 2:<br>nums = [1, 5, 10], n = 20<br>Return 2.<br>The two patches can be [2, 4].</p>
<p>Example 3:<br>nums = [1, 2, 2], n = 5<br>Return 0.</p>
<p><strong>Thinking:</strong></p>
<p>The first range we can cover of an array is total, then if we add a new element to this array and this element add &lt;= total, then the new range is [1, add+total). We should also care about the java maxint value, so if we use bit manipulation, it means it is bigger than maxint if total is smaller than zero.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int minPatches(int[] nums, int n) {
    int total = 1; //total is the upper bound of the sum
    int count = 0;
    int index = 0;
    int len = nums.length;

    while (total &lt;= n) {
        if (index &lt; len &amp;&amp; nums[index] &lt;= total){
            total += nums[index++];
        }
        else{
            total &lt;&lt;= 1;
            count++;
            if (total &lt; 0)
                break;
        }
    }


    return count;
} 
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that ]]>
    </summary>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Verify Preorder Serialization of a Binary Tree(Java)]]></title>
    <link href="http://yoursite.com/2016/02/01/Leetcode-Verify-Preorder-Serialization-of-a-Binary-Tree-Java/"/>
    <id>http://yoursite.com/2016/02/01/Leetcode-Verify-Preorder-Serialization-of-a-Binary-Tree-Java/</id>
    <published>2016-02-02T06:40:06.000Z</published>
    <updated>2016-02-02T07:18:34.000Z</updated>
    <content type="html"><![CDATA[<p>One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as #.</p>
<pre><code>     _9_
    /   \
   3     2
  / \   / \
 4   1  #  6
/ \ / \   / \
# # # #   # #
</code></pre><p>For example, the above binary tree can be serialized to the string “9,3,4,#,#,1,#,#,2,#,6,#,#”, where # represents a null node.</p>
<p>Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.</p>
<p>Each comma separated value in the string must be either an integer or a character ‘#’ representing null pointer.</p>
<p>You may assume that the input format is always valid, for example it could never contain two consecutive commas such as “1,,3”.</p>
<p>Example 1:<br>“9,3,4,#,#,1,#,#,2,#,6,#,#”<br>Return true</p>
<p>Example 2:<br>“1,#”<br>Return false</p>
<p>Example 3:<br>“9,#,#,1”<br>Return false</p>
<p><strong>Thinking:</strong></p>
<p>Accroding to the correct answer given, we can find the pattern. We should start from # and use stack to store it. When get two #, we should get another element from the string. </p>
<p><strong>Solution:</strong></p>
<pre><code>public boolean isValidSerialization(String preorder) {
    String[] strlist = preorder.split(&quot;,&quot;);
    Stack&lt;String&gt; stack = new Stack&lt;String&gt;();
    Stack&lt;String&gt; tempstack = new Stack&lt;String&gt;();

    for (String s: strlist) {
        stack.push(s);
    }
    while (!stack.isEmpty()) {
        while (!stack.isEmpty() &amp;&amp; stack.peek().equals(&quot;#&quot;)){
            tempstack.push(stack.pop());
        }
        if (tempstack.size() &lt; 2)
            break;
        while (tempstack.size() &gt;= 2 &amp;&amp; !stack.isEmpty() &amp;&amp; !stack.peek().equals(&quot;#&quot;)){
            tempstack.pop();
            tempstack.pop();
            if (!stack.isEmpty() &amp;&amp; !stack.peek().equals(&quot;#&quot;)){
                stack.pop();
                tempstack.push(&quot;#&quot;);
            }
        }
    }

    if (tempstack.size() == 1 &amp;&amp; stack.isEmpty())
        return true;
    else
        return false;
}
</code></pre><p>There is another simpler solution:</p>
<pre><code>public boolean isValidSerialization(String preorder) {
    String[] p = preorder.split(&quot;,&quot;);
    int idx = 0; // stack
    for (int i = 0; i &lt; p.length; i++) {
    if (p[i].equals(&quot;#&quot;)) {
        idx--;
    } else {
        if (idx &lt; 0) { // check
          return false;
        }
        p[idx++] = p[i];
      }
    }
    return idx == -1; // check
  }
</code></pre><p>Reference: <a href="https://leetcode.com/discuss/83903/share-my-java-solution" target="_blank" rel="external">https://leetcode.com/discuss/83903/share-my-java-solution</a></p>
<p>And another much simplier solution which caculate the indegree and outdegree:</p>
<pre><code>public boolean isValidSerialization2(String preorder) {
    String[] nodes = preorder.split(&quot;,&quot;);
    int diff = 1;
    for (String node: nodes) {
        if (--diff &lt; 0) return false;
        if (!node.equals(&quot;#&quot;)) diff += 2;
    }
    return diff == 0;
}
</code></pre><p>Reference: <a href="https://www.hrwhisper.me/leetcode-algorithm-solution/" target="_blank" rel="external">https://www.hrwhisper.me/leetcode-algorithm-solution/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node’s value. If it is]]>
    </summary>
    
      <category term="Graph" scheme="http://yoursite.com/tags/Graph/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AI Note]]></title>
    <link href="http://yoursite.com/2016/02/01/AI-Note/"/>
    <id>http://yoursite.com/2016/02/01/AI-Note/</id>
    <published>2016-02-01T23:25:11.000Z</published>
    <updated>2016-02-02T00:56:02.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Lecture 1:</strong></p>
<p><strong>Lecture 2:</strong></p>
<ol>
<li>What’s Agent?</li>
<li>PEAS</li>
</ol>
<p><strong>Lecture 3:</strong></p>
<ol>
<li>Difference between tree search and graph search:<br> Graph search will record the explored nodes, and won’t explore them again.</li>
</ol>
<p><strong>Lecture 4:</strong></p>
<ol>
<li>DFS, BFS, uniform-cost search, interative deepening search, evaluating search performance about completeness, optimality, time and space complexity</li>
<li>BFS:<br> Completeness: Yes(When b is finite)<br> Optimality: Yes(If path is nondecreasing)<br> Time: O(b^d)<br> Space: O(b^d)</li>
<li>DFS:<br> Completeness: Yes(If graph search version)<br> Optimality: No<br> Time: O(b^m)<br> Space: O(b*m)</li>
<li>Uniform-cost search:<br> Completeness: Yes<br> Optimality: Yes(If path is nondecreasing)<br> Uniform-cost search not optimal if it is terminated when some node in the queue has goal state.</li>
<li>Iterative deepening search:<br> Completeness: Yes<br> Optimality: Yes<br> Time: O(b^d)<br> Space: O(bd)</li>
</ol>
<p><strong>Lecture 5:</strong></p>
<ol>
<li>Uniformed search, bi-directional search, informed search, greedy best first search, A*, interative deepening A*, recursive best first search, simplified memory-bounded A*</li>
<li>Bidirectional search:<br> Search forward from initial state, and backward from goal.<br> Completeness: Yes<br> Optimality: Yes<br> Time: O(b^(d/2)<br> Space: O(b^(d/2)</li>
<li>Greedy best first search:<br> Greedy BFS keeps all the nodes generated in the<br>Frontier, which is sorted based on h(n).<br> Completeness: No<br> Optimality: No<br> Time: O(b^m)<br> Space: O(b^m)</li>
<li>A* Search:<br> Use (approximate) total path cost to guide search<br> Admissible Heurisitic: A heuristic is admissible if it never overestimates the cost to reach the goal<br> e.g. hSLD(n) is admissible because it never overestimates the actual road distance<br> Admissible heuristics does not guarantee that the chosen path is optimal<br> A heuristic is consistent if for every node n and every successor n’ of n generated by any action a<br>h(n) ≤ c(n,a,n’) + h(n’)<br> That is, f(n) is nondecreasing along every path.<br> Completeness: Yes<br> Optimality: Yes(if admissible in tree search or consistent in graph search)</li>
<li>Recursive Best-Frist Search:<br> Keep track of f value (f-limit) of best sibling of path currently exploring<br> Space: O(bd)</li>
<li>Memory-Bounded A*:<br>  I.e., expand best leaves until available memory is full;When full, SMA* drops worst leaf node (highest f-value);Like RBFS, backup forgotten node value to its parent</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Lecture 1:</strong></p>
<p><strong>Lecture 2:</strong></p>
<ol>
<li>What’s Agent?</li>
<li>PEAS</li>
</ol>
<p><strong>Lecture 3:<]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Kth Largest Element in an Array(Java)]]></title>
    <link href="http://yoursite.com/2016/01/31/Leetcode-Kth-Largest-Element-in-an-Array-Java/"/>
    <id>http://yoursite.com/2016/01/31/Leetcode-Kth-Largest-Element-in-an-Array-Java/</id>
    <published>2016-02-01T05:21:22.000Z</published>
    <updated>2016-02-01T06:15:05.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p>For example,<br>Given [3,2,1,5,6,4] and k = 2, return 5.</p>
<p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p>
<p><strong>Thinking:</strong></p>
<p>There are three ways to solve this problem:</p>
<ol>
<li>The first one is to build a max heap with size n, and get the top of the heap k times.</li>
<li>The second one is to build a min heap with size k, and keep the biggest top k elements of this array. Finally, get the top of it.</li>
<li>The third one is to use a method called quickselect which uses function partition. It first use a pivot to split the array into two parts, then accroding to this index, choose which part to select.</li>
</ol>
<p><strong>Solution:</strong></p>
<p>Max heap:</p>
<pre><code>public int findKthLargest1(int[] nums, int k) {
    int len = nums.length;
    PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;Integer&gt;(len, new HeapComparator());
    for (int i = 0; i &lt; len; i++){
        heap.add(nums[i]);
    }
    for (int i = 0; i &lt; k-1; i++){
        heap.poll();
    }
    return heap.peek();
}

class HeapComparator implements Comparator {

    @Override
    public int compare(Object o1, Object o2) {
        // TODO Auto-generated method stub
        int i1 = (int)o1;
        int i2 = (int)o2;
        if (i1 &gt; i2)
            return -1;
        else if (i1 == i2)
            return 0;
        else
            return 1;
    }

}
</code></pre><p>Min heap:</p>
<pre><code>public int findKthLargest2(int[] nums, int k) {
    int len = nums.length;
    PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;Integer&gt;(k);
    for (int i = 0; i &lt; k; i++){
        heap.add(nums[i]);
    }
    for (int i = k; i &lt; len; i++){
        if (nums[i] &gt; heap.peek()){
            heap.poll();
            heap.add(nums[i]);
        }
    }
    return heap.peek();
}
</code></pre><p>Quickselect:</p>
<pre><code>public int findKthLargest3(int[] nums, int k) {
    int len = nums.length;
    return quickselect(nums, 0, len-1, k);
}

private int quickselect(int[] nums, int left, int right, int k){
    int pivotIndex = partition(nums, left, right, left);
    if (pivotIndex == k-1){
        return nums[pivotIndex];
    }
    else if(pivotIndex &lt; k){
        return quickselect(nums, pivotIndex+1, right, k);
    }
    else{
        return quickselect(nums, left, pivotIndex-1, k);
    }
}

private int partition(int[] nums, int left, int right, int index){
    int pivotvalue = nums[index];
    int storeindex = left;
    nums[index] = nums[right];
    for (int i = left; i &lt; right; i++){
        if (nums[i] &gt; pivotvalue){
            int temp = nums[i];
            nums[i] = nums[storeindex];
            nums[storeindex++] = temp;
        }
    }
    nums[right] = nums[storeindex];
    nums[storeindex] = pivotvalue;
    return storeindex;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorte]]>
    </summary>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
      <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Permutations II(Java)]]></title>
    <link href="http://yoursite.com/2016/01/31/Leetcode-Permutations-II-Java/"/>
    <id>http://yoursite.com/2016/01/31/Leetcode-Permutations-II-Java/</id>
    <published>2016-02-01T01:10:24.000Z</published>
    <updated>2016-02-01T01:26:48.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p>For example,<br>[1,1,2] have the following unique permutations:<br>[1,1,2], [1,2,1], and [2,1,1].</p>
<p><strong>Thinking:</strong></p>
<p>It’s very similiar with the question permutation, we should use backtracing to go through all the possibilities. For example, we pick the first element of the array, and get the permutation of the rest of this array, and put the first element in every possible position. The only difference bewteen the permutation is that we don’t allow duplicate. We can use hashset to solve this problem.</p>
<p>By the way, I made a mistake this time which I used to make. It’s that in the loop of this:</p>
<pre><code>for (List&lt;Integer&gt; list: backtracing(nums, index+1)){
    for (int i = 0; i &lt;= list.size(); i++){
        List&lt;Integer&gt; tempres = new ArrayList&lt;Integer&gt;(list);
        tempres.add(i, nums[index]);
        tres.add(tempres);
    }
}
</code></pre><p>I shouldn’t use the temporary variable list to operate, because<br>1) the size of it will change;<br>2) we should use it several times instead of once.<br>Then that means we should build another temporary variable. In this case, it’s tempres.</p>
<p><strong>Solution:</strong></p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {
    return backtracing(nums, 0);
}

private List&lt;List&lt;Integer&gt;&gt; backtracing(int[] nums, int index) {
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    HashSet&lt;List&lt;Integer&gt;&gt; tres = new HashSet&lt;List&lt;Integer&gt;&gt;();
    int len = nums.length;

    if (index &gt;= len){
        return res;
    }

    if (index == len - 1){
        List&lt;Integer&gt; tempres = new ArrayList&lt;Integer&gt;();
        tempres.add(nums[index]);
        res.add(tempres);
        return res;
    }

    for (List&lt;Integer&gt; list: backtracing(nums, index+1)){
        for (int i = 0; i &lt;= list.size(); i++){
            List&lt;Integer&gt; tempres = new ArrayList&lt;Integer&gt;(list);
            tempres.add(i, nums[index]);
            tres.add(tempres);
        }
    }

    res.addAll(tres);
    return res;
}
</code></pre><p>There is another solution is much faster than me. Because it use extra space to record which element is used and use sort to reduce the extra cost to make sure unique. What’s more, the process of adding first and removing after dfs is usually used by people. I suppose I should learn from it.</p>
<p>Code:</p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    if(nums==null || nums.length==0) return res;
    boolean[] used = new boolean[nums.length];
    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
    Arrays.sort(nums);
    dfs(nums, used, list, res);
    return res;
}

public void dfs(int[] nums, boolean[] used, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; res){
    if(list.size()==nums.length){
        res.add(new ArrayList&lt;Integer&gt;(list));
        return;
    }
    for(int i=0;i&lt;nums.length;i++){
        if(used[i]) continue;
        if(i&gt;0 &amp;&amp;nums[i-1]==nums[i] &amp;&amp; !used[i-1]) continue;
        used[i]=true;
        list.add(nums[i]);
        dfs(nums,used,list,res);
        used[i]=false;
        list.remove(list.size()-1);
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</]]>
    </summary>
    
      <category term="Backtracing" scheme="http://yoursite.com/tags/Backtracing/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Algorithm Note]]></title>
    <link href="http://yoursite.com/2016/01/31/Algorithm-Note/"/>
    <id>http://yoursite.com/2016/01/31/Algorithm-Note/</id>
    <published>2016-02-01T00:21:38.000Z</published>
    <updated>2016-02-01T07:10:43.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li>Chapter 3 Exercises 6中有两个点， 一个是如果一个图的DFS树中没有出现的边，边的两个顶点一定是祖先与孩子的关系；一个是如果一个图的BFS树的BFS树中没有出现的边，边的两个顶点在BFS树中的层数差不会大于1.</li>
<li>如果一个图的DFS树，或者BFS树和图相同，那么原图就没有环，否则就找他们最低的祖先，构成一个环。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<ol>
<li>Chapter 3 Exercises 6中有两个点， 一个是如果一个图的DFS树中没有出现的边，边的两个顶点一定是祖先与孩子的关系；一个是如果一个图的BFS树的BFS树中没有出现的边，边的两个顶点在BFS树中的层数差不会大于1.</li>
<li>如果一个图的]]>
    </summary>
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[VIM]]></title>
    <link href="http://yoursite.com/2016/01/30/VIM/"/>
    <id>http://yoursite.com/2016/01/30/VIM/</id>
    <published>2016-01-31T06:54:24.000Z</published>
    <updated>2016-01-31T07:05:27.000Z</updated>
    <content type="html"><![CDATA[<p>一、打开文件、保存、关闭文件(vi命令模式下使用)<br>:w       //保存文件<br>:w vpser.net //保存至vpser.net文件<br>:q          //退出编辑器，如果文件已修改请使用下面的命令<br>:q!        //退出编辑器，且不保存<br>:wq         //退出编辑器，且保存文件</p>
<p>二、插入文本或行(vi命令模式下使用，执行下面命令后将进入插入模式，按ESC键可退出插入模式)<br>一般使用i<br>a      //在当前光标位置的右边添加文本<br>i       //在当前光标位置的左边添加文本<br>A     //在当前行的末尾位置添加文本<br>I      //在当前行的开始处添加文本(非空字符的行首)<br>O     //在当前行的上面新建一行<br>o     //在当前行的下面新建一行<br>R    //替换(覆盖)当前光标位置及后面的若干文本<br>J    //合并光标所在行及下一行为一行(依然在命令模式)</p>
<p>三、移动光标(vi命令模式下使用)<br>1、使用上下左右方向键</p>
<p>2、命令模式下：h   向左、j   向下 、k   向上、l  向右。<br>空格键 向右、Backspace  向左、Enter  移动到下一行首、-  移动到上一行首。</p>
<p>四、删除、恢复字符或行(vi命令模式下使用)<br>x         //删除当前字符<br>nx         //删除从光标开始的n个字符<br>dd      //删除当前行<br>ndd   //向下删除当前行在内的n行<br>u       //撤销上一步操作<br>U      //撤销对当前行的所有操作</p>
<p>五、搜索(vi命令模式下使用)<br>/vpser     //向光标下搜索vpser字符串，vpser可以是正则表达式<br>?vpser     //向光标上搜索vpser字符串<br>n           //向下搜索前一个搜素动作<br>N         //向上搜索前一个搜索动作</p>
<p>*(#)      //当光标停留在某个单词上时, 输入这条命令表示查找与该单词匹配的下(上)一个单词. 同样, 再输入 n 查找下一个匹配处, 输入 N 反方向查找.</p>
<p>g*(g#)        //此命令与上条命令相似, 只不过它不完全匹配光标所在处的单词, 而是匹配包含该单词的所有字符串.</p>
<p>六、跳至指定行(vi命令模式下使用)<br>n+        //向下跳n行<br>n-         //向上跳n行<br>nG        //跳到行号为n的行<br>G           //跳至文件的底部</p>
<p>七、设置行号(vi命令模式下使用)<br>:set  nu     //显示行号<br>:set nonu    //取消显示行号</p>
<p>八、复制、粘贴(vi命令模式下使用)<br>yy    //将当前行复制到缓存区，也可以用 “ayy 复制，”a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务。<br>nyy   //将当前行向下n行复制到缓冲区，也可以用 “anyy 复制，”a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务。<br>yw    //复制从光标开始到词尾的字符。<br>nyw   //复制从光标开始的n个单词。<br>y^      //复制从光标到行首的内容。  VPS侦探<br>y$      //复制从光标到行尾的内容。<br>p        //粘贴剪切板里的内容在光标后，如果使用了前面的自定义缓冲区，建议使用”ap 进行粘贴。<br>P        //粘贴剪切板里的内容在光标前，如果使用了前面的自定义缓冲区，建议使用”aP 进行粘贴。</p>
<p>九、替换(vi命令模式下使用)<br>:s/old/new      //用new替换行中首次出现的old<br>:s/old/new/g         //用new替换行中所有的old<br>:n,m s/old/new/g     //用new替换从n到m行里所有的old<br>:%s/old/new/g      //用new替换当前文件里所有的old</p>
<p>十、编辑其他文件<br>:e otherfilename    //编辑文件名为otherfilename的文件。</p>
<p>十一、修改文件格式<br>:set fileformat=unix   //将文件修改为unix格式，如win下面的文本文件在linux下会出现^M。</p>
<p>十二、查找帮助<br>当你不知道怎么处理时，直接输入help可以看到帮助文档的起点，ZZ是退出或者：q，不建议使用<br>查找关于某个字母的命令 ：help x   查找关于x的命令。</p>
<p>参考：<a href="http://blog.csdn.net/chenxiaochen32/article/details/7378127" target="_blank" rel="external">http://blog.csdn.net/chenxiaochen32/article/details/7378127</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一、打开文件、保存、关闭文件(vi命令模式下使用)<br>:w       //保存文件<br>:w vpser.net //保存至vpser.net文件<br>:q          //退出编辑器，如果文件已修改请使用下面的命令<br>:q!        //退出编辑]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Palindrome Partitioning(Java)]]></title>
    <link href="http://yoursite.com/2016/01/30/Leetcode-Palindrome-Partitioning-Java/"/>
    <id>http://yoursite.com/2016/01/30/Leetcode-Palindrome-Partitioning-Java/</id>
    <published>2016-01-31T06:25:26.000Z</published>
    <updated>2016-01-31T06:51:07.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return all possible palindrome partitioning of s.</p>
<p>For example, given s = “aab”,<br>Return</p>
<pre><code>[
  [&quot;aa&quot;,&quot;b&quot;],
  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]
]
</code></pre><p><strong>Thinking:</strong></p>
<p>We should get all the possible partition, it’s obvious we should use backtracing. We partition the string from beginning, and check if it’s palindrome, then check the rest of the substring. If all the substrings are palindrome, we put them in the result. We have to notice the API of Java substring(beginIndex, endIndex) that beginIndex is inclusive but endIndex is exclusive.</p>
<p><strong>Solution:</strong></p>
<pre><code>public List&lt;List&lt;String&gt;&gt; partition(String s) {
    List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;List&lt;String&gt;&gt;();
    int len = s.length();
    if (palindrome(s)){
        List&lt;String&gt; tempres = new ArrayList&lt;String&gt;();
        tempres.add(s);
        res.add(tempres);
    }
    for (int i = 1; i &lt; len; i++){
        if (palindrome(s.substring(0, i))){
            for (List&lt;String&gt; list: partition(s.substring(i))){
                list.add(0, s.substring(0, i));
                res.add(list);
            }
        }
    }
    return res;
}

private boolean palindrome(String s){
    int len = s.length();
    int left = 0;
    int right = len - 1;
    while (left &lt; right){
        if (s.charAt(left) != s.charAt(right)){
            return false;
        }
        left++;
        right--;
    }
    return true;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return]]>
    </summary>
    
      <category term="Backtracing" scheme="http://yoursite.com/tags/Backtracing/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Binary Tree Zigzag Level Order Traversal(Java)]]></title>
    <link href="http://yoursite.com/2016/01/30/Leetcode-Binary-Tree-Zigzag-Level-Order-Traversal-Java/"/>
    <id>http://yoursite.com/2016/01/30/Leetcode-Binary-Tree-Zigzag-Level-Order-Traversal-Java/</id>
    <published>2016-01-31T05:21:37.000Z</published>
    <updated>2016-01-31T05:29:07.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree {3,9,20,#,#,15,7},</p>
<pre><code>  3
 / \
9  20
  /  \
 15   7
</code></pre><p>return its zigzag level order traversal as:</p>
<pre><code>[
  [3],
  [20,9],
  [15,7]
]
</code></pre><p><strong>Thinking:</strong></p>
<p>It’s a BFS problem. It’s fine if we need use queue, but because we have to record as a zigzag order, it’s more efficient to use stack. What’s more, we should to notice the order of left and right child.</p>
<p><strong>Solution:</strong></p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) {
    int flag = 0;
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();
    Stack&lt;TreeNode&gt; tempstack = new Stack&lt;TreeNode&gt;();
    if (root == null)
        return res;
    stack.add(root);
    while (!stack.isEmpty() || !tempstack.isEmpty()){
        tempstack = new Stack&lt;TreeNode&gt;();
        List&lt;Integer&gt; tempres = new ArrayList&lt;Integer&gt;();
        while (!stack.isEmpty()){
            TreeNode node = stack.pop();
            tempres.add(node.val);
            if (flag == 0){
                if (node.left != null){
                    tempstack.add(node.left);
                }
                if (node.right != null){
                    tempstack.add(node.right);
                }
            }
            else{
                if (node.right != null){
                    tempstack.add(node.right);
                }
                if (node.left != null){
                    tempstack.add(node.left);
                }
            }

        }
        res.add(tempres);
        stack.addAll(tempstack);
        flag ^= 1;
    }

    return res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to ri]]>
    </summary>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-4Sum(Java)]]></title>
    <link href="http://yoursite.com/2016/01/30/Leetcode-4Sum-Java/"/>
    <id>http://yoursite.com/2016/01/30/Leetcode-4Sum-Java/</id>
    <published>2016-01-31T04:33:10.000Z</published>
    <updated>2016-01-31T04:42:45.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>
<p>Note:<br>Elements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d)<br>The solution set must not contain duplicate quadruplets.<br>    For example, given array S = {1 0 -1 0 -2 2}, and target = 0.</p>
<pre><code>A solution set is:
(-1,  0, 0, 1)
(-2, -1, 1, 2)
(-2,  0, 0, 2)
</code></pre><p><strong>Thinking</strong>:</p>
<p>This questions is very similar with 2Sum and 3Sum. There are several way to solve it. </p>
<p><strong>Solution1:</strong></p>
<p>The most common method may use the method of 3Sum, and do that n times.</p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; fourSum1(int[] nums, int target) {
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    Set&lt;List&lt;Integer&gt;&gt; tres = new HashSet&lt;List&lt;Integer&gt;&gt;();
    Arrays.sort(nums);
    int len = nums.length;


    for (int i = 0; i &lt; len-3; i++){
        for (int j = i+1; j &lt; len-2; j++){
            for (int k = j+1; k &lt; len-1; k++){
                int l = len-1;
                while (k &lt; l){
                    int sum = nums[i] + nums[j] + nums[k] + nums[l];
                    if (sum == target){
                        List&lt;Integer&gt; tempres = new ArrayList&lt;Integer&gt;();
                        tempres.add(nums[i]);
                        tempres.add(nums[j]);
                        tempres.add(nums[k]);
                        tempres.add(nums[l]);
                        tres.add(tempres);
                        k++;
                        l--;
                    }
                    else if (sum &gt; target){
                        l--;
                    }
                    else{
                        k++;
                    }
                    while (k &lt; l &amp;&amp; nums[k+1] == nums[k]){
                        k++;
                    }
                    while (k &lt; l &amp;&amp; nums[l-1] == nums[l]){
                        l--;
                    }
                }
            }
        }
    }

    res.addAll(tres);
    return res;
}
</code></pre><p><strong>Solution2:</strong></p>
<p>The second solution is to combine every two numbers as a pair, and make it as a 2sum problem. But for implementing this method, we have to define the data structure by ourself and implement the interface of Comparator to sort the sum of them.</p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; fourSum2(int[] nums, int target){
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    int len = nums.length;
    if (len &lt; 4)
        return res;
    Pair[] pairSum = new Pair[len*(len-1)/2];
    Set&lt;List&lt;Integer&gt;&gt; tres = new HashSet&lt;List&lt;Integer&gt;&gt;();

    int count = 0;
    for (int i = 0; i &lt; len-1; i++){
        for (int j = i+1; j &lt; len; j++){
            Pair ele = new Pair(nums[i], nums[j], i, j);
            pairSum[count++] = ele;
        }
    }
    Arrays.sort(pairSum, new SumComparator());

    int left = 0;
    int right = pairSum.length - 1;
    while (left &lt; right){
        int sum = pairSum[left].getSum() + pairSum[right].getSum();
        if (sum == target){
            int endl = left;
            int endr = right;
            while (pairSum[endl].getSum() == pairSum[endl+1].getSum() &amp;&amp; endl+1 &lt; endr){
                endl++;
            }
            while (pairSum[endr].getSum() == pairSum[endr-1].getSum() &amp;&amp; endl &lt; endr-1){
                endr--;
            }
            for (int i = left; i &lt;= endl; i++){
                for (int j = right; j&gt;= endr; j--){
                    int i1 = pairSum[i].geti();
                    int i2 = pairSum[j].geti();
                    int j1 = pairSum[i].getj();
                    int j2 = pairSum[j].getj();
                    if (i1 == i2 || i1 == j2 || j1 == i2 || j1 == j2){
                        continue;
                    }
                    int[] temp = new int[4];
                    temp[0] = pairSum[i].getN1();
                    temp[1] = pairSum[i].getN2();
                    temp[2] = pairSum[j].getN1();
                    temp[3] = pairSum[j].getN2();
                    Arrays.sort(temp);
                    List&lt;Integer&gt; tempres = new ArrayList&lt;Integer&gt;();
                    tempres.add(temp[0]);
                    tempres.add(temp[1]);
                    tempres.add(temp[2]);
                    tempres.add(temp[3]);
                    tres.add(tempres);
                }
            }
            left = endl+1;
            right = endr-1;
        }
        else if (sum &gt; target){
            right--;
        }
        else{
            left++;
        }
    }

    res.addAll(tres);
    return res;
}

class SumComparator implements Comparator{

    @Override
    public final int compare(Object o1, Object o2) {
        // TODO Auto-generated method stub
        Pair l1 = (Pair)o1;
        Pair l2 = (Pair)o2;
        if (l1.getSum() &gt; l2.getSum())
            return 1;
        else if (l1.getSum() &lt; l2.getSum())
            return -1;
        else
            return 0;
    }
}

class Pair{
    int i;
    int j;
    int n1;
    int n2;
    int sum;
    Pair(int num1, int num2, int i, int j){
        this.n1 = num1;
        this.n2 = num2;
        this.sum = num1 + num2;
        this.i = i;
        this.j = j;
    }
    public int getSum(){
        return this.sum;
    }
    public int getN1(){
        return this.n1;
    }
    public int getN2(){
        return this.n2;
    }
    public int geti(){
        return this.i;
    }
    public int getj(){
        return this.j;
    }
}
</code></pre><p>Reference: <a href="http://blog.csdn.net/linhuanmars/article/details/24826871" target="_blank" rel="external">http://blog.csdn.net/linhuanmars/article/details/24826871</a></p>
<p><strong>Solution3:</strong></p>
<p>The third method is the most efficient method. It has two loop of two points and use some method to break or return early. It really improve the performance of time running.</p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; fourSum3(int[] nums, int target) {
    List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    Arrays.sort(nums);
    int second = 0, third = 0, nexti = 0, nextj = 0;
    for(int i=0, L=nums.length; i&lt;L-3; i++) {
        if(nums[i]&lt;&lt;2 &gt; target) return list; // return immediately
        for(int j=L-1; j&gt;i+2; j--) {
            if(nums[j]&lt;&lt;2 &lt; target) break; // break immediately
            int rem = target-nums[i]-nums[j];
            int lo = i+1, hi=j-1;
            while(lo&lt;hi) {
                int sum = nums[lo] + nums[hi];
                if(sum&gt;rem) --hi;
                else if(sum&lt;rem) ++lo;
                else {
                    list.add(Arrays.asList(nums[i],nums[lo],nums[hi],nums[j]));
                    while(++lo&lt;=hi &amp;&amp; nums[lo-1]==nums[lo]) continue; // avoid duplicate results
                    while(--hi&gt;=lo &amp;&amp; nums[hi]==nums[hi+1]) continue; // avoid duplicate results
                }
            }
            while(j&gt;=1 &amp;&amp; nums[j]==nums[j-1]) --j; // skip inner loop
        }
        while(i&lt;L-1 &amp;&amp; nums[i]==nums[i+1]) ++i; // skip outer loop
    }
    return list;
}
</code></pre><p>Reference: <a href="https://leetcode.com/discuss/78276/java-little-bit-faster-than-other-common-methods-9ms-beats-95%25" target="_blank" rel="external">https://leetcode.com/discuss/78276/java-little-bit-faster-than-other-common-methods-9ms-beats-95%25</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Two Points" scheme="http://yoursite.com/tags/Two-Points/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-3Sum(Java)]]></title>
    <link href="http://yoursite.com/2016/01/28/Leetcode-3Sum-Java/"/>
    <id>http://yoursite.com/2016/01/28/Leetcode-3Sum-Java/</id>
    <published>2016-01-29T00:28:55.000Z</published>
    <updated>2016-01-29T00:32:01.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p>Note:<br>Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)<br>The solution set must not contain duplicate triplets.<br>    For example, given array S = {-1 0 1 2 -1 -4},</p>
<pre><code>A solution set is:
(-1, 0, 1)
(-1, -1, 2)
</code></pre><p><strong>Thinking:</strong></p>
<p>Sort the array first. Pick a number from the array, and use other two points to record the position of the array and determine which one should change by the sum of them. What’s more, the result set should has no duplicate, so we can use hashset here.</p>
<p><strong>Solution:</strong></p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
    int l = nums.length;
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    Set&lt;List&lt;Integer&gt;&gt; tres = new HashSet&lt;List&lt;Integer&gt;&gt;();

    if (l &lt; 3)
        return res;

    Arrays.sort(nums);

    for (int i = 0; i &lt; l-2; i++){
        int k = l-1;
        for (int j = i+1; j &lt; l; j++){
            while (j &lt; k){
                int sum = nums[i] + nums[j] + nums[k];
                if (sum == 0){
                    List&lt;Integer&gt; tempres = new ArrayList&lt;Integer&gt;();
                    tempres.add(nums[i]);
                    tempres.add(nums[j]);
                    tempres.add(nums[k]);
                    tres.add(tempres);
                    while (j &lt; k &amp;&amp; nums[j] == tempres.get(1)){
                        j++;
                    }
                    k--;
                }
                else if (sum &gt; 0){
                    k--;
                }
                else{
                    j++;
                }

            }
        }
    }
    res.addAll(tres);

    return res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all uniqu]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Two Points" scheme="http://yoursite.com/tags/Two-Points/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Two Sum(Java)]]></title>
    <link href="http://yoursite.com/2016/01/28/Leetcode-Two-Sum-Java/"/>
    <id>http://yoursite.com/2016/01/28/Leetcode-Two-Sum-Java/</id>
    <published>2016-01-28T22:55:39.000Z</published>
    <updated>2016-01-28T22:58:03.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>
<p>You may assume that each input would have exactly one solution.</p>
<p>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p>
<p><strong>Thinking:</strong></p>
<p>We can use hash map to store the rest of nums[i], and if we find which number is equal to the rest beofore, their sum will be target.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int[] twoSum(int[] nums, int target){
    HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
    int[] res = new int[2];

    for (int i = 0; i &lt; nums.length; i++){
        if (map.containsKey(nums[i])){
            res[0] = map.get(nums[i]) + 1;
            res[1] = i+1;
            break;
        }
        else{
            map.put(target-nums[i], i);
        }
    }

    return res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>
<p>]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Game of Life(Java)]]></title>
    <link href="http://yoursite.com/2016/01/28/Leetcode-Game-of-Life-Java/"/>
    <id>http://yoursite.com/2016/01/28/Leetcode-Game-of-Life-Java/</id>
    <published>2016-01-28T22:17:33.000Z</published>
    <updated>2016-01-28T22:36:18.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>According to the Wikipedia’s article: “The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.”</p>
<p>Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</p>
<p>Any live cell with fewer than two live neighbors dies, as if caused by under-population.<br>Any live cell with two or three live neighbors lives on to the next generation.<br>Any live cell with more than three live neighbors dies, as if by over-population..<br>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.<br>Write a function to compute the next state (after one update) of the board given its current state.</p>
<p>Follow up:<br>Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.<br>In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?</p>
<p><strong>Thinkings:</strong></p>
<p>It’s difficult quesiont, isn’t it? We have to fully understand when cell become live or dead and try to replace them in place. One solution is to present their status using bits, the first bit represents their current status and second bit represents their next status. For example:</p>
<p>current status is live and next status will be dead is 01<br>current status is dead and next status will be live is 10</p>
<p>And then we can get the current status by:</p>
<pre><code>board[i][j] &amp; 1
</code></pre><p>Get the finnaly status by:</p>
<pre><code>board[i][j] &gt;&gt;= 1
</code></pre><p><strong>Solution:</strong></p>
<pre><code>public void gameOfLife(int[][] board) {
    int m = board.length;
    if (m == 0)
        return;
    int n = board[0].length;

    //int[][] temp = new int[m][n];


    for (int i = 0; i &lt; m; i++){
        for (int j = 0; j &lt; n; j++){
            int count = 0;
            for (int p = -1; p &lt; 2; p++)
                for (int q = -1; q &lt; 2; q++){
                    if (i+p&gt;=0 &amp;&amp; i+p&lt;m &amp;&amp; j+q&gt;=0 &amp;&amp; j+q&lt;n &amp;&amp; !(p==0 &amp;&amp; q==0)){
                        if ((board[i+p][j+q] &amp; 1) == 1)
                            count++;
                    }
                }

            if ((board[i][j] &amp; 1) == 0 &amp;&amp; count == 3){
                //temp[i][j] = 1;
                board[i][j] = 2;
            }
            else if ((board[i][j] &amp; 1) == 1 &amp;&amp; count &lt;=3 &amp;&amp; count &gt;= 2){
                    board[i][j] = 3;

            }
        }
    }

    for (int i = 0; i &lt; m; i++){
        for (int j = 0; j &lt; n; j++){
            //board[i][j] = temp[i][j];
            board[i][j] &gt;&gt;= 1;
        }
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>According to the Wikipedia’s article: “The Game of Life, also known simply as Life, is a cellular autom]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Letter Combinations of a Phone Number(Java)]]></title>
    <link href="http://yoursite.com/2016/01/27/Leetcode-Letter-Combinations-of-a-Phone-Number-Java/"/>
    <id>http://yoursite.com/2016/01/27/Leetcode-Letter-Combinations-of-a-Phone-Number-Java/</id>
    <published>2016-01-28T00:11:34.000Z</published>
    <updated>2016-01-28T00:21:10.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a digit string, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below.</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt=""></p>
<pre><code>Input:Digit string &quot;23&quot;
Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].
</code></pre><p>Note:<br>Although the above answer is in lexicographical order, your answer could be in any order you want.</p>
<p><strong>Thinking:</strong></p>
<p>We should get all the possiblities of the comibination so we need use backtracing.</p>
<p><strong>Solution:</strong></p>
<pre><code>import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

public class Solution {
    static private Map&lt;Character, char[]&gt; hmap = new HashMap&lt;Character, char[]&gt;();

    private Character two = new Character(&apos;2&apos;);
    private char[] twoC = {&apos;a&apos;, &apos;b&apos;, &apos;c&apos;};
    private Character three = new Character(&apos;3&apos;);
    private char[] threeC = {&apos;d&apos;, &apos;e&apos;, &apos;f&apos;};
    private Character four = new Character(&apos;4&apos;);
    private char[] fourC = {&apos;g&apos;, &apos;h&apos;, &apos;i&apos;};
    private Character five = new Character(&apos;5&apos;);
    private char[] fiveC = {&apos;j&apos;, &apos;k&apos;, &apos;l&apos;};
    private Character six = new Character(&apos;6&apos;);
    private char[] sixC = {&apos;m&apos;, &apos;n&apos;, &apos;o&apos;};
    private Character seven = new Character(&apos;7&apos;);
    private char[] sevenC = {&apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;};
    private Character eight = new Character(&apos;8&apos;);
    private char[] eightC = {&apos;t&apos;, &apos;u&apos;, &apos;v&apos;};
    private Character nine = new Character(&apos;9&apos;);
    private char[] nineC = {&apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;};

    public Solution(){
        hmap.put(two, twoC);
        hmap.put(three, threeC);
        hmap.put(four, fourC);
        hmap.put(five, fiveC);
        hmap.put(six, sixC);
        hmap.put(seven, sevenC);
        hmap.put(eight, eightC);
        hmap.put(nine, nineC);
    }

    public List&lt;String&gt; letterCombinations(String digits) {
        List&lt;String&gt; res = new ArrayList&lt;String&gt;();

        backTracing(digits, 0, &quot;&quot;, res);

        return res;
    }

    private void backTracing(String digits, int index, String cur, List&lt;String&gt; res){
        int l = digits.length();
        if (l == 0)
            return;
        if (index == l){
            res.add(cur);
            return;
        }


        Character tmpc = new Character(digits.charAt(index));
        if(hmap.containsKey(tmpc)){
            for (char c :hmap.get(tmpc)){
                backTracing(digits, index+1, cur+c, res);
            }
        }

    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a digit string, return all possible letter combinations that the number could represent.</p>
<p>A]]>
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Path Sum II(Java)]]></title>
    <link href="http://yoursite.com/2016/01/27/Leetcode-Path-Sum-II-Java/"/>
    <id>http://yoursite.com/2016/01/27/Leetcode-Path-Sum-II-Java/</id>
    <published>2016-01-27T22:11:58.000Z</published>
    <updated>2016-01-27T23:05:21.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p>
<p>For example:<br>Given the below binary tree and sum = 22,</p>
<pre><code>      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1
</code></pre><p>return</p>
<pre><code>[
      [5,4,11,2],
       [5,8,4,5]
]
</code></pre><p><strong>Thinking:</strong></p>
<p>We should use classic dfs method to solve this problem and record all the results.</p>
<p><strong>Solution:</strong></p>
<p>But my first version of solution is time limit exceeded:</p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) {
    List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();

    return dp(root, sum, res);
}

private List&lt;List&lt;Integer&gt;&gt; dp(TreeNode root, int sum, List&lt;Integer&gt; cur){
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    if (root == null)
        return null;
    if (root.left == null &amp;&amp; root.right == null){
        if (root.val == sum){
            cur.add(root.val);
            res.add(cur);
            return res;
        }
        else{
            return res;
        }
    }
    for (List&lt;Integer&gt; ele: dp(root.left, sum-root.val, cur)){
        if (ele != null){
            ele.add(0, root.val);
            res.add(ele);
        }
    }
    for (List&lt;Integer&gt; ele: dp(root.right, sum-root.val, cur)){
        if (ele != null){
            ele.add(0, root.val);
            res.add(ele);
        }
    }

    return res;
}
</code></pre><p>Then I have to improve the effiency of this algorithm, and the code is below:</p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) {
    List&lt;Integer&gt; cur = new ArrayList&lt;Integer&gt;();
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();

    dp(root, sum, cur, res);

    return res;
}

private void dp(TreeNode root, int sum, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; res){
    if (root == null)
        return;
    //preorder dfs

    sum -= root.val;
    if (root.left == null &amp;&amp; root.right == null){
        if (sum == 0){
            cur.add(root.val);
            List&lt;Integer&gt; tempres = new ArrayList&lt;Integer&gt;();
            tempres.addAll(cur);
            res.add(tempres);
            cur.remove(cur.size() - 1);
        }
        return;
    }
    cur.add(root.val);
    if (root.left != null){
        dp(root.left, sum, cur, res);
    }
    if (root.right != null){
        dp(root.right, sum, cur, res);
    }
    cur.remove(cur.size() - 1);
}
</code></pre><p>It’s very importatn to create a new List while put the current list data to final result, becuase if not we will only copy the address of this variable cur. Then it will be incorrect if we revise cur.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.<]]>
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://yoursite.com/2016/01/27/hello-world/"/>
    <id>http://yoursite.com/2016/01/27/hello-world/</id>
    <published>2016-01-27T22:00:19.000Z</published>
    <updated>2016-01-27T22:00:19.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start"><a href="#Quick_Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create_a_new_post"><a href="#Create_a_new_post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server"><a href="#Run_server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files"><a href="#Generate_static_files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites"><a href="#Deploy_to_remote_sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.]]>
    </summary>
    
      <category term="uncategoried" scheme="http://yoursite.com/categories/uncategoried/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Flatten Binary Tree to Linked List(Java)]]></title>
    <link href="http://yoursite.com/2016/01/27/leetcode-flatten-binary-tree-to-linked-list/"/>
    <id>http://yoursite.com/2016/01/27/leetcode-flatten-binary-tree-to-linked-list/</id>
    <published>2016-01-27T22:00:06.000Z</published>
    <updated>2016-01-27T22:00:06.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<pre><code>    1
   / \
  2   5
 / \   \
3   4   6
</code></pre><p>The flattened tree should look like:</p>
<pre><code>1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
</code></pre><p>Hint:<br>If you notice carefully in the flattened tree, each node’s right child points to the next node of a pre-order traversal.</p>
<p><strong>Thinking:</strong> </p>
<p>It’s a simple dfs question and it’s pre-order. So we need to make the left-child become right-child of root and make right-child become whole left-child’s right-child. </p>
<p><strong>Solution:</strong></p>
<pre><code>public class Solution {
    public void flatten(TreeNode root) {
        if (root == null)
            return;
        dfs(root);
    }

    public TreeNode dfs(TreeNode root){

        if (root.left == null &amp;&amp; root.right == null){
            return root;
        }

        TreeNode left = null;
        TreeNode right = null;
        TreeNode preleft = root.left;
        TreeNode preright = root.right;
        if (preleft == null){
            return dfs(preright);
        }
        else if(preright == null){
            root.left = null;
            root.right = preleft;
            return dfs(preleft);
        }
        else{
            left = dfs(preleft);
            right = dfs(preright);
            root.left = null;
            root.right = preleft;
            left.right = preright;
            return right;
        }
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<pre><code>]]>
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Triangle(Java)]]></title>
    <link href="http://yoursite.com/2016/01/27/Leetcode-Triangle/"/>
    <id>http://yoursite.com/2016/01/27/Leetcode-Triangle/</id>
    <published>2016-01-27T21:58:25.000Z</published>
    <updated>2016-01-27T21:58:25.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>
<p>For example, given the following triangle:</p>
<pre><code>[
       [2],
     [3,4],
    [6,5,7],
   [4,1,8,3]
]
</code></pre><p>The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</p>
<p>Note:<br>Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</p>
<p><strong>Thinking:</strong><br>It’s a simple dynamic programming question. The expression is dp[i][j] = min(d[i-1][j-1], d[i][j]) + triangle[i][j].</p>
<p>But the first time, my code is time exceed:</p>
<pre><code>public class Solution {
    public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) {
        int lr = triangle.size();
        if(lr == 0){
            return 0;
        }
        int lc = triangle.get(lr-1).size();
        int min = 100000;
        for(int i = 0; i &lt; lc; i++){
            int tmp = dp(triangle, lr-1, i);
            if(tmp &lt; min)
                min = tmp;
        }
        return min;
    }

    public int dp(List&lt;List&lt;Integer&gt;&gt; triangle, int row, int column){
        if(row == 0){
            return triangle.get(0).get(0);
        }
        int value = triangle.get(row).get(column);
        int size = triangle.get(row-1).size();
        if(column &gt;= size){
            return dp(triangle, row-1, column-1) + value;
        }
        else if(column - 1 &lt; 0){
            return dp(triangle, row-1, column) + value;
        }
        else{
            int res1 = dp(triangle, row-1, column-1) + value;
            int res2 = dp(triangle, row-1, column) + value;
            if(res1 &lt; res2){
                return res1;
            }
            else{
                return res2;
            }
        }
    }
}
</code></pre><p>Then I noticed the bonus, so I change my mind to use <em>iteration</em>:</p>
<pre><code>public class Solution{
    public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle){
        int lr = triangle.size();
        int[] min = new int[lr];
        int[] tempmin = new int[lr];
        min[0] = triangle.get(0).get(0);
        for(int i = 1; i &lt; lr; i++){
            tempmin[0] = min[0] + triangle.get(i).get(0);
            tempmin[i] = min[i-1] + triangle.get(i).get(i);
            for(int j = 1; j &lt; i; j++){
                int res1 = min[j-1] + triangle.get(i).get(j);
                int res2 = min[j] + triangle.get(i).get(j);
                if(res1 &lt; res2)
                    tempmin[j] = res1;
                else
                    tempmin[j] = res2;
            }
            for(int k = 0; k &lt; i+1; k++){
                min[k] = tempmin[k];
            }
        }
        int m = 100000;
        for(int i = 0; i &lt; lr; i++){
            if(min[i] &lt; m)
                m = min[i];
        }
        return m;
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numb]]>
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
</feed>
