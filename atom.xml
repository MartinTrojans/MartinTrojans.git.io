<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Martin's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-03-09T03:48:45.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Martin]]></name>
    <email><![CDATA[martinglory1992@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[The Zen of Python]]></title>
    <link href="http://yoursite.com/2016/03/08/The-Zen-of-Python/"/>
    <id>http://yoursite.com/2016/03/08/The-Zen-of-Python/</id>
    <published>2016-03-09T03:46:49.000Z</published>
    <updated>2016-03-09T03:48:45.000Z</updated>
    <content type="html"><![CDATA[<p><strong>The Zen of Python:</strong></p>
<p>Beautiful is better than ugly.</p>
<p>Explicit is better than implicit.</p>
<p>Simple is better than complex.</p>
<p>Complex is better than complicated.</p>
<p>Flat is better than nested.</p>
<p>Sparse is better than dense.</p>
<p>Readability counts.</p>
<p>Special cases aren’t special enough to break the rules.</p>
<p>Although practicality beats purity.</p>
<p>Errors should never pass silently.</p>
<p>Unless explicitly silenced.</p>
<p>In the face of ambiguity, refuse the temptation to guess.</p>
<p>There should be one– and preferably only one –obvious way to do it.</p>
<p>Although that way may not be obvious at first unless you’re Dutch.</p>
<p>Now is better than never.</p>
<p>Although never is often better than <em>right</em> now.</p>
<p>If the implementation is hard to explain, it’s a bad idea.</p>
<p>If the implementation is easy to explain, it may be a good idea.</p>
<p>Namespaces are one honking great idea – let’s do more of those!</p>
<p>(Reference: <a href="https://www.python.org/dev/peps/pep-0020/" target="_blank" rel="external">https://www.python.org/dev/peps/pep-0020/</a>)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>The Zen of Python:</strong></p>
<p>Beautiful is better than ugly.</p>
<p>Explicit is better than implicit.</p>
<p>Simple is bette]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Reconstruct Itinerary(Java)]]></title>
    <link href="http://yoursite.com/2016/03/08/Leetcode-Reconstruct-Itinerary-Java/"/>
    <id>http://yoursite.com/2016/03/08/Leetcode-Reconstruct-Itinerary-Java/</id>
    <published>2016-03-08T23:43:32.000Z</published>
    <updated>2016-03-09T00:27:35.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.</p>
<p>Note:<br>If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary </p>
<p> 1.[“JFK”, “LGA”] has a smaller lexical order than [“JFK”, “LGB”].</p>
<p> 2.All airports are represented by three capital letters (IATA code).</p>
<p> 3.You may assume all tickets form at least one valid itinerary.</p>
<p>Example 1:</p>
<pre><code>tickets = [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]
</code></pre><p>Return </p>
<pre><code>[&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;].
</code></pre><p>Example 2:</p>
<pre><code>tickets = [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]
</code></pre><p>Return </p>
<pre><code>[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;].
</code></pre><p>Another possible reconstruction is [“JFK”,”SFO”,”ATL”,”JFK”,”ATL”,”SFO”]. But it is larger in lexical order.</p>
<p><strong>Thinking:</strong></p>
<p>We need to use dfs to travse all the graph and record the graph. But we need to record it in order. So it should be stored in PriorityQueue and store the route while visiting. If it’s stuck we back up but also record the previous information, because we know there are other ways to get there. Until all the edges are visited once, it’s finished.</p>
<p><strong>Solution:</strong></p>
<pre><code>List&lt;String&gt; res = new ArrayList&lt;String&gt;();
HashMap&lt;String, PriorityQueue&lt;String&gt;&gt; map = new HashMap&lt;String, PriorityQueue&lt;String&gt;&gt;();

public List&lt;String&gt; findItinerary(String[][] tickets) {
    for (String[] ticket: tickets)
        map.computeIfAbsent(ticket[0], k -&gt; new PriorityQueue&lt;String&gt;()).add(ticket[1]);
    visit(&quot;JFK&quot;);

    return res;
}

private void visit(String cur) {
    while (map.containsKey(cur) &amp;&amp; !map.get(cur).isEmpty())
        visit(map.get(cur).poll());
    res.add(0, cur);
}
</code></pre><p>Reference: <a href="https://leetcode.com/discuss/84659/short-ruby-python-java-c" target="_blank" rel="external">https://leetcode.com/discuss/84659/short-ruby-python-java-c</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reco]]>
    </summary>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Graph" scheme="http://yoursite.com/tags/Graph/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Maximum Product Subarray(Java)]]></title>
    <link href="http://yoursite.com/2016/03/07/Leetcode-Maximum-Product-Subarray-Java/"/>
    <id>http://yoursite.com/2016/03/07/Leetcode-Maximum-Product-Subarray-Java/</id>
    <published>2016-03-08T04:39:50.000Z</published>
    <updated>2016-03-08T04:42:28.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>For example, given the array [2,3,-2,4],<br>the contiguous subarray [2,3] has the largest product = 6.</p>
<p><strong>Thinking:</strong></p>
<p>This problem is similiar with the MaxSubArray. One thing we need to notice is that we should maintian another variable which is the minimum value of the negative value. When it multiple the negtive value in the array, it maybe the maximum.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int maxProduct(int[] nums) {
    int l = nums.length;
    int max = nums[0];
    int maxhere = nums[0];
    int minhere = nums[0];

    for (int i = 1; i &lt; l; i++) {
        if (nums[i] &gt;= 0) {
            maxhere = Math.max(maxhere*nums[i], nums[i]);
            minhere = Math.min(minhere*nums[i], nums[i]);
        } else {
            int temp = maxhere;
            maxhere = Math.max(minhere*nums[i], nums[i]);
            minhere = Math.min(temp*nums[i], nums[i]);
        }
        max = Math.max(maxhere, max);
    }

    return max;
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest pro]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Evaluate Reverse Polish Notation(Java)]]></title>
    <link href="http://yoursite.com/2016/03/07/Leetcode-Evaluate-Reverse-Polish-Notation-Java/"/>
    <id>http://yoursite.com/2016/03/07/Leetcode-Evaluate-Reverse-Polish-Notation-Java/</id>
    <published>2016-03-08T00:22:28.000Z</published>
    <updated>2016-03-08T00:24:39.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p>
<p>Valid operators are +, -, *, /. Each operand may be an integer or another expression.</p>
<p>Some examples:</p>
<pre><code>[&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;] -&gt; ((2 + 1) * 3) -&gt; 9
[&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;] -&gt; (4 + (13 / 5)) -&gt; 6
</code></pre><p><strong>Thinking:</strong></p>
<p>We should use stack and scan the elements of this string array. Whenever we get the operator, we pop element from the stack and push new element to the stack.</p>
<p><strong>Solutioin:</strong></p>
<pre><code>public int evalRPN(String[] tokens) {
    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();

    for (String s: tokens) {
        if (s.equals(&quot;+&quot;)) {
            int num1 = stack.pop();
            int num2 = stack.pop();
            stack.push(num1+num2);
        }
        else if (s.equals(&quot;-&quot;)) {
            int num1 = stack.pop();
            int num2 = stack.pop();
            stack.push(num2-num1);
        }
        else if (s.equals(&quot;*&quot;)) {
            int num1 = stack.pop();
            int num2 = stack.pop();
            stack.push(num1*num2);
        }
        else if (s.equals(&quot;/&quot;)) {
            int num1 = stack.pop();
            int num2 = stack.pop();
            stack.push(num2/num1);
        }
        else
            stack.push(Integer.parseInt(s));
    }

    return stack.pop();
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p>
<p>Valid operators are +]]>
    </summary>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Increasing Triplet Subsequence(Java)]]></title>
    <link href="http://yoursite.com/2016/03/07/Leetcode-Increasing-Triplet-Subsequence-Java/"/>
    <id>http://yoursite.com/2016/03/07/Leetcode-Increasing-Triplet-Subsequence-Java/</id>
    <published>2016-03-08T00:09:02.000Z</published>
    <updated>2016-03-08T00:12:16.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.</p>
<p>Formally the function should:<br>Return true if there exists i, j, k<br>such that arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤ n-1 else return false.<br>Your algorithm should run in O(n) time complexity and O(1) space complexity.</p>
<p>Examples:<br>Given [1, 2, 3, 4, 5],<br>return true.</p>
<p>Given [5, 4, 3, 2, 1],<br>return false.</p>
<p><strong>Thinking:</strong></p>
<p>We need to implement this algorithm in linear time and constant space. So we need to scan this array once and record the information needed in one time. We need to variable to record the information, the first one is the minimum of this array, and the second one is the number which is bigger than its previous elements. If one element is bigger than it, the result will be true. Otherwise, we should update the two variables’ values.</p>
<p><strong>Solution:</strong></p>
<pre><code>public boolean increasingTriplet(int[] nums) {
    int l = nums.length;
    if (l &lt; 3)    return false;
    int min = nums[0];
    int secmin = Integer.MAX_VALUE;

    for (int i = 1; i &lt; l; i++) {
        if (nums[i] &gt; secmin)    return true;
        else if (nums[i] &lt;= min) min = nums[i];
        else if (nums[i] &lt; secmin)    secmin = nums[i];
    }
    return false;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array]]>
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Shortest Path Problem]]></title>
    <link href="http://yoursite.com/2016/03/06/Shortest-Path-Problem/"/>
    <id>http://yoursite.com/2016/03/06/Shortest-Path-Problem/</id>
    <published>2016-03-06T22:37:58.000Z</published>
    <updated>2016-03-06T23:50:35.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Shorstest Path Problem Categories:</strong></p>
<ol>
<li>From a speicific start point;</li>
<li>To a specific end point;</li>
<li>Start and end with a specific point;</li>
<li>Search for all the shortest path in every pair nodes.</li>
</ol>
<p><strong>Dijkstra:</strong></p>
<p>This algorithm is aiming at caculating all the shortest paths from every point to a specific start point. And it’s a greedy algorithm.</p>
<p>Algorithm:</p>
<ol>
<li>Set the distance to the start node as infinity to all the nodes except the start node.</li>
<li>Initial a set which conclude the added nodes, and another set for unvisited nodes.</li>
<li>For the added nodes set, we find the shortest edge from adjancent nodes crossing this set in unvisited set. And add the adjancent node to the added added nodes.</li>
<li>Update the distances of nodes from start node which connect to the last added node.</li>
<li>Do step 3 and 4 repeatedly until all the nodes are in the added set.</li>
</ol>
<p>Pseudoode:</p>
<pre><code>function Dijkstra(Graph, source):

    create vertex set Q

    for each vertex v in Graph:             // Initialization
    dist[v] ← INFINITY                  // Unknown distance from source to v
    prev[v] ← UNDEFINED                 // Previous node in optimal path from source
    add v to Q                          // All nodes initially in Q (unvisited nodes)

    dist[source] ← 0                        // Distance from source to source

    while Q is not empty:
        u ← vertex in Q with min dist[u]    // Source node will be selected first
        remove u from Q 

        for each neighbor v of u:           // where v is still in Q.
            alt ← dist[u] + length(u, v)
            if alt &lt; dist[v]:               // A shorter path to v has been found
                dist[v] ← alt 
                prev[v] ← u 

    return dist[], prev[]
</code></pre><p>Java Code:</p>
<pre><code>public static void dijkstra(int[][] edges, int s, int[] dist, int[] pre) {
    int n = edges.length;

    HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(n);

    for (int i = 0; i &lt; n; i++) {
        dist[i] = Integer.MAX_VALUE;
        set.add(i);
    }
    dist[s] = 0;

    while (!set.isEmpty()) {
        int min = findMin(set, dist);
        for (int i = 0; i &lt; n; i++) {
            if (edges[min][i] != -1) { // find the neighbors of the node
                if (dist[i] &lt; dist[min] + edges[min][i]) { //relaxation
                    dist[i] = dist[min] + edges[min][i];
                    pre[i] = min;
                }
            }
        }
    }
}
private static int findMin(Set set, int[] dist) {
    int min = Integer.MAX_VALUE, minIdx = -1;
    for (int i = 0; i &lt; dist.length; i++) {
        if (set.contains(i) &amp;&amp; dist[i] &lt; min) {
            min = dist[i];
            minIdx = i;
        }
    }
    set.remove(minIdx);
    return minIdx;
}
</code></pre><p>Running Time:</p>
<p>O(E*lgv)</p>
<p>If use the Fibonacci heap -&gt;  O(V*lgV + E)</p>
<p><strong>Bellman Ford:</strong></p>
<p>Aimming at searching for the shortest path from a specific start node. It is useful also for the graph containing the negative edges. It’s a dynamic programming algorithm.</p>
<p>Algorithm:</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Shorstest Path Problem Categories:</strong></p>
<ol>
<li>From a speicific start point;</li>
<li>To a specific end point;</li>
<li]]>
    </summary>
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Maximal Square(Java)]]></title>
    <link href="http://yoursite.com/2016/02/27/Leetcode-Maximal-Square-Java/"/>
    <id>http://yoursite.com/2016/02/27/Leetcode-Maximal-Square-Java/</id>
    <published>2016-02-28T04:51:07.000Z</published>
    <updated>2016-02-28T04:54:04.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing all 1’s and return its area.</p>
<p>For example, given the following matrix:</p>
<pre><code>1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
</code></pre><p>Return 4.</p>
<p><strong>Thinking:</strong></p>
<p>IIf the [i-1][j], [i][j-1] and [i-1][j-1] all have the same length of ‘1’ edge and the [i][j] is ‘1’, the length of the square can increase.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int maximalSquare(char[][] matrix) {
    int m = matrix.length;
    if (m == 0)    return 0;
    int n = matrix[0].length;
    int res = 0;
    int[][] opt = new int[m+1][n+1];

    for (int i = 1; i &lt;= m; i++){
        for (int j = 1; j &lt;= n; j++) {
            if (matrix[i-1][j-1] == &apos;1&apos;) {
                opt[i][j] = Math.min(opt[i-1][j-1], Math.min(opt[i-1][j], opt[i][j-1])) + 1;
                res = Math.max(res, opt[i][j]);
            }
        }
    }

    return res * res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing all 1’s and return]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Reorder List(Java)]]></title>
    <link href="http://yoursite.com/2016/02/27/Leetcode-Reorder-List-Java/"/>
    <id>http://yoursite.com/2016/02/27/Leetcode-Reorder-List-Java/</id>
    <published>2016-02-28T01:01:11.000Z</published>
    <updated>2016-02-28T01:03:28.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>You must do this in-place without altering the nodes’ values.</p>
<p>For example,<br>Given {1,2,3,4}, reorder it to {1,4,2,3}.</p>
<p><strong>Thinking:</strong></p>
<p>We need three steps to finish this operation. The first one is to find the middle in the linked list. The second one is to reverse the second half of this linked list. The final one is to link these two parts again.</p>
<p><strong>Solution:</strong></p>
<pre><code>public void reorderList(ListNode head) {
    if (head == null || head.next == null)    return;
    ListNode slow = head, fast = head.next, preMiddle, preCurrent, current, p, q;

    //find the middle
    while (fast != null &amp;&amp; fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }

    //reverse the second half
    preMiddle = slow;
    preCurrent = slow.next;
    while (preCurrent.next != null) {
        current = preCurrent.next;
        preCurrent.next = current.next;
        current.next = preMiddle.next;
        preMiddle.next = current;
    }

    //connect two parts
    p = head;
    q = preMiddle.next;
    while (p != preMiddle) {
        preMiddle.next = q.next;
        q.next = p.next;
        p.next = q;
        p = q.next;
        q = preMiddle.next;
    }

}
</code></pre><p>Reference:<a href="https://leetcode.com/discuss/35599/java-solution-with-3-steps" target="_blank" rel="external">https://leetcode.com/discuss/35599/java-solution-with-3-steps</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>You mus]]>
    </summary>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Word Ladder(Java)]]></title>
    <link href="http://yoursite.com/2016/02/26/Leetcode-Word-Ladder-Java/"/>
    <id>http://yoursite.com/2016/02/26/Leetcode-Word-Ladder-Java/</id>
    <published>2016-02-27T03:18:18.000Z</published>
    <updated>2016-02-27T22:32:41.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:</p>
<p>Only one letter can be changed at a time<br>Each intermediate word must exist in the word list<br>For example,</p>
<p>Given:<br>beginWord = “hit”<br>endWord = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”]<br>As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>return its length 5.</p>
<p>Note:<br>Return 0 if there is no such transformation sequence.<br>All words have the same length.<br>All words contain only lowercase alphabetic characters.</p>
<p><strong>Thinking:</strong></p>
<p>We can search the result from the start word. At every step, we change the every index of the start string and check if it’s in the WordList. If it’s in the range, then we add it to our nodes. Do it like a BFS search. Also in order to be more efficient, we can search also from the end word.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int ladderLength(String beginWord, String endWord, Set&lt;String&gt; wordList) {
    if (beginWord.equals(endWord))    return 1;
    Set&lt;String&gt; startSet = new HashSet&lt;String&gt;();
    Set&lt;String&gt; endSet =  new HashSet&lt;String&gt;();
    int res = 1;
    startSet.add(beginWord);
    endSet.add(endWord);
    while (!wordList.isEmpty() &amp;&amp; !startSet.isEmpty() &amp;&amp; !endSet.isEmpty()) {
        res++;
        Set&lt;String&gt; tempSet = new HashSet&lt;String&gt;();
        for (String nWord: startSet) {
            wordList.remove(nWord);
            for (String ele: check(nWord, wordList)) {
                if (endSet.contains(ele))    return res;
                tempSet.add(ele);
            }
        }
        startSet = tempSet;
        tempSet = new HashSet&lt;String&gt;();
        res++;
        for (String nWord: endSet) {
            wordList.remove(nWord);
            for (String ele: check(nWord, wordList)) {
                if (startSet.contains(ele))    return res;
                tempSet.add(ele);
            }
        }
        endSet = tempSet;
    }
    return 0;
}
private List&lt;String&gt; check(String word, Set&lt;String&gt; wordList) {
    List&lt;String&gt; res = new ArrayList&lt;String&gt;();
    int len = word.length();
    if (len == 1)    {
        res.addAll(wordList);
        return res;
    }
    for (int i = 0; i &lt; len; i++) {
        char[] chs = word.toCharArray();
        for (char j = &apos;a&apos;; j &lt;= &apos;z&apos;; j++) {
            chs[i] = j;
            String temp = String.valueOf(chs);
            if (wordList.contains(temp))    res.add(temp);              
        }
    }
    return res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest tran]]>
    </summary>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Validate Binary Search Tree(Java)]]></title>
    <link href="http://yoursite.com/2016/02/26/Leetcode-Validate-Binary-Search-Tree-Java/"/>
    <id>http://yoursite.com/2016/02/26/Leetcode-Validate-Binary-Search-Tree-Java/</id>
    <published>2016-02-27T03:12:44.000Z</published>
    <updated>2016-02-27T03:17:34.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.</p>
<p><strong>Thinking:</strong></p>
<p>We should use dfs check the root of the range and both its left child and right child.</p>
<p><strong>Solution:</strong></p>
<pre><code>public boolean isValidBST(TreeNode root) {
    return helper(root, Long.MIN_VALUE, Long.MAX_VALUE);
}

private boolean helper(TreeNode root, long a, long b) {
    if (root == null)    return true;
    if (root.val &lt;= a || root.val &gt;= b)    return false;        
    return helper(root.left, a, root.val&lt;b? root.val:b) &amp;&amp; helper(root.right, root.val&gt;a? root.val:a, b);
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is define]]>
    </summary>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Decode Ways(Java)]]></title>
    <link href="http://yoursite.com/2016/02/26/Leetcode-Decode-Ways-Java/"/>
    <id>http://yoursite.com/2016/02/26/Leetcode-Decode-Ways-Java/</id>
    <published>2016-02-26T20:35:11.000Z</published>
    <updated>2016-02-26T20:41:51.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>A message containing letters from A-Z is being encoded to numbers using the following mapping:</p>
<p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>Given an encoded message containing digits, determine the total number of ways to decode it.</p>
<p>For example,<br>Given encoded message “12”, it could be decoded as “AB” (1 2) or “L” (12).</p>
<p>The number of ways decoding “12” is 2.</p>
<p><strong>Thinking:</strong></p>
<p>If we use the recursive way, we should see that the search tree will go down like check [0],[0,1], then [1],[1,2] and [2],[2,3] then [2], [2,3] and [3],[3,4] and [3],[3,4] and [4],[4,5] … There are some nodes are repeated. So we can use interation from bottom to root to store the number of paths in every index of string.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int numDecodings(String s) {
    int l = s.length();
    if (l == 0)    return 0;
    int[] counts = new int[l+1];

    counts[l] = 1;
    if (s.charAt(l-1) != &apos;0&apos;)    counts[l-1] = 1;

    for (int i = l-2; i &gt;=0; i--) {
        if (s.charAt(i) == &apos;0&apos;)    continue;
        counts[i] = Integer.parseInt(s.substring(i, i+2)) &lt;=26? counts[i+1]+counts[i+2] : counts[i+1];
    }

    return counts[0];
}
</code></pre><p>Reference: <a href="https://leetcode.com/discuss/8527/dp-solution-java-for-reference" target="_blank" rel="external">https://leetcode.com/discuss/8527/dp-solution-java-for-reference</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>A message containing letters from A-Z is being encoded to numbers using the following mapping:</p>
<p>‘]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Simplify Path(Java)]]></title>
    <link href="http://yoursite.com/2016/02/25/Leetcode-Simplify-Path-Java/"/>
    <id>http://yoursite.com/2016/02/25/Leetcode-Simplify-Path-Java/</id>
    <published>2016-02-25T22:47:27.000Z</published>
    <updated>2016-02-25T22:56:13.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an absolute path for a file (Unix-style), simplify it.</p>
<p>For example,<br>path = “/home/“, =&gt; “/home”<br>path = “/a/./b/../../c/“, =&gt; “/c”<br>click to show corner cases.</p>
<p>Corner Cases:<br>Did you consider the case where path = “/../“?<br>In this case, you should return “/“.<br>Another corner case is the path might contain multiple slashes ‘/‘ together, such as “/home//foo/“.<br>In this case, you should ignore redundant slashes and return “/home/foo”.</p>
<p><strong>Thinking:</strong></p>
<p>The file system is like a tree, and finding path of this tree is like a dfs process. So we can use stack to track the node of dfs. If the string is “..”, we go back, otherwise go to the given dirctory.</p>
<p><strong>Solution:</strong></p>
<pre><code>public String simplifyPath(String path) {
    Stack&lt;String&gt; stack = new Stack&lt;String&gt;();
    String[] paths = path.split(&quot;/&quot;);

    for (String p: paths) {
        p = p.trim();
        if (p.equals(&quot;&quot;) || p.equals(&quot;.&quot;))    continue;
        if (p.equals(&quot;..&quot;))    {
            if (!stack.isEmpty()) {
                stack.pop();
            }
            continue;
        }
        stack.push(p);
    }

    StringBuilder res = new StringBuilder();
    while (!stack.isEmpty()) 
        res.insert(0, &quot;/&quot;.concat(stack.pop()));


    return res.length() == 0? &quot;/&quot;:res.toString();
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given an absolute path for a file (Unix-style), simplify it.</p>
<p>For example,<br>path = “/home/“, =&]]>
    </summary>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Word Search(Java)]]></title>
    <link href="http://yoursite.com/2016/02/25/Leetcode-Word-Search-Java/"/>
    <id>http://yoursite.com/2016/02/25/Leetcode-Word-Search-Java/</id>
    <published>2016-02-25T21:44:36.000Z</published>
    <updated>2016-02-25T21:49:05.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p>For example,<br>Given board =</p>
<p>[<br>  [‘A’,’B’,’C’,’E’],<br>  [‘S’,’F’,’C’,’S’],<br>  [‘A’,’D’,’E’,’E’]<br>]<br>word = “ABCCED”, -&gt; returns true,<br>word = “SEE”, -&gt; returns true,<br>word = “ABCB”, -&gt; returns false.</p>
<p><strong>Thinking:</strong></p>
<p>I assume it’s graph and do dfs in this 2d array. Start from every point and search the result until find the solution or failure. In this process, we need to record the visitied set. In my solution, I used the hashset. But in more efficient way, we can use bit manipulate to mask the visited element.</p>
<p><strong>Solution:</strong></p>
<p>My solution(use HashSet):</p>
<pre><code>public boolean exist(char[][] board, String word) {
    int m = board.length;
    if (m == 0)    return false;
    int n = board[0].length;
    Set&lt;Integer&gt; record = new HashSet&lt;Integer&gt;();
    for (int i = 0; i &lt; m; i++)
        for (int j = 0; j &lt; n; j++)
            if (backtracking(board, word, 0, i, j, record))    return true;
    return false;
}

private boolean backtracking(char[][] board, String word, int index, int i, int j, Set&lt;Integer&gt; record) {
    if (board[i][j] == word.charAt(index) &amp;&amp; !record.contains(i*board[0].length+j)){
        if (index == word.length()-1)    return true;
        boolean res = false;
        record.add(i*board[0].length+j);
        if (i-1&gt;=0)    res |= backtracking(board, word, index+1, i-1, j, record);
        if (!res &amp;&amp; i+1&lt;board.length) res |= backtracking(board, word, index+1, i+1, j, record);
        if (!res &amp;&amp; j-1&gt;=0)    res |= backtracking(board, word, index+1, i, j-1, record);
        if (!res &amp;&amp; j+1&lt;board[0].length) res |= backtracking(board, word, index+1, i, j+1, record);
        record.remove(i*board[0].length+j);
        return res;
    }
    return false;
}
</code></pre><p>use the mask:</p>
<pre><code>public boolean exist(char[][] board, String word) {
    char[] w = word.toCharArray();
    for (int y=0; y&lt;board.length; y++) {
        for (int x=0; x&lt;board[y].length; x++) {
            if (exist(board, y, x, w, 0)) return true;
        }
    }
    return false;
}

private boolean exist(char[][] board, int y, int x, char[] word, int i) {
    if (i == word.length) return true;
    if (y&lt;0 || x&lt;0 || y == board.length || x == board[y].length) return false;
    if (board[y][x] != word[i]) return false;
        board[y][x] ^= 256;
    boolean exist = exist(board, y, x+1, word, i+1)
    || exist(board, y, x-1, word, i+1)
    || exist(board, y+1, x, word, i+1)
    || exist(board, y-1, x, word, i+1);
    board[y][x] ^= 256;
    return exist;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed fr]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Spiral Matrix(Java)]]></title>
    <link href="http://yoursite.com/2016/02/23/Leetcode-Spiral-Matrix-Java/"/>
    <id>http://yoursite.com/2016/02/23/Leetcode-Spiral-Matrix-Java/</id>
    <published>2016-02-24T04:12:38.000Z</published>
    <updated>2016-02-24T04:14:10.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p>
<p>For example,<br>Given the following matrix:</p>
<pre><code>[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
</code></pre><p>You should return [1,2,3,6,9,8,7,4,5].</p>
<p><strong>Thinking:</strong></p>
<p>There are four directions can go, move according to the order of right, down, left, up and check the bound of moving.</p>
<p><strong>Solution:</strong></p>
<pre><code>public List&lt;Integer&gt; spiralOrder(int[][] matrix) {
    List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
    int m = matrix.length;
    if (m == 0)    return res;
    int n = matrix[0].length;
    int direction = 0;//0right, 1down, 2left, 3up
    int i = 0, j = 0;//position
    int c0 = 1, c1 = 1, c2 = 0, c3 = 1;//row and column limit

    while (c0 + c2 - 1 &lt;= n &amp;&amp; c1 + c3 - 1 &lt;= m) {
        res.add(matrix[i][j]);
        switch (direction) {
        case 0:
            if (j == n-c0){
                direction = (direction+1) % 4;
                c0++;
                res.remove(res.size()-1);
            }
            else
                j++;
            break;
        case 1:
            if (i == m-c1){
                direction = (direction+1) % 4;
                c1++;
                res.remove(res.size()-1);
            }
            else
                i++;
            break;
        case 2:
            if (j == c2){
                direction = (direction+1) % 4;
                c2++;
                res.remove(res.size()-1);
            }
            else
                j--;
            break;
        case 3:
            if (i == c3){
                direction = (direction+1) % 4;
                c3++;
                res.remove(res.size()-1);
            }
            else
                i--;
            break;
        }
    }
    res.add(matrix[i][j]);

    return res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Multiply Strings(Java)]]></title>
    <link href="http://yoursite.com/2016/02/23/Leetcode-Multiply-Strings-Java/"/>
    <id>http://yoursite.com/2016/02/23/Leetcode-Multiply-Strings-Java/</id>
    <published>2016-02-24T03:09:09.000Z</published>
    <updated>2016-02-24T03:20:12.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given two numbers represented as strings, return multiplication of the numbers as a string.</p>
<p>Note: The numbers can be arbitrarily large and are non-negative.</p>
<p><strong>Thinking:</strong></p>
<p>Simulate the process of multiplying.</p>
<p><img src="https://drscdn.500px.org/photo/130178585/m%3D2048/300d71f784f679d5e70fadda8ad7d68f" alt=""></p>
<p><strong>Solution:</strong> (Record the result from low digits to high digits in array)</p>
<pre><code>public String multiply(String num1, String num2) {
    int l1 = num1.length(), l2 = num2.length();
    int[] res = new int[l1+l2];

    for (int i = l1-1; i &gt;= 0; i--) {
        for (int j = l2-1; j &gt;= 0; j--){
            int index = l1+l2-i-j-2;
            res[index] += (num1.charAt(i) - &apos;0&apos;) * (num2.charAt(j) - &apos;0&apos;);
            res[index+1] += res[index] / 10;
            res[index] = res[index] % 10;
        }
    }

    StringBuilder fres = new StringBuilder();
    for (int i = res.length-1; i &gt;= 0; i--)
        if (!(fres.length() == 0 &amp;&amp; res[i] == 0))   fres.append(res[i]);

    return fres.length() == 0? &quot;0&quot;:fres.toString();
}
</code></pre><p>A little improvement which record the result from high to low digits in array:</p>
<p>public String multiply(String num1, String num2) {<br>    int m = num1.length(), n = num2.length();<br>    int[] pos = new int[m + n];</p>
<pre><code>for(int i = m - 1; i &gt;= 0; i--) {
    for(int j = n - 1; j &gt;= 0; j--) {
        int mul = (num1.charAt(i) - &apos;0&apos;) * (num2.charAt(j) - &apos;0&apos;); 
        int p1 = i + j, p2 = i + j + 1;
        int sum = mul + pos[p2];

        pos[p1] += sum / 10;
        pos[p2] = (sum) % 10;
    }
}  

StringBuilder sb = new StringBuilder();
for(int p : pos) if(!(sb.length() == 0 &amp;&amp; p == 0)) sb.append(p);
return sb.length() == 0 ? &quot;0&quot; : sb.toString();
</code></pre><p>}</p>
<p>Reference: <a href="https://leetcode.com/discuss/71593/easiest-java-solution-with-graph-explanation" target="_blank" rel="external">https://leetcode.com/discuss/71593/easiest-java-solution-with-graph-explanation</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given two numbers represented as strings, return multiplication of the numbers as a string.</p>
<p>Note]]>
    </summary>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Rotate List(Java)]]></title>
    <link href="http://yoursite.com/2016/02/23/Leetcode-Rotate-List-Java/"/>
    <id>http://yoursite.com/2016/02/23/Leetcode-Rotate-List-Java/</id>
    <published>2016-02-24T00:27:32.000Z</published>
    <updated>2016-02-24T00:29:56.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a list, rotate the list to the right by k places, where k is non-negative.</p>
<p>For example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,<br>return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.</p>
<p><strong>Thinking:</strong></p>
<p>Firstly, count the length of the linked list. Then get the n-k th node. Finnaly, change the pointer of it and the tail.</p>
<p><strong>Solution:</strong></p>
<pre><code>public ListNode rotateRight(ListNode head, int k) {
    if (head == null || head.next == null)    return head;
    ListNode p = head;
    int count = 1;
    while (p.next != null) {
        p = p.next;
        count++;
    }
    if (k == count)    return head;
    p.next = head;
    p = head;
    for (int i = 1; i &lt; count - k%count; i++) {
        p = p.next;
    }
    ListNode nhead = p.next;
    p.next = null;

    return nhead;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a list, rotate the list to the right by k places, where k is non-negative.</p>
<p>For example:<br]]>
    </summary>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Remove Duplicate Letters(Java)]]></title>
    <link href="http://yoursite.com/2016/02/23/Leetcode-Remove-Duplicate-Letters-Java/"/>
    <id>http://yoursite.com/2016/02/23/Leetcode-Remove-Duplicate-Letters-Java/</id>
    <published>2016-02-23T21:56:43.000Z</published>
    <updated>2016-02-23T22:59:13.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.</p>
<p>Example:<br>Given “bcabc”<br>Return “abc”</p>
<p>Given “cbacdcbc”<br>Return “acdb”</p>
<p><strong>Thinking:</strong></p>
<p>Record the times characters emerges in the list and check from left to right.Record the smallest character postion of the list until find the unique character, then delete the bigger characters before smallest one and delete smallest from the rest of list.</p>
<p><strong>Solution:</strong></p>
<pre><code>public String removeDuplicateLetters(String s) {
    int[] count = new int[26];
    int smallest = 0;
    if (s.length() == 0)    return &quot;&quot;;
    for (char c: s.toCharArray())    count[c-&apos;a&apos;]++;
    for (int i = 0; i &lt; s.length(); i++){
        if (s.charAt(i) &lt; s.charAt(smallest))    smallest = i;
        if (--count[s.charAt(i) - &apos;a&apos;] == 0)    break;
    }
    return s.charAt(smallest) + removeDuplicateLetters(s.substring(smallest+1).replaceAll(s.charAt(smallest)+&quot;&quot;, &quot;&quot;));
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a string which contains only lowercase letters, remove duplicate letters so that every letter app]]>
    </summary>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Number of Digit One(Java)]]></title>
    <link href="http://yoursite.com/2016/02/23/Leetcode-Number-of-Digit-One-Java/"/>
    <id>http://yoursite.com/2016/02/23/Leetcode-Number-of-Digit-One-Java/</id>
    <published>2016-02-23T21:51:33.000Z</published>
    <updated>2016-02-23T21:56:23.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.</p>
<p>For example:<br>Given n = 13,<br>Return 6, because digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.</p>
<p>Hint:</p>
<p>Beware of overflow.</p>
<p><strong>Thinking:</strong></p>
<p>This is question to find formula. We should notice that: </p>
<pre><code>1                   1                                                                                     [1, 9]

11                 10  11  12  13  14  15  16  17  18  19                              [10, 19]

1                   21                                                                                   [20, 29]

1                   31                                                                                   [30, 39]

1                   41                                                                                   [40, 49]

1                   51                                                                                   [50, 59]

1                   61                                                                                   [60, 69]

1                   71                                                                                   [70, 79]

1                   81                                                                                   [80, 89]

1                   91                                                                                   [90, 99]

11                 100  101  102  103  104  105  106  107  108  109          [100, 109]

21                 110  111  112  113  114  115  116  117  118  119             [110, 119]

11                 120  121  122  123  124  125  126  127  128  129          [120, 129]
</code></pre><p>We should divide it into three situations in every digit division: one is bigger than 2, another is equal to 1 and the rest is less than 0. </p>
<p><strong>Solution:</strong></p>
<pre><code>public int countDigitOne(int n) {
    int res = 0;
    for (long m = 1; m &lt;= n; m*=10) {
        res += (n/m + 8) / 10 * m + (n/m % 10 == 1? n%m+1:0);
    }
    return res;
}
</code></pre><p>Reference: <a href="https://leetcode.com/discuss/44281/4-lines-o-log-n-c-java-python" target="_blank" rel="external">https://leetcode.com/discuss/44281/4-lines-o-log-n-c-java-python</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than ]]>
    </summary>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Basic Calculator II(Java)]]></title>
    <link href="http://yoursite.com/2016/02/22/Leetcode-Basic-Calculator-II-Java/"/>
    <id>http://yoursite.com/2016/02/22/Leetcode-Basic-Calculator-II-Java/</id>
    <published>2016-02-23T06:37:46.000Z</published>
    <updated>2016-02-23T06:40:55.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Implement a basic calculator to evaluate a simple expression string.</p>
<p>The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero.</p>
<p>You may assume that the given expression is always valid.</p>
<p>Some examples:</p>
<pre><code>&quot;3+2*2&quot; = 7
&quot; 3/2 &quot; = 1
&quot; 3+5 / 2 &quot; = 5
</code></pre><p>Note: Do not use the eval built-in library function.</p>
<p><strong>Thinking:</strong></p>
<p>An efficient way to solve this problem is to use stack get last num for an operation. And in order to delay the operation after get the two numbers, we need a op variable to record the last op until find the second number. What’s more, accroding to their op, numbers push into the stack in different ways. Finnaly, we just need to get the element from stack and add them all.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int calculate(String s) {
    Stack&lt;Long&gt; stack = new Stack&lt;Long&gt;();

    int i = 0;
    char op = &apos;+&apos;;
    long num = 0;

    while (i &lt; s.length()) {
        if (Character.isDigit(s.charAt(i))) {
            while (i &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i)))
                num = num * 10 + s.charAt(i++) - &apos;0&apos;;
        }
        else if (s.charAt(i) == &apos; &apos;)
            i++;
        else {
            if (op == &apos;+&apos;)
                stack.push(num);
            else if (op == &apos;-&apos;)
                stack.push(-num);
            else if (op == &apos;*&apos;)
                stack.push(stack.pop() * num);
            else if (op == &apos;/&apos;)
                stack.push(stack.pop() / num);
            num = 0;
            op = s.charAt(i++);
        }
    }

    if (op == &apos;+&apos;)
        stack.push(num);
    else if (op == &apos;-&apos;)
        stack.push(-num);
    else if (op == &apos;*&apos;)
        stack.push(stack.pop() * num);
    else if (op == &apos;/&apos;)
        stack.push(stack.pop() / num);

    int res = 0;
    for (Long n: stack)
        res += n;

    return res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Implement a basic calculator to evaluate a simple expression string.</p>
<p>The expression string conta]]>
    </summary>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Repeated DNA Sequences(Java)]]></title>
    <link href="http://yoursite.com/2016/02/22/Leetcode-Repeated-DNA-Sequences-Java/"/>
    <id>http://yoursite.com/2016/02/22/Leetcode-Repeated-DNA-Sequences-Java/</id>
    <published>2016-02-23T04:11:24.000Z</published>
    <updated>2016-02-23T05:09:08.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.</p>
<p>Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.</p>
<p>For example,</p>
<pre><code>Given s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;,

Return:
[&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;].
</code></pre><p><strong>Thinking:</strong></p>
<p>Because it limits the length of repeated substrings, so we can travse the list one time from the left to right. Pick substring from the list to check whether this substring emerge beofe.</p>
<p><strong>Solution:</strong></p>
<pre><code>public List&lt;String&gt; findRepeatedDnaSequences(String s) {
    HashSet&lt;String&gt; set = new HashSet&lt;String&gt;();
    List&lt;String&gt; res = new ArrayList&lt;String&gt;();

    for (int i = 0; i+10 &lt;= s.length(); i ++) {
        String temp = s.substring(i, i+10);
        if (!set.contains(temp)) {
            set.add(temp);
        }
        else {
            if (!res.contains(temp))
                res.add(temp);
        }
    }

    return res;
}
</code></pre><p>More efficient way:(which use the bits to represent map fucntion, reference: <a href="https://leetcode.com/discuss/25399/clean-java-solution-hashmap-bits-manipulation" target="_blank" rel="external">https://leetcode.com/discuss/25399/clean-java-solution-hashmap-bits-manipulation</a>)</p>
<pre><code>public List&lt;String&gt; findRepeatedDnaSequences(String s) {
    HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();
    HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();
    HashSet&lt;Integer&gt; second = new HashSet&lt;Integer&gt;();
    List&lt;String&gt; res = new ArrayList&lt;String&gt;();

    if (s.length() &lt; 10)    return res;

    map.put(&apos;A&apos;, 0);
    map.put(&apos;C&apos;, 1);
    map.put(&apos;G&apos;, 2);
    map.put(&apos;T&apos;, 3);

    int v = 0;

    for (int i = 0; i &lt; s.length(); i++) {
        v &lt;&lt;= 2;
        v |= map.get(s.charAt(i));
        v &amp;= 0xfffff;
        if (i &lt; 9)    continue;
        if (!set.add(v) &amp;&amp; second.add(v)) {
            res.add(s.substring(i-9, i+1));
        }
    }

    return res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”]]>
    </summary>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
</feed>
