<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Martin's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-02-23T06:40:55.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Martin]]></name>
    <email><![CDATA[martinglory1992@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Leetcode-Basic Calculator II(Java)]]></title>
    <link href="http://yoursite.com/2016/02/22/Leetcode-Basic-Calculator-II-Java/"/>
    <id>http://yoursite.com/2016/02/22/Leetcode-Basic-Calculator-II-Java/</id>
    <published>2016-02-23T06:37:46.000Z</published>
    <updated>2016-02-23T06:40:55.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Implement a basic calculator to evaluate a simple expression string.</p>
<p>The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero.</p>
<p>You may assume that the given expression is always valid.</p>
<p>Some examples:</p>
<pre><code>&quot;3+2*2&quot; = 7
&quot; 3/2 &quot; = 1
&quot; 3+5 / 2 &quot; = 5
</code></pre><p>Note: Do not use the eval built-in library function.</p>
<p><strong>Thinking:</strong></p>
<p>An efficient way to solve this problem is to use stack get last num for an operation. And in order to delay the operation after get the two numbers, we need a op variable to record the last op until find the second number. What’s more, accroding to their op, numbers push into the stack in different ways. Finnaly, we just need to get the element from stack and add them all.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int calculate(String s) {
    Stack&lt;Long&gt; stack = new Stack&lt;Long&gt;();

    int i = 0;
    char op = &apos;+&apos;;
    long num = 0;

    while (i &lt; s.length()) {
        if (Character.isDigit(s.charAt(i))) {
            while (i &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i)))
                num = num * 10 + s.charAt(i++) - &apos;0&apos;;
        }
        else if (s.charAt(i) == &apos; &apos;)
            i++;
        else {
            if (op == &apos;+&apos;)
                stack.push(num);
            else if (op == &apos;-&apos;)
                stack.push(-num);
            else if (op == &apos;*&apos;)
                stack.push(stack.pop() * num);
            else if (op == &apos;/&apos;)
                stack.push(stack.pop() / num);
            num = 0;
            op = s.charAt(i++);
        }
    }

    if (op == &apos;+&apos;)
        stack.push(num);
    else if (op == &apos;-&apos;)
        stack.push(-num);
    else if (op == &apos;*&apos;)
        stack.push(stack.pop() * num);
    else if (op == &apos;/&apos;)
        stack.push(stack.pop() / num);

    int res = 0;
    for (Long n: stack)
        res += n;

    return res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Implement a basic calculator to evaluate a simple expression string.</p>
<p>The expression string conta]]>
    </summary>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Repeated DNA Sequences(Java)]]></title>
    <link href="http://yoursite.com/2016/02/22/Leetcode-Repeated-DNA-Sequences-Java/"/>
    <id>http://yoursite.com/2016/02/22/Leetcode-Repeated-DNA-Sequences-Java/</id>
    <published>2016-02-23T04:11:24.000Z</published>
    <updated>2016-02-23T05:09:08.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.</p>
<p>Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.</p>
<p>For example,</p>
<pre><code>Given s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;,

Return:
[&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;].
</code></pre><p><strong>Thinking:</strong></p>
<p>Because it limits the length of repeated substrings, so we can travse the list one time from the left to right. Pick substring from the list to check whether this substring emerge beofe.</p>
<p><strong>Solution:</strong></p>
<pre><code>public List&lt;String&gt; findRepeatedDnaSequences(String s) {
    HashSet&lt;String&gt; set = new HashSet&lt;String&gt;();
    List&lt;String&gt; res = new ArrayList&lt;String&gt;();

    for (int i = 0; i+10 &lt;= s.length(); i ++) {
        String temp = s.substring(i, i+10);
        if (!set.contains(temp)) {
            set.add(temp);
        }
        else {
            if (!res.contains(temp))
                res.add(temp);
        }
    }

    return res;
}
</code></pre><p>More efficient way:(which use the bits to represent map fucntion, reference: <a href="https://leetcode.com/discuss/25399/clean-java-solution-hashmap-bits-manipulation" target="_blank" rel="external">https://leetcode.com/discuss/25399/clean-java-solution-hashmap-bits-manipulation</a>)</p>
<pre><code>public List&lt;String&gt; findRepeatedDnaSequences(String s) {
    HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();
    HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();
    HashSet&lt;Integer&gt; second = new HashSet&lt;Integer&gt;();
    List&lt;String&gt; res = new ArrayList&lt;String&gt;();

    if (s.length() &lt; 10)    return res;

    map.put(&apos;A&apos;, 0);
    map.put(&apos;C&apos;, 1);
    map.put(&apos;G&apos;, 2);
    map.put(&apos;T&apos;, 3);

    int v = 0;

    for (int i = 0; i &lt; s.length(); i++) {
        v &lt;&lt;= 2;
        v |= map.get(s.charAt(i));
        v &amp;= 0xfffff;
        if (i &lt; 9)    continue;
        if (!set.add(v) &amp;&amp; second.add(v)) {
            res.add(s.substring(i-9, i+1));
        }
    }

    return res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”]]>
    </summary>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Count Complete Tree Nodes(Java)]]></title>
    <link href="http://yoursite.com/2016/02/22/Leetcode-Count-Complete-Tree-Nodes-Java/"/>
    <id>http://yoursite.com/2016/02/22/Leetcode-Count-Complete-Tree-Nodes-Java/</id>
    <published>2016-02-23T03:49:47.000Z</published>
    <updated>2016-02-23T03:55:33.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a complete binary tree, count the number of nodes.</p>
<p>Definition of a complete binary tree from Wikipedia:<br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p>
<p><strong>Thinking:</strong></p>
<p>Firstly, I want to traverse the tree, but we can do better. Because we know its structure is special. For example, if this root’s height is this root’s right child’s height minus 1, its left subtree must be a full tree. So we need to caclulate the rest nodes which remain in its right subtree. Otherwise, we need to go to left.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int countNodes(TreeNode root) {
    int h = height(root);
    if (h == 0)
        return 0;
    if (h == height(root.right)+1){
        return (1 &lt;&lt; (h-1)) + countNodes(root.right);
    } else {
        return (1 &lt;&lt; (h-2)) + countNodes(root.left);
    }
}

private int height(TreeNode root) {
    return root == null? 0 : 1 + height(root.left);
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a complete binary tree, count the number of nodes.</p>
<p>Definition of a complete binary tree fr]]>
    </summary>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Sort List(Java)]]></title>
    <link href="http://yoursite.com/2016/02/22/Leetcode-Sort-List-Java/"/>
    <id>http://yoursite.com/2016/02/22/Leetcode-Sort-List-Java/</id>
    <published>2016-02-23T01:27:44.000Z</published>
    <updated>2016-02-23T02:06:43.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Sort a linked list in O(n log n) time using constant space complexity.</p>
<p><strong>Thinking:</strong></p>
<p>There are three basic algorithm to sort in n*logn time. They are merge sort, heap sort and quick sort. And I implement the sort method in merge sort. In order to do this, I have to implement the function such as getLength, get the mid node, merge and so on.</p>
<p>Basic idea of merge sort is to divide a list into two lists, and make them sorted then merge them together.</p>
<p><strong>Solution:</strong></p>
<pre><code>//merge
public ListNode sortList(ListNode head) {
    int len = getLength(head);
    if (len == 0)    return null;
    ListNode nhead = mergeSort(head, len);
    addTail(nhead, len);
    return nhead;
}

private ListNode mergeSort(ListNode head, int n) {
    if (n &lt;= 1)
        return head;
    ListNode mid = getNode(head, n/2);
    ListNode nhead = mergeSort(head, n/2);
    ListNode nmid = mergeSort(mid, n - n/2);
    return merge(nhead, nmid, n);
}

private int getLength(ListNode head) {
    int l = 0;

    while (head != null) {
        head = head.next;
        l++;
    }

    return l;
}

private ListNode getNode(ListNode head, int index) {
    while (index &gt; 0) {
        head = head.next;
        index--;
    }

    return head;
}

private ListNode merge(ListNode p1, ListNode p2, int len) {
    ListNode dummy = new ListNode(0);
    ListNode p = dummy;
    int l1 = 0;
    int l2 = 0;
    while (l1 &lt; len/2 &amp;&amp; l2 &lt; len - len/2) {
        if (p1.val &lt; p2.val) {
            p.next = p1;
            p1 = p1.next;
            p = p.next;
            l1++;
        } else {
            p.next = p2;
            p2 = p2.next;
            p = p.next;
            l2++;
        }
    }
    if (l1 == len/2) {
        p.next = p2;
    } else {
        p.next = p1;
    }
    return dummy.next;
}

private void addTail(ListNode head, int n) {
    while (n &gt; 1) {
        head = head.next;
        n--;
    }
    head.next = null;
}
</code></pre><p>More efficient method:<br>Reference:<a href="https://leetcode.com/discuss/1709/have-pretty-mergesort-method-anyone-speed-reduce-memory-usage" target="_blank" rel="external">https://leetcode.com/discuss/1709/have-pretty-mergesort-method-anyone-speed-reduce-memory-usage</a></p>
<p>It use the fast pointer and slow pointer to find the middle index of the linked list. Add a null to the first half to implement the merge operation.</p>
<pre><code>public ListNode sortList(ListNode head) {
    if (head == null || head.next == null)
        return head;
    ListNode f = head.next.next;
    ListNode p = head;
    while (f != null &amp;&amp; f.next != null) {
        p = p.next;
        f =  f.next.next;
    }
    ListNode h2 = sortList(p.next);
    p.next = null;
    return merge(sortList(head), h2);
}
public ListNode merge(ListNode h1, ListNode h2) {
    ListNode hn = new ListNode(Integer.MIN_VALUE);
    ListNode c = hn;
    while (h1 != null &amp;&amp; h2 != null) {
        if (h1.val &lt; h2.val) {
            c.next = h1;
            h1 = h1.next;
        }
        else {
            c.next = h2;
            h2 = h2.next;
        }
        c = c.next;
    }
    if (h1 != null)
        c.next = h1;
    if (h2 != null)
        c.next = h2;
    return hn.next;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Sort a linked list in O(n log n) time using constant space complexity.</p>
<p><strong>Thinking:</strong]]>
    </summary>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Permutation Sequence(Java)]]></title>
    <link href="http://yoursite.com/2016/02/22/Leetcode-Permutation-Sequence-Java/"/>
    <id>http://yoursite.com/2016/02/22/Leetcode-Permutation-Sequence-Java/</id>
    <published>2016-02-22T23:33:08.000Z</published>
    <updated>2016-02-22T23:49:50.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p>
<p>By listing and labeling all of the permutations in order,<br>We get the following sequence (ie, for n = 3):</p>
<p>“123”<br>“132”<br>“213”<br>“231”<br>“312”<br>“321”<br>Given n and k, return the kth permutation sequence.</p>
<p>Note: Given n will be between 1 and 9 inclusive.</p>
<p><strong>Thinking:</strong></p>
<p>We can conclude the position of the element in the searching tree according to the k. For example, there are n subtrees in the first level, so the k/(n-1) means picking the k/(n-1) th element in the array. And delete the element from the element, pick the next one. Do this recursively.</p>
<p><strong>Solution:</strong></p>
<pre><code>public String getPermutation(int n, int k) {
    ArrayList&lt;Integer&gt; nums = new ArrayList&lt;Integer&gt;();
    int fac = 1;
    int[] pos = new int[n+1];
    for (int i = 1; i &lt;= n; i++){
        nums.add(i);
        fac *= i;
    }
    fac /= n;
    k -= 1;
    for (int i = 1; i &lt; n; i++){
        pos[i] = k / fac;
        k %= fac;
        fac /= (n-i);
    }
    StringBuilder res = new StringBuilder();
    for (int i = 1; i &lt;= n; i++){
        res.append(nums.remove(pos[i]));
    }

    return res.toString();
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p>
<p>By listing and labeling all of t]]>
    </summary>
    
      <category term="BackTracking" scheme="http://yoursite.com/tags/BackTracking/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Longest Substring Without Repeating Characters(Java)]]></title>
    <link href="http://yoursite.com/2016/02/21/Leetcode-Longest-Substring-Without-Repeating-Characters-Java/"/>
    <id>http://yoursite.com/2016/02/21/Leetcode-Longest-Substring-Without-Repeating-Characters-Java/</id>
    <published>2016-02-22T03:48:17.000Z</published>
    <updated>2016-02-22T22:49:44.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for “abcabcbb” is “abc”, which the length is 3. For “bbbbb” the longest substring is “b”, with the length of 1.</p>
<p><strong>Thinking:</strong></p>
<p>The basic idea is to maintain a hashmap to keep the exsiting characters. If there is a character appered in the hashmap, then move the index to the last position it emerged. Hold two pointers: one is to record the substring’s start position and the other is to record the substring’s end position. And the pointers can only move forward.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int lengthOfLongestSubstring(String s) {
    HashMap&lt;Character, Integer&gt; alphabeta = new HashMap&lt;Character, Integer&gt;();
    int max = 0;
    int count = 0;
    int idx = 0;

    while (idx+count &lt; s.length()) {

        if (!alphabeta.containsKey(s.charAt(idx + count))) {
            alphabeta.put(s.charAt(idx + count), idx+count);
            count++;
        }
        else {
            idx = alphabeta.get(s.charAt(idx + count)) + 1;
            alphabeta = new HashMap&lt;Character, Integer&gt;();
            count = 0;
        }
        max = Math.max(max, count);
    }

    return max;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a string, find the length of the longest substring without repeating characters. For example, the]]>
    </summary>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Two Points" scheme="http://yoursite.com/tags/Two-Points/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Longest Palindromic Substring(Java)]]></title>
    <link href="http://yoursite.com/2016/02/21/Leetcode-Longest-Palindromic-Substring-Java/"/>
    <id>http://yoursite.com/2016/02/21/Leetcode-Longest-Palindromic-Substring-Java/</id>
    <published>2016-02-22T03:45:14.000Z</published>
    <updated>2016-02-22T03:47:32.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.</p>
<p><strong>Thinking:</strong></p>
<p>Run from left to right and check each element in different index. The check method is select a index, and expand its range to two sides of it. Record the max value and max substring.</p>
<p><strong>Solution:</strong></p>
<pre><code>int max = 1;
String res = &quot;&quot;;
public String longestPalindrome(String s) {
    if (s.length() &lt; 2)
        return s;
    for (int i = 0; i &lt; s.length() - max/2; i++){

        if (i+1&lt;s.length() &amp;&amp; s.charAt(i) == s.charAt(i+1)){
            check(s, i-1, i+2, 2);
        }

        check(s, i-1, i+1, 1);
    }

    return res;
}

private void check(String s, int i, int j, int len){
    int count = len;
    while (i &gt;= 0 &amp;&amp; j &lt; s.length()){
        if (s.charAt(i) == s.charAt(j))
            count += 2;
        else
            break;
        i--;
        j++;
    }
    if (count &gt; max){
        res = s.substring(i+1, j);
        max = count;
    }

}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length o]]>
    </summary>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Add Two Numbers(Java)]]></title>
    <link href="http://yoursite.com/2016/02/21/Leetcode-Add-Two-Numbers-Java/"/>
    <id>http://yoursite.com/2016/02/21/Leetcode-Add-Two-Numbers-Java/</id>
    <published>2016-02-22T02:07:11.000Z</published>
    <updated>2016-02-22T02:09:17.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8</p>
<p><strong>Thinking:</strong></p>
<p>It’s like a problem adding two numbers from the low digits to high digits. We need two variable to record the sum of current digit and whether it will incresce the next digit. Then what we should care about is to traverse the linked list and check whether it’s null pointer.</p>
<p><strong>Solution:</strong></p>
<pre><code>public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    int num1 = 0;
    int num2 = 0;
    int sum = 0;
    int flag = 0;

    if (l1 != null){
        num1 = l1.val;
        l1 = l1.next;
    }
    if (l2 != null){
        num2 = l2.val;
        l2 = l2.next;
    }
    sum = (num1 + num2) % 10;
    flag = (num1 + num2) / 10;
    ListNode head = new ListNode(sum);
    ListNode p = head;

    while (l1 != null || l2 != null){
        num1 = 0;
        num2 = 0;
        if (l1 != null) {
            num1 = l1.val;
            l1 = l1.next;
        }
        if (l2 != null) {
            num2 = l2.val;
            l2 = l2.next;
        }

        sum = (num1 + num2 + flag) % 10;
        flag = (num1 + num2 + flag) / 10;
        p.next = new ListNode(sum);
        p = p.next;
    }

    if (flag == 1)
        p.next = new ListNode(1);

    return head;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse ]]>
    </summary>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Word Break(Java)]]></title>
    <link href="http://yoursite.com/2016/02/21/Leetcode-Word-Break-Java/"/>
    <id>http://yoursite.com/2016/02/21/Leetcode-Word-Break-Java/</id>
    <published>2016-02-22T01:44:47.000Z</published>
    <updated>2016-02-22T01:48:12.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p>For example, given<br>s = “leetcode”,<br>dict = [“leet”, “code”].</p>
<p>Return true because “leetcode” can be segmented as “leet code”.</p>
<p><strong>Thinking:</strong></p>
<p>This question can be solved in dynamic programming. We can get parts of the string once and check if it’s in the dictionary words and then check the left. And we can store the result of previous substring with index in the array.</p>
<p><strong>Solution:</strong></p>
<pre><code>public boolean wordBreak(String s, Set&lt;String&gt; wordDict) {
    boolean[] valid = new boolean[s.length()+1];

    valid[0] = true;

    for (int i = 1; i &lt;= s.length(); i++) {
        for (int j = i-1; j &gt;= 0; j--){
            if (valid[j] &amp;&amp; wordDict.contains(s.substring(j, i))){
                valid[i] = true;
                break;
            }
        }
    }

    return valid[s.length()];
</code></pre><p>Reference: <a href="https://leetcode.com/discuss/18904/java-implementation-using-dp-in-two-ways" target="_blank" rel="external">https://leetcode.com/discuss/18904/java-implementation-using-dp-in-two-ways</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Clone Graph(Java)]]></title>
    <link href="http://yoursite.com/2016/02/21/Leetcode-Clone-Graph-Java/"/>
    <id>http://yoursite.com/2016/02/21/Leetcode-Clone-Graph-Java/</id>
    <published>2016-02-22T00:46:04.000Z</published>
    <updated>2016-02-22T00:48:14.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.</p>
<p>OJ’s undirected graph serialization:<br>Nodes are labeled uniquely.</p>
<p>We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.<br>As an example, consider the serialized graph {0,1,2#1,2#2,2}.</p>
<p>The graph has a total of three nodes, and therefore contains three parts as separated by #.</p>
<p>First node is labeled as 0. Connect node 0 to both nodes 1 and 2.<br>Second node is labeled as 1. Connect node 1 to node 2.<br>Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.<br>Visually, the graph looks like the following:</p>
<pre><code>   1
  / \
 /   \
0 --- 2
     / \
     \_/
</code></pre><p><strong>Thinking:</strong></p>
<p>In order to clone this graph, we need to traverse the graph either using DFS or BFS. In my solution, I use DFS and graph search which will hold a HashMap to record the explored nodes.</p>
<p><strong>Solution:</strong></p>
<pre><code>HashMap&lt;Integer, UndirectedGraphNode&gt; exploredSet = new HashMap&lt;Integer, UndirectedGraphNode&gt;();
public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
    return clone(node);
}

private UndirectedGraphNode clone(UndirectedGraphNode node){
    if (node == null) return null;
    UndirectedGraphNode newNode = new UndirectedGraphNode(node.label);

    exploredSet.put(node.label, newNode);

    for (UndirectedGraphNode n: node.neighbors) {
        if (exploredSet.containsKey(n.label)) {
            newNode.neighbors.add(exploredSet.get(n.label));
        } else {
            newNode.neighbors.add(clone(n));
        }
    }

    return newNode;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.</p>
<p>]]>
    </summary>
    
      <category term="Graph, DFS, BFS" scheme="http://yoursite.com/tags/Graph-DFS-BFS/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Additive Number(Java)]]></title>
    <link href="http://yoursite.com/2016/02/21/Leetcode-Additive-Number-Java/"/>
    <id>http://yoursite.com/2016/02/21/Leetcode-Additive-Number-Java/</id>
    <published>2016-02-22T00:23:12.000Z</published>
    <updated>2016-02-22T00:27:17.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Additive number is a string whose digits can form additive sequence.</p>
<p>A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.</p>
<p>For example:<br>“112358” is an additive number because the digits can form an additive sequence: 1, 1, 2, 3, 5, 8.</p>
<p>1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8<br>“199100199” is also an additive number, the additive sequence is: 1, 99, 100, 199.<br>1 + 99 = 100, 99 + 100 = 199<br>Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.</p>
<p>Given a string containing only digits ‘0’-‘9’, write a function to determine if it’s an additive number.</p>
<p>Follow up:<br>How would you handle overflow for very large input integers?</p>
<p><strong>Thinking:</strong></p>
<p>I noticed that it’s only different in the first time in the iteration becuase we know nothing about the first element. But when found it, we can use the previous two elements to check the next one. So in the first function, we enumerate the first two elements, and check the rest string if it’s valid recursively.</p>
<p><strong>Solution:</strong></p>
<pre><code>public boolean isAdditiveNumber(String num) {

    int len = num.length();

    long num1 = 0;
    long num2 = 0;
    //find the first two elements first
    for (int i = 1; 2*i+1 &lt;= len; i++){
        for (int j = 1; Math.max(i, j) &lt;= len-i-j; j++){
            if (num.charAt(0) == &apos;0&apos; &amp;&amp; i &gt; 1)    return false;//if first char is 0, then it only can be 0
            num1 = Long.parseLong(num.substring(0, i));
            if (num.charAt(i) == &apos;0&apos; &amp;&amp; j &gt; 1)    break;//if second element start with 0, then it only can be 0
            num2 = Long.parseLong(num.substring(i, i+j));
            if (isValid(num1, num2, i+j, num))//check the rest recursively
                return true;
        }
    }

    return false;
}

private boolean isValid(long i, long j, int start, String num){
    if (start == num.length())    return true;//no rest chars left, success
    if (num.charAt(start) == &apos;0&apos;)    return false;
    long sum = 0;
    for (int idx = start+1; idx &lt;= num.length(); idx++){
        sum = Long.parseLong(num.substring(start, idx));
        if (sum - i &gt; j)
            return false;
        if (sum - i == j)
            return isValid(j, sum, idx, num);
    }
    return false;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Additive number is a string whose digits can form additive sequence.</p>
<p>A valid additive sequence s]]>
    </summary>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Coin Change(Java)]]></title>
    <link href="http://yoursite.com/2016/02/14/Leetcode-Coin-Change-Java/"/>
    <id>http://yoursite.com/2016/02/14/Leetcode-Coin-Change-Java/</id>
    <published>2016-02-15T00:11:50.000Z</published>
    <updated>2016-02-15T00:17:51.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p>
<p>Example 1:<br>coins = [1, 2, 5], amount = 11<br>return 3 (11 = 5 + 5 + 1)</p>
<p>Example 2:<br>coins = [2], amount = 3<br>return -1.</p>
<p>Note:<br>You may assume that you have an infinite number of each kind of coin.</p>
<p><strong>Thinking:</strong></p>
<p>In order to solve this problem, we can use dp which check whether choose current coin to make sure it’s minimum. But using function recursively will waste a lot of time. So we need to use extra space avoiding waste time. Then, we should build up a dp array accroding to the amount of money. Then update the dp value of different amout from zero to the target amout. The DP expression is: dp[i + coins[j]] = Math.min(dp[i + coins[j]], dp[i] + 1)</p>
<p><strong>Solution:</strong></p>
<pre><code>public int coinChange(int[] coins, int amount) {
    int dp[] = new int[amount + 1];
    for (int i = 1; i &lt;= amount; i++) dp[i] = Integer.MAX_VALUE-1;
    for (int i = 0; i &lt;= amount; i++) {
        for (int j = 0; j &lt; coins.length; j++) {
            if (i + coins[j] &lt;= amount)
                dp[i + coins[j]] = Math.min(dp[i + coins[j]], dp[i] + 1);
        }
    }
    return dp[amount] == Integer.MAX_VALUE-1 ? -1 : dp[amount];
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>You are given coins of different denominations and a total amount of money amount. Write a function to ]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Some basic problems]]></title>
    <link href="http://yoursite.com/2016/02/13/Some-basic-problems/"/>
    <id>http://yoursite.com/2016/02/13/Some-basic-problems/</id>
    <published>2016-02-13T23:55:10.000Z</published>
    <updated>2016-02-13T23:56:22.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li>Hanoi:</li>
</ol>
<p><img src="http://my.csdn.net/uploads/201204/23/1335186818_5426.jpg" alt=""></p>
<pre><code>public  void move(int n,char a,char b,char c){  

    if(n==1){  
        System.out.println(&quot;move from &quot;+a+&quot; to &quot;+c);  
    }else{  
        move(n-1, a,c,b);  
        move(1, a, b, c);  
        move(n-1, b, a, c);  
    }  
}  
</code></pre><ol>
<li>Queue:</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<ol>
<li>Hanoi:</li>
</ol>
<p><img src="http://my.csdn.net/uploads/201204/23/1335186818_5426.jpg" alt=""></p>
<pre><code>public  void move(i]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Some thoughts about interview]]></title>
    <link href="http://yoursite.com/2016/02/13/Some-thoughts-about-interview/"/>
    <id>http://yoursite.com/2016/02/13/Some-thoughts-about-interview/</id>
    <published>2016-02-13T22:52:22.000Z</published>
    <updated>2016-02-14T00:01:24.000Z</updated>
    <content type="html"><![CDATA[<p>These days, I have been asked by some questions in interviews. These are not quite difficult questions, but I suppose I didn’t behavior well. There are some reasons I think, and I have to improve it:</p>
<ol>
<li>I am not familiar with the simple and basic question so that I’m not very sure about the solution’s correctness and I have to review it again and again.</li>
<li>My code is not so effienct and some of the interviewers had to remind me that. That’s really terrible but I think they are very nice to let me know that.</li>
<li>My code is not so clean because I didn’t keep a clean mind that time. I suppose it’s kind of nervous that time though I didn’t realize that and I want to solve that problem too hurry. I need to relax my minds next time.</li>
<li>What’s worse, I didn’t have nice communication with interviewers. Because of my bad English and bad preperation for interview. Sorry about that.</li>
</ol>
<p>And below are some questions I have to review:</p>
<ol>
<li>How to realize a queue or stack using array or linkedlist</li>
<li>Binary search and whenever mentioning the sorted array, I think it should come into my mind immediately the binary search</li>
<li>Graph theory about the DFS and BFS</li>
<li>What’s difference between .equals and == in Java</li>
<li>Heap and stack in java</li>
<li>Some detials and desing thoughts of my projects</li>
<li>ood  object oriented design principles (<a href="https://scotch.io/bar-talk/s-o-l-i-d-the-first-five-principles-of-object-oriented-design" target="_blank" rel="external">https://scotch.io/bar-talk/s-o-l-i-d-the-first-five-principles-of-object-oriented-design</a>)</li>
<li>The comparasion between the methods of shortest path (<a href="http://developer.51cto.com/art/201105/262170.htm" target="_blank" rel="external">http://developer.51cto.com/art/201105/262170.htm</a>)</li>
<li>Hanoi (<a href="http://blog.csdn.net/zhutulang/article/details/7491390" target="_blank" rel="external">http://blog.csdn.net/zhutulang/article/details/7491390</a>)</li>
<li>Maze (<a href="http://baobaoyangzhou.blog.163.com/blog/static/11783125020104147195273/" target="_blank" rel="external">http://baobaoyangzhou.blog.163.com/blog/static/11783125020104147195273/</a>)</li>
<li>The realization of DFS not using recursive (<a href="http://blog.csdn.net/lalor/article/details/6845788" target="_blank" rel="external">http://blog.csdn.net/lalor/article/details/6845788</a>) which use stack</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>These days, I have been asked by some questions in interviews. These are not quite difficult questions, but I suppose I didn’t behavior w]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Majority Element II(Java)]]></title>
    <link href="http://yoursite.com/2016/02/10/Leetcode-Majority-Element-II-Java/"/>
    <id>http://yoursite.com/2016/02/10/Leetcode-Majority-Element-II-Java/</id>
    <published>2016-02-11T02:32:38.000Z</published>
    <updated>2016-02-11T02:46:22.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space.</p>
<p>Hint:</p>
<p>How many majority elements could it possibly have?</p>
<p><strong>Thinking:</strong></p>
<p>This question is similar with Majority Element which can be solved by Boyer–Moore majority vote algorithm.</p>
<p><strong>Solution:</strong></p>
<pre><code>public List&lt;Integer&gt; majorityElement(int[] nums) {
    List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
    int count1 = 0, count2 = 0, can1 = 0, can2 = 1;

    for (int num: nums){
        if (num == can1)
            count1++;
        else if (num == can2)
            count2++;
        else if (count1 == 0){
            can1 = num;
            count1 = 1;
        }
        else if (count2 == 0){
            can2 = num;
            count2 = 1;
        }
        else{
            count1--;
            count2--;
        }
    }
    count1 = 0;
    count2 = 0;
    for (int num: nums){
        if (num == can1)
            count1++;
        else if (num == can2)
            count2++;
    }

    if (count1 &gt; nums.length / 3)
        res.add(can1);
    if (count2 &gt; nums.length / 3 &amp;&amp; can1 != can2)
        res.add(can2);

    return res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm ]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Implement Trie (Prefix Tree)(Java)]]></title>
    <link href="http://yoursite.com/2016/02/10/Leetcode-Implement-Trie-Prefix-Tree-Java/"/>
    <id>http://yoursite.com/2016/02/10/Leetcode-Implement-Trie-Prefix-Tree-Java/</id>
    <published>2016-02-11T01:06:45.000Z</published>
    <updated>2016-02-11T01:08:44.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Implement a trie with insert, search, and startsWith methods.</p>
<p>Note:<br>You may assume that all inputs are consist of lowercase letters a-z.</p>
<p><strong>Thinking:</strong></p>
<p>I assume every node has no val, but edges do. So I keep a HashMap for everynode. What’s more, in order to determine whether this node is a leave, I add another boolean value.</p>
<p><strong>Solution:</strong></p>
<pre><code>import java.util.HashMap;

class TrieNode {
    HashMap&lt;Character, TrieNode&gt; edges = new HashMap&lt;Character, TrieNode&gt;();
    boolean leave = false;
    // Initialize your data structure here.
    public TrieNode() {
    }
}

public class Trie {
    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    // Inserts a word into the trie.
    public void insert(String word) {
        TrieNode cur = root;
        for (char c: word.toCharArray()){
            if (!cur.edges.containsKey(c)){
                TrieNode newNode = new TrieNode();
                cur.edges.put(c, newNode);
                cur = newNode;

            }
            else {
                cur = cur.edges.get(c);
            }
        }
        cur.leave = true;
    }

    // Returns if the word is in the trie.
    public boolean search(String word) {
        TrieNode cur = root;
        for (char c: word.toCharArray()){
            if (!cur.edges.containsKey(c)){
                return false;
            }
            else{
                cur = cur.edges.get(c);
            }
        }
        return cur.leave;
    }

    // Returns if there is any word in the trie
    // that starts with the given prefix.
    public boolean startsWith(String prefix) {
        TrieNode cur = root;
        for (char c: prefix.toCharArray()){
            if (!cur.edges.containsKey(c)){
                return false;
            }
            else{
                cur = cur.edges.get(c);
            }
        }
        return true;
    }
}

// Your Trie object will be instantiated and called as such:
// Trie trie = new Trie();
// trie.insert(&quot;somestring&quot;);
// trie.search(&quot;key&quot;);
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Implement a trie with insert, search, and startsWith methods.</p>
<p>Note:<br>You may assume that all i]]>
    </summary>
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
      <category term="Trie" scheme="http://yoursite.com/tags/Trie/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Sqrt(x)(Java)]]></title>
    <link href="http://yoursite.com/2016/02/10/Leetcode-Sqrt-x-Java/"/>
    <id>http://yoursite.com/2016/02/10/Leetcode-Sqrt-x-Java/</id>
    <published>2016-02-11T00:33:22.000Z</published>
    <updated>2016-02-11T00:34:52.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Implement int sqrt(int x).</p>
<p>Compute and return the square root of x.</p>
<p><strong>Thinking:</strong></p>
<p>We can get the answer using bianry search from the range of integer.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int mySqrt(int x) {
    if ( x &lt;= 1 )
        return x;
    int low = 1;
    int high = Integer.MAX_VALUE;
    while (true){
        int mid = low + (high - low) / 2; //in order to avoid overflow
        if (mid &gt; x / mid){
            high = mid - 1;
        }else{
            if ( (mid+1) &gt; x/(mid+1))
                return mid;
            low = mid + 1;
        }
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Implement int sqrt(int x).</p>
<p>Compute and return the square root of x.</p>
<p><strong>Thinking:</st]]>
    </summary>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Course Schedule(Java)]]></title>
    <link href="http://yoursite.com/2016/02/10/Leetcode-Course-Schedule-Java/"/>
    <id>http://yoursite.com/2016/02/10/Leetcode-Course-Schedule-Java/</id>
    <published>2016-02-10T23:16:31.000Z</published>
    <updated>2016-02-11T00:03:03.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>There are a total of n courses you have to take, labeled from 0 to n - 1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p>
<p>For example:</p>
<p>2, [[1,0]]<br>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.</p>
<p>2, [[1,0],[0,1]]<br>There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</p>
<p>Note:<br>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.</p>
<p>click to show more hints.</p>
<p>Hints:<br>This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.<br>Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.<br>Topological sort could also be done via BFS.</p>
<p><strong>Thinking:</strong></p>
<p>We can search it from a arbitary node, can search by DFS. If there is a cycle, we will meet the visited nodes once DFS. So we need a array to hold the visited record. By the way, if we want a topological sort, we can hold a current value which is number of nodes initially and decrese one only when meet a sink node.</p>
<p>For BFS, we can find the nodes whose indegree or outdegree is zero, and search from them. If there is a cycle, the number of nodes searched will less than the exact number because in a cycle no nodes’ indegree or outdegree is zero.</p>
<p><strong>Solution:</strong></p>
<p>DFS:</p>
<pre><code>public boolean canFinish(int numCourses, int[][] prerequisites) {
    if (numCourses &lt;= 1)
        return true;
    ArrayList&lt;HashSet&lt;Integer&gt;&gt; edges = new ArrayList&lt;HashSet&lt;Integer&gt;&gt;(numCourses);
    boolean[] visited = new boolean[numCourses];

    for (int i = 0; i &lt; numCourses; i++)
        edges.add(new HashSet&lt;Integer&gt;());

    for (int[] pre: prerequisites){
        edges.get(pre[0]).add(pre[1]);
    }

    for (int i = 0; i &lt; numCourses; i++){
        if (edges.get(i).size() != 0)
            if (!dfs(edges, i, visited))
                return false;
    }

    return true;
}

private boolean dfs(ArrayList&lt;HashSet&lt;Integer&gt;&gt; edges, int i, boolean[] visited){
    if (visited[i] == true)
        return false;
    visited[i] = true;
    while (edges.get(i).size() != 0){
        int j = edges.get(i).iterator().next();

        if (!dfs(edges, j, visited))
            return false;

        edges.get(i).remove(j);
    }
    visited[i] = false; //there is a cycle only when once DFS, so we change it back when onece DFS is finished
    return true;
}
</code></pre><p>BFS:</p>
<pre><code>    public boolean canFinishBFS(int numCourses, int[][] prerequisites) {
    if (numCourses &lt;= 1)
        return true;
    ArrayList&lt;HashSet&lt;Integer&gt;&gt; edges = new ArrayList&lt;HashSet&lt;Integer&gt;&gt;(numCourses);
    int[] inDegree = new int[numCourses];
    Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;();
    int count = 0;

    for (int i = 0; i &lt; numCourses; i++)
        edges.add(new HashSet&lt;Integer&gt;());

    for (int[] pre: prerequisites){
        if (!edges.get(pre[0]).contains(pre[1])){
            edges.get(pre[0]).add(pre[1]);
            inDegree[pre[1]]++;
        }
    }

    for (int i = 0; i &lt; inDegree.length; i++)
        if (inDegree[i] == 0)
            q.add(i);

    while (!q.isEmpty()){
        int i = q.poll();
        count++;
        while (edges.get(i).size() != 0){
            int j = edges.get(i).iterator().next();
            if (--inDegree[j] == 0)
                q.add(j);
            edges.get(i).remove(j);
        }
    }

    return count == numCourses;
}
</code></pre><p>Simpler and more concise BFS solution:</p>
<p>Reference: <a href="https://leetcode.com/discuss/35578/easy-bfs-topological-sort-java" target="_blank" rel="external">https://leetcode.com/discuss/35578/easy-bfs-topological-sort-java</a></p>
<pre><code>public boolean canFinish(int numCourses, int[][] prerequisites) {
    int[][] matrix = new int[numCourses][numCourses]; // i -&gt; j
    int[] indegree = new int[numCourses];

    for (int i=0; i&lt;prerequisites.length; i++) {
        int ready = prerequisites[i][0];
        int pre = prerequisites[i][1];
        if (matrix[pre][ready] == 0)
            indegree[ready]++; //duplicate case
        matrix[pre][ready] = 1;
    }

    int count = 0;
    Queue&lt;Integer&gt; queue = new LinkedList();
    for (int i=0; i&lt;indegree.length; i++) {
        if (indegree[i] == 0) queue.offer(i);
    }
    while (!queue.isEmpty()) {
        int course = queue.poll();
        count++;
        for (int i=0; i&lt;numCourses; i++) {
            if (matrix[course][i] != 0) {
                if (--indegree[i] == 0)
                    queue.offer(i);
            }
        }
    }
    return count == numCourses;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>There are a total of n courses you have to take, labeled from 0 to n - 1.</p>
<p>Some courses may have ]]>
    </summary>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Graph" scheme="http://yoursite.com/tags/Graph/"/>
    
      <category term="Topological Sort" scheme="http://yoursite.com/tags/Topological-Sort/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Minimum Height Trees(Java)]]></title>
    <link href="http://yoursite.com/2016/02/09/Leetcode-Minimum-Height-Trees-Java/"/>
    <id>http://yoursite.com/2016/02/09/Leetcode-Minimum-Height-Trees-Java/</id>
    <published>2016-02-10T07:10:01.000Z</published>
    <updated>2016-02-10T07:13:33.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.</p>
<p>Format<br>The graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels).</p>
<p>You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.</p>
<p>Example 1:</p>
<p>Given n = 4, edges = [[1, 0], [1, 2], [1, 3]]</p>
<pre><code>  0
  |
  1
 / \
2   3
</code></pre><p>return [1]</p>
<p>Example 2:</p>
<p>Given n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</p>
<pre><code>0  1  2
 \ | /
   3
   |
   4
   |
   5
</code></pre><p>return [3, 4]</p>
<p>Hint:</p>
<p>How many MHTs can a graph have at most?<br>Note:</p>
<p>(1) According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.”</p>
<p>(2) The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.</p>
<p><strong>Thinking:</strong></p>
<p>We should track the path from every leaves until there are only one or two nodes left. In other words, in the middle of the graph will be the root of the minimum height tree.</p>
<p><strong>Solution:</strong></p>
<pre><code>public List&lt;Integer&gt; findMinHeightTrees(int n, int[][] edges) {
    if (n == 1){
        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
        res.add(0);
        return res;
    }
    List&lt;Integer&gt; leaves = new ArrayList&lt;Integer&gt;();
    List&lt;Set&lt;Integer&gt;&gt; adj = new ArrayList&lt;Set&lt;Integer&gt;&gt;(n);
    for (int i = 0; i &lt; n; i++)
        adj.add(new HashSet&lt;Integer&gt;());
    for (int[] edge: edges){
        adj.get(edge[0]).add(edge[1]);
        adj.get(edge[1]).add(edge[0]);
    }
    for (int i = 0; i &lt; n; i++){
        if (adj.get(i).size() == 1)
            leaves.add(i);
    }

    while (n &gt; 2){
        n -= leaves.size();
        List&lt;Integer&gt; newLeaves = new ArrayList&lt;Integer&gt;();
        for (int i: leaves){
            int j = adj.get(i).iterator().next();
            adj.get(j).remove(i);
            if (adj.get(j).size() == 1)
                newLeaves.add(j);
        }
        leaves = newLeaves;
    }

    return leaves;
}
</code></pre><p>Reference:<a href="https://leetcode.com/discuss/71763/share-some-thoughts" target="_blank" rel="external">https://leetcode.com/discuss/71763/share-some-thoughts</a></p>
<p>My previous code(LTE):</p>
<pre><code>public List&lt;Integer&gt; findMinHeightTrees(int n, int[][] edges) {
    List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
    int min = Integer.MAX_VALUE;
    int res1 = -1;
    int res2 = -1;

    for (int i = 0; i &lt; n; i++){
        int temp = bfs(n, i, edges);
        if (temp &lt; min){
            min = temp;
            res1 = i;
        }
        else if (temp == min){
            res2 = i;
        }
    }

    if (res1 != -1)
        res.add(res1);
    if (res2 != -1)
        res.add(res2);

    return res;
}

private int bfs(int n, int i, int[][] edges){
    int height = 0;
    boolean[] used = new boolean[edges.length];
    Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;();
    q.add(i);

    while (!q.isEmpty()){
        int num = q.size();
        while (num &gt; 0){
            int temp = q.poll();
            for (int j = 0; j &lt; edges.length; j++){
                if (edges[j][0] == temp || edges[j][1] == temp){
                    if (used[j] == false){
                        if (edges[j][0] == temp)
                            q.add(edges[j][1]);
                        else
                            q.add(edges[j][0]);
                        used[j] = true;
                    }
                }
            }
            num--;
        }
        height++;
    }

    return height;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>For a undirected graph with tree characteristics, we can choose any node as the root. The result graph ]]>
    </summary>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="Graph" scheme="http://yoursite.com/tags/Graph/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Next Permutation(Java)]]></title>
    <link href="http://yoursite.com/2016/02/09/Leetcode-Next-Permutation-Java/"/>
    <id>http://yoursite.com/2016/02/09/Leetcode-Next-Permutation-Java/</id>
    <published>2016-02-10T03:38:47.000Z</published>
    <updated>2016-02-12T05:44:37.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place, do not allocate extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
<pre><code>1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
</code></pre><p><strong>Thinking:</strong></p>
<p>The method can be described as below:</p>
<p><img src="http://4.bp.blogspot.com/-4zN0u5JG0vs/UN0xPEkP5yI/AAAAAAAAG9Q/O48ZfwB1i_c/s640/Picture4.png" alt=""></p>
<p><strong>Solution:</strong></p>
<pre><code>public void nextPermutation(int[] nums) {
    if (nums == null || nums.length == 0)
        return;
    int i = nums.length - 2;
    while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i+1]){
        i--;
    }

    if (i == -1){
        reverse(nums, 0, nums.length-1);
        return;
    }

    int j = i+1;
    while (j &lt; nums.length &amp;&amp; nums[j] &gt; nums[i]){
        j++;
    }
    j--;
    swap(nums, i, j);
    reverse(nums, i+1, nums.length-1);

    return;
}
private void swap(int[] nums, int i, int j){
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
private void reverse(int[] nums, int i, int j){
    while (i &lt; j){
        swap(nums, i++, j--);
    }
}
</code></pre><p>Reference:<a href="http://fisherlei.blogspot.com/2012/12/leetcode-next-permutation.html" target="_blank" rel="external">http://fisherlei.blogspot.com/2012/12/leetcode-next-permutation.html</a><br><a href="http://www.cnblogs.com/springfor/p/3896245.html" target="_blank" rel="external">http://www.cnblogs.com/springfor/p/3896245.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutatio]]>
    </summary>
    
  </entry>
  
</feed>
