<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Martin's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-02-01T06:15:05.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Martin]]></name>
    <email><![CDATA[martinglory1992@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Leetcode-Kth Largest Element in an Array(Java)]]></title>
    <link href="http://yoursite.com/2016/01/31/Leetcode-Kth-Largest-Element-in-an-Array-Java/"/>
    <id>http://yoursite.com/2016/01/31/Leetcode-Kth-Largest-Element-in-an-Array-Java/</id>
    <published>2016-02-01T05:21:22.000Z</published>
    <updated>2016-02-01T06:15:05.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p>For example,<br>Given [3,2,1,5,6,4] and k = 2, return 5.</p>
<p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p>
<p><strong>Thinking:</strong></p>
<p>There are three ways to solve this problem:</p>
<ol>
<li>The first one is to build a max heap with size n, and get the top of the heap k times.</li>
<li>The second one is to build a min heap with size k, and keep the biggest top k elements of this array. Finally, get the top of it.</li>
<li>The third one is to use a method called quickselect which uses function partition. It first use a pivot to split the array into two parts, then accroding to this index, choose which part to select.</li>
</ol>
<p><strong>Solution:</strong></p>
<p>Max heap:</p>
<pre><code>public int findKthLargest1(int[] nums, int k) {
    int len = nums.length;
    PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;Integer&gt;(len, new HeapComparator());
    for (int i = 0; i &lt; len; i++){
        heap.add(nums[i]);
    }
    for (int i = 0; i &lt; k-1; i++){
        heap.poll();
    }
    return heap.peek();
}

class HeapComparator implements Comparator {

    @Override
    public int compare(Object o1, Object o2) {
        // TODO Auto-generated method stub
        int i1 = (int)o1;
        int i2 = (int)o2;
        if (i1 &gt; i2)
            return -1;
        else if (i1 == i2)
            return 0;
        else
            return 1;
    }

}
</code></pre><p>Min heap:</p>
<pre><code>public int findKthLargest2(int[] nums, int k) {
    int len = nums.length;
    PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;Integer&gt;(k);
    for (int i = 0; i &lt; k; i++){
        heap.add(nums[i]);
    }
    for (int i = k; i &lt; len; i++){
        if (nums[i] &gt; heap.peek()){
            heap.poll();
            heap.add(nums[i]);
        }
    }
    return heap.peek();
}
</code></pre><p>Quickselect:</p>
<pre><code>public int findKthLargest3(int[] nums, int k) {
    int len = nums.length;
    return quickselect(nums, 0, len-1, k);
}

private int quickselect(int[] nums, int left, int right, int k){
    int pivotIndex = partition(nums, left, right, left);
    if (pivotIndex == k-1){
        return nums[pivotIndex];
    }
    else if(pivotIndex &lt; k){
        return quickselect(nums, pivotIndex+1, right, k);
    }
    else{
        return quickselect(nums, left, pivotIndex-1, k);
    }
}

private int partition(int[] nums, int left, int right, int index){
    int pivotvalue = nums[index];
    int storeindex = left;
    nums[index] = nums[right];
    for (int i = left; i &lt; right; i++){
        if (nums[i] &gt; pivotvalue){
            int temp = nums[i];
            nums[i] = nums[storeindex];
            nums[storeindex++] = temp;
        }
    }
    nums[right] = nums[storeindex];
    nums[storeindex] = pivotvalue;
    return storeindex;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorte]]>
    </summary>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
      <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Permutations II(Java)]]></title>
    <link href="http://yoursite.com/2016/01/31/Leetcode-Permutations-II-Java/"/>
    <id>http://yoursite.com/2016/01/31/Leetcode-Permutations-II-Java/</id>
    <published>2016-02-01T01:10:24.000Z</published>
    <updated>2016-02-01T01:26:48.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p>For example,<br>[1,1,2] have the following unique permutations:<br>[1,1,2], [1,2,1], and [2,1,1].</p>
<p><strong>Thinking:</strong></p>
<p>It’s very similiar with the question permutation, we should use backtracing to go through all the possibilities. For example, we pick the first element of the array, and get the permutation of the rest of this array, and put the first element in every possible position. The only difference bewteen the permutation is that we don’t allow duplicate. We can use hashset to solve this problem.</p>
<p>By the way, I made a mistake this time which I used to make. It’s that in the loop of this:</p>
<pre><code>for (List&lt;Integer&gt; list: backtracing(nums, index+1)){
    for (int i = 0; i &lt;= list.size(); i++){
        List&lt;Integer&gt; tempres = new ArrayList&lt;Integer&gt;(list);
        tempres.add(i, nums[index]);
        tres.add(tempres);
    }
}
</code></pre><p>I shouldn’t use the temporary variable list to operate, because<br>1) the size of it will change;<br>2) we should use it several times instead of once.<br>Then that means we should build another temporary variable. In this case, it’s tempres.</p>
<p><strong>Solution:</strong></p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {
    return backtracing(nums, 0);
}

private List&lt;List&lt;Integer&gt;&gt; backtracing(int[] nums, int index) {
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    HashSet&lt;List&lt;Integer&gt;&gt; tres = new HashSet&lt;List&lt;Integer&gt;&gt;();
    int len = nums.length;

    if (index &gt;= len){
        return res;
    }

    if (index == len - 1){
        List&lt;Integer&gt; tempres = new ArrayList&lt;Integer&gt;();
        tempres.add(nums[index]);
        res.add(tempres);
        return res;
    }

    for (List&lt;Integer&gt; list: backtracing(nums, index+1)){
        for (int i = 0; i &lt;= list.size(); i++){
            List&lt;Integer&gt; tempres = new ArrayList&lt;Integer&gt;(list);
            tempres.add(i, nums[index]);
            tres.add(tempres);
        }
    }

    res.addAll(tres);
    return res;
}
</code></pre><p>There is another solution is much faster than me. Because it use extra space to record which element is used and use sort to reduce the extra cost to make sure unique. What’s more, the process of adding first and removing after dfs is usually used by people. I suppose I should learn from it.</p>
<p>Code:</p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    if(nums==null || nums.length==0) return res;
    boolean[] used = new boolean[nums.length];
    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
    Arrays.sort(nums);
    dfs(nums, used, list, res);
    return res;
}

public void dfs(int[] nums, boolean[] used, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; res){
    if(list.size()==nums.length){
        res.add(new ArrayList&lt;Integer&gt;(list));
        return;
    }
    for(int i=0;i&lt;nums.length;i++){
        if(used[i]) continue;
        if(i&gt;0 &amp;&amp;nums[i-1]==nums[i] &amp;&amp; !used[i-1]) continue;
        used[i]=true;
        list.add(nums[i]);
        dfs(nums,used,list,res);
        used[i]=false;
        list.remove(list.size()-1);
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</]]>
    </summary>
    
      <category term="Backtracing" scheme="http://yoursite.com/tags/Backtracing/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Algorithm Note]]></title>
    <link href="http://yoursite.com/2016/01/31/Algorithm-Note/"/>
    <id>http://yoursite.com/2016/01/31/Algorithm-Note/</id>
    <published>2016-02-01T00:21:38.000Z</published>
    <updated>2016-02-01T00:21:38.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[VIM]]></title>
    <link href="http://yoursite.com/2016/01/30/VIM/"/>
    <id>http://yoursite.com/2016/01/30/VIM/</id>
    <published>2016-01-31T06:54:24.000Z</published>
    <updated>2016-01-31T07:05:27.000Z</updated>
    <content type="html"><![CDATA[<p>一、打开文件、保存、关闭文件(vi命令模式下使用)<br>:w       //保存文件<br>:w vpser.net //保存至vpser.net文件<br>:q          //退出编辑器，如果文件已修改请使用下面的命令<br>:q!        //退出编辑器，且不保存<br>:wq         //退出编辑器，且保存文件</p>
<p>二、插入文本或行(vi命令模式下使用，执行下面命令后将进入插入模式，按ESC键可退出插入模式)<br>一般使用i<br>a      //在当前光标位置的右边添加文本<br>i       //在当前光标位置的左边添加文本<br>A     //在当前行的末尾位置添加文本<br>I      //在当前行的开始处添加文本(非空字符的行首)<br>O     //在当前行的上面新建一行<br>o     //在当前行的下面新建一行<br>R    //替换(覆盖)当前光标位置及后面的若干文本<br>J    //合并光标所在行及下一行为一行(依然在命令模式)</p>
<p>三、移动光标(vi命令模式下使用)<br>1、使用上下左右方向键</p>
<p>2、命令模式下：h   向左、j   向下 、k   向上、l  向右。<br>空格键 向右、Backspace  向左、Enter  移动到下一行首、-  移动到上一行首。</p>
<p>四、删除、恢复字符或行(vi命令模式下使用)<br>x         //删除当前字符<br>nx         //删除从光标开始的n个字符<br>dd      //删除当前行<br>ndd   //向下删除当前行在内的n行<br>u       //撤销上一步操作<br>U      //撤销对当前行的所有操作</p>
<p>五、搜索(vi命令模式下使用)<br>/vpser     //向光标下搜索vpser字符串，vpser可以是正则表达式<br>?vpser     //向光标上搜索vpser字符串<br>n           //向下搜索前一个搜素动作<br>N         //向上搜索前一个搜索动作</p>
<p>*(#)      //当光标停留在某个单词上时, 输入这条命令表示查找与该单词匹配的下(上)一个单词. 同样, 再输入 n 查找下一个匹配处, 输入 N 反方向查找.</p>
<p>g*(g#)        //此命令与上条命令相似, 只不过它不完全匹配光标所在处的单词, 而是匹配包含该单词的所有字符串.</p>
<p>六、跳至指定行(vi命令模式下使用)<br>n+        //向下跳n行<br>n-         //向上跳n行<br>nG        //跳到行号为n的行<br>G           //跳至文件的底部</p>
<p>七、设置行号(vi命令模式下使用)<br>:set  nu     //显示行号<br>:set nonu    //取消显示行号</p>
<p>八、复制、粘贴(vi命令模式下使用)<br>yy    //将当前行复制到缓存区，也可以用 “ayy 复制，”a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务。<br>nyy   //将当前行向下n行复制到缓冲区，也可以用 “anyy 复制，”a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务。<br>yw    //复制从光标开始到词尾的字符。<br>nyw   //复制从光标开始的n个单词。<br>y^      //复制从光标到行首的内容。  VPS侦探<br>y$      //复制从光标到行尾的内容。<br>p        //粘贴剪切板里的内容在光标后，如果使用了前面的自定义缓冲区，建议使用”ap 进行粘贴。<br>P        //粘贴剪切板里的内容在光标前，如果使用了前面的自定义缓冲区，建议使用”aP 进行粘贴。</p>
<p>九、替换(vi命令模式下使用)<br>:s/old/new      //用new替换行中首次出现的old<br>:s/old/new/g         //用new替换行中所有的old<br>:n,m s/old/new/g     //用new替换从n到m行里所有的old<br>:%s/old/new/g      //用new替换当前文件里所有的old</p>
<p>十、编辑其他文件<br>:e otherfilename    //编辑文件名为otherfilename的文件。</p>
<p>十一、修改文件格式<br>:set fileformat=unix   //将文件修改为unix格式，如win下面的文本文件在linux下会出现^M。</p>
<p>十二、查找帮助<br>当你不知道怎么处理时，直接输入help可以看到帮助文档的起点，ZZ是退出或者：q，不建议使用<br>查找关于某个字母的命令 ：help x   查找关于x的命令。</p>
<p>参考：<a href="http://blog.csdn.net/chenxiaochen32/article/details/7378127" target="_blank" rel="external">http://blog.csdn.net/chenxiaochen32/article/details/7378127</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一、打开文件、保存、关闭文件(vi命令模式下使用)<br>:w       //保存文件<br>:w vpser.net //保存至vpser.net文件<br>:q          //退出编辑器，如果文件已修改请使用下面的命令<br>:q!        //退出编辑]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Palindrome Partitioning(Java)]]></title>
    <link href="http://yoursite.com/2016/01/30/Leetcode-Palindrome-Partitioning-Java/"/>
    <id>http://yoursite.com/2016/01/30/Leetcode-Palindrome-Partitioning-Java/</id>
    <published>2016-01-31T06:25:26.000Z</published>
    <updated>2016-01-31T06:51:07.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return all possible palindrome partitioning of s.</p>
<p>For example, given s = “aab”,<br>Return</p>
<pre><code>[
  [&quot;aa&quot;,&quot;b&quot;],
  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]
]
</code></pre><p><strong>Thinking:</strong></p>
<p>We should get all the possible partition, it’s obvious we should use backtracing. We partition the string from beginning, and check if it’s palindrome, then check the rest of the substring. If all the substrings are palindrome, we put them in the result. We have to notice the API of Java substring(beginIndex, endIndex) that beginIndex is inclusive but endIndex is exclusive.</p>
<p><strong>Solution:</strong></p>
<pre><code>public List&lt;List&lt;String&gt;&gt; partition(String s) {
    List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;List&lt;String&gt;&gt;();
    int len = s.length();
    if (palindrome(s)){
        List&lt;String&gt; tempres = new ArrayList&lt;String&gt;();
        tempres.add(s);
        res.add(tempres);
    }
    for (int i = 1; i &lt; len; i++){
        if (palindrome(s.substring(0, i))){
            for (List&lt;String&gt; list: partition(s.substring(i))){
                list.add(0, s.substring(0, i));
                res.add(list);
            }
        }
    }
    return res;
}

private boolean palindrome(String s){
    int len = s.length();
    int left = 0;
    int right = len - 1;
    while (left &lt; right){
        if (s.charAt(left) != s.charAt(right)){
            return false;
        }
        left++;
        right--;
    }
    return true;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return]]>
    </summary>
    
      <category term="Backtracing" scheme="http://yoursite.com/tags/Backtracing/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Binary Tree Zigzag Level Order Traversal(Java)]]></title>
    <link href="http://yoursite.com/2016/01/30/Leetcode-Binary-Tree-Zigzag-Level-Order-Traversal-Java/"/>
    <id>http://yoursite.com/2016/01/30/Leetcode-Binary-Tree-Zigzag-Level-Order-Traversal-Java/</id>
    <published>2016-01-31T05:21:37.000Z</published>
    <updated>2016-01-31T05:29:07.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree {3,9,20,#,#,15,7},</p>
<pre><code>  3
 / \
9  20
  /  \
 15   7
</code></pre><p>return its zigzag level order traversal as:</p>
<pre><code>[
  [3],
  [20,9],
  [15,7]
]
</code></pre><p><strong>Thinking:</strong></p>
<p>It’s a BFS problem. It’s fine if we need use queue, but because we have to record as a zigzag order, it’s more efficient to use stack. What’s more, we should to notice the order of left and right child.</p>
<p><strong>Solution:</strong></p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) {
    int flag = 0;
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();
    Stack&lt;TreeNode&gt; tempstack = new Stack&lt;TreeNode&gt;();
    if (root == null)
        return res;
    stack.add(root);
    while (!stack.isEmpty() || !tempstack.isEmpty()){
        tempstack = new Stack&lt;TreeNode&gt;();
        List&lt;Integer&gt; tempres = new ArrayList&lt;Integer&gt;();
        while (!stack.isEmpty()){
            TreeNode node = stack.pop();
            tempres.add(node.val);
            if (flag == 0){
                if (node.left != null){
                    tempstack.add(node.left);
                }
                if (node.right != null){
                    tempstack.add(node.right);
                }
            }
            else{
                if (node.right != null){
                    tempstack.add(node.right);
                }
                if (node.left != null){
                    tempstack.add(node.left);
                }
            }

        }
        res.add(tempres);
        stack.addAll(tempstack);
        flag ^= 1;
    }

    return res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to ri]]>
    </summary>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-4Sum(Java)]]></title>
    <link href="http://yoursite.com/2016/01/30/Leetcode-4Sum-Java/"/>
    <id>http://yoursite.com/2016/01/30/Leetcode-4Sum-Java/</id>
    <published>2016-01-31T04:33:10.000Z</published>
    <updated>2016-01-31T04:42:45.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>
<p>Note:<br>Elements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d)<br>The solution set must not contain duplicate quadruplets.<br>    For example, given array S = {1 0 -1 0 -2 2}, and target = 0.</p>
<pre><code>A solution set is:
(-1,  0, 0, 1)
(-2, -1, 1, 2)
(-2,  0, 0, 2)
</code></pre><p><strong>Thinking</strong>:</p>
<p>This questions is very similar with 2Sum and 3Sum. There are several way to solve it. </p>
<p><strong>Solution1:</strong></p>
<p>The most common method may use the method of 3Sum, and do that n times.</p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; fourSum1(int[] nums, int target) {
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    Set&lt;List&lt;Integer&gt;&gt; tres = new HashSet&lt;List&lt;Integer&gt;&gt;();
    Arrays.sort(nums);
    int len = nums.length;


    for (int i = 0; i &lt; len-3; i++){
        for (int j = i+1; j &lt; len-2; j++){
            for (int k = j+1; k &lt; len-1; k++){
                int l = len-1;
                while (k &lt; l){
                    int sum = nums[i] + nums[j] + nums[k] + nums[l];
                    if (sum == target){
                        List&lt;Integer&gt; tempres = new ArrayList&lt;Integer&gt;();
                        tempres.add(nums[i]);
                        tempres.add(nums[j]);
                        tempres.add(nums[k]);
                        tempres.add(nums[l]);
                        tres.add(tempres);
                        k++;
                        l--;
                    }
                    else if (sum &gt; target){
                        l--;
                    }
                    else{
                        k++;
                    }
                    while (k &lt; l &amp;&amp; nums[k+1] == nums[k]){
                        k++;
                    }
                    while (k &lt; l &amp;&amp; nums[l-1] == nums[l]){
                        l--;
                    }
                }
            }
        }
    }

    res.addAll(tres);
    return res;
}
</code></pre><p><strong>Solution2:</strong></p>
<p>The second solution is to combine every two numbers as a pair, and make it as a 2sum problem. But for implementing this method, we have to define the data structure by ourself and implement the interface of Comparator to sort the sum of them.</p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; fourSum2(int[] nums, int target){
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    int len = nums.length;
    if (len &lt; 4)
        return res;
    Pair[] pairSum = new Pair[len*(len-1)/2];
    Set&lt;List&lt;Integer&gt;&gt; tres = new HashSet&lt;List&lt;Integer&gt;&gt;();

    int count = 0;
    for (int i = 0; i &lt; len-1; i++){
        for (int j = i+1; j &lt; len; j++){
            Pair ele = new Pair(nums[i], nums[j], i, j);
            pairSum[count++] = ele;
        }
    }
    Arrays.sort(pairSum, new SumComparator());

    int left = 0;
    int right = pairSum.length - 1;
    while (left &lt; right){
        int sum = pairSum[left].getSum() + pairSum[right].getSum();
        if (sum == target){
            int endl = left;
            int endr = right;
            while (pairSum[endl].getSum() == pairSum[endl+1].getSum() &amp;&amp; endl+1 &lt; endr){
                endl++;
            }
            while (pairSum[endr].getSum() == pairSum[endr-1].getSum() &amp;&amp; endl &lt; endr-1){
                endr--;
            }
            for (int i = left; i &lt;= endl; i++){
                for (int j = right; j&gt;= endr; j--){
                    int i1 = pairSum[i].geti();
                    int i2 = pairSum[j].geti();
                    int j1 = pairSum[i].getj();
                    int j2 = pairSum[j].getj();
                    if (i1 == i2 || i1 == j2 || j1 == i2 || j1 == j2){
                        continue;
                    }
                    int[] temp = new int[4];
                    temp[0] = pairSum[i].getN1();
                    temp[1] = pairSum[i].getN2();
                    temp[2] = pairSum[j].getN1();
                    temp[3] = pairSum[j].getN2();
                    Arrays.sort(temp);
                    List&lt;Integer&gt; tempres = new ArrayList&lt;Integer&gt;();
                    tempres.add(temp[0]);
                    tempres.add(temp[1]);
                    tempres.add(temp[2]);
                    tempres.add(temp[3]);
                    tres.add(tempres);
                }
            }
            left = endl+1;
            right = endr-1;
        }
        else if (sum &gt; target){
            right--;
        }
        else{
            left++;
        }
    }

    res.addAll(tres);
    return res;
}

class SumComparator implements Comparator{

    @Override
    public final int compare(Object o1, Object o2) {
        // TODO Auto-generated method stub
        Pair l1 = (Pair)o1;
        Pair l2 = (Pair)o2;
        if (l1.getSum() &gt; l2.getSum())
            return 1;
        else if (l1.getSum() &lt; l2.getSum())
            return -1;
        else
            return 0;
    }
}

class Pair{
    int i;
    int j;
    int n1;
    int n2;
    int sum;
    Pair(int num1, int num2, int i, int j){
        this.n1 = num1;
        this.n2 = num2;
        this.sum = num1 + num2;
        this.i = i;
        this.j = j;
    }
    public int getSum(){
        return this.sum;
    }
    public int getN1(){
        return this.n1;
    }
    public int getN2(){
        return this.n2;
    }
    public int geti(){
        return this.i;
    }
    public int getj(){
        return this.j;
    }
}
</code></pre><p>Reference: <a href="http://blog.csdn.net/linhuanmars/article/details/24826871" target="_blank" rel="external">http://blog.csdn.net/linhuanmars/article/details/24826871</a></p>
<p><strong>Solution3:</strong></p>
<p>The third method is the most efficient method. It has two loop of two points and use some method to break or return early. It really improve the performance of time running.</p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; fourSum3(int[] nums, int target) {
    List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    Arrays.sort(nums);
    int second = 0, third = 0, nexti = 0, nextj = 0;
    for(int i=0, L=nums.length; i&lt;L-3; i++) {
        if(nums[i]&lt;&lt;2 &gt; target) return list; // return immediately
        for(int j=L-1; j&gt;i+2; j--) {
            if(nums[j]&lt;&lt;2 &lt; target) break; // break immediately
            int rem = target-nums[i]-nums[j];
            int lo = i+1, hi=j-1;
            while(lo&lt;hi) {
                int sum = nums[lo] + nums[hi];
                if(sum&gt;rem) --hi;
                else if(sum&lt;rem) ++lo;
                else {
                    list.add(Arrays.asList(nums[i],nums[lo],nums[hi],nums[j]));
                    while(++lo&lt;=hi &amp;&amp; nums[lo-1]==nums[lo]) continue; // avoid duplicate results
                    while(--hi&gt;=lo &amp;&amp; nums[hi]==nums[hi+1]) continue; // avoid duplicate results
                }
            }
            while(j&gt;=1 &amp;&amp; nums[j]==nums[j-1]) --j; // skip inner loop
        }
        while(i&lt;L-1 &amp;&amp; nums[i]==nums[i+1]) ++i; // skip outer loop
    }
    return list;
}
</code></pre><p>Reference: <a href="https://leetcode.com/discuss/78276/java-little-bit-faster-than-other-common-methods-9ms-beats-95%25" target="_blank" rel="external">https://leetcode.com/discuss/78276/java-little-bit-faster-than-other-common-methods-9ms-beats-95%25</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Two Points" scheme="http://yoursite.com/tags/Two-Points/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-3Sum(Java)]]></title>
    <link href="http://yoursite.com/2016/01/28/Leetcode-3Sum-Java/"/>
    <id>http://yoursite.com/2016/01/28/Leetcode-3Sum-Java/</id>
    <published>2016-01-29T00:28:55.000Z</published>
    <updated>2016-01-29T00:32:01.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p>Note:<br>Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)<br>The solution set must not contain duplicate triplets.<br>    For example, given array S = {-1 0 1 2 -1 -4},</p>
<pre><code>A solution set is:
(-1, 0, 1)
(-1, -1, 2)
</code></pre><p><strong>Thinking:</strong></p>
<p>Sort the array first. Pick a number from the array, and use other two points to record the position of the array and determine which one should change by the sum of them. What’s more, the result set should has no duplicate, so we can use hashset here.</p>
<p><strong>Solution:</strong></p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
    int l = nums.length;
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    Set&lt;List&lt;Integer&gt;&gt; tres = new HashSet&lt;List&lt;Integer&gt;&gt;();

    if (l &lt; 3)
        return res;

    Arrays.sort(nums);

    for (int i = 0; i &lt; l-2; i++){
        int k = l-1;
        for (int j = i+1; j &lt; l; j++){
            while (j &lt; k){
                int sum = nums[i] + nums[j] + nums[k];
                if (sum == 0){
                    List&lt;Integer&gt; tempres = new ArrayList&lt;Integer&gt;();
                    tempres.add(nums[i]);
                    tempres.add(nums[j]);
                    tempres.add(nums[k]);
                    tres.add(tempres);
                    while (j &lt; k &amp;&amp; nums[j] == tempres.get(1)){
                        j++;
                    }
                    k--;
                }
                else if (sum &gt; 0){
                    k--;
                }
                else{
                    j++;
                }

            }
        }
    }
    res.addAll(tres);

    return res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all uniqu]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Two Points" scheme="http://yoursite.com/tags/Two-Points/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Two Sum(Java)]]></title>
    <link href="http://yoursite.com/2016/01/28/Leetcode-Two-Sum-Java/"/>
    <id>http://yoursite.com/2016/01/28/Leetcode-Two-Sum-Java/</id>
    <published>2016-01-28T22:55:39.000Z</published>
    <updated>2016-01-28T22:58:03.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>
<p>You may assume that each input would have exactly one solution.</p>
<p>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p>
<p><strong>Thinking:</strong></p>
<p>We can use hash map to store the rest of nums[i], and if we find which number is equal to the rest beofore, their sum will be target.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int[] twoSum(int[] nums, int target){
    HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
    int[] res = new int[2];

    for (int i = 0; i &lt; nums.length; i++){
        if (map.containsKey(nums[i])){
            res[0] = map.get(nums[i]) + 1;
            res[1] = i+1;
            break;
        }
        else{
            map.put(target-nums[i], i);
        }
    }

    return res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>
<p>]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Game of Life(Java)]]></title>
    <link href="http://yoursite.com/2016/01/28/Leetcode-Game-of-Life-Java/"/>
    <id>http://yoursite.com/2016/01/28/Leetcode-Game-of-Life-Java/</id>
    <published>2016-01-28T22:17:33.000Z</published>
    <updated>2016-01-28T22:36:18.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>According to the Wikipedia’s article: “The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.”</p>
<p>Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</p>
<p>Any live cell with fewer than two live neighbors dies, as if caused by under-population.<br>Any live cell with two or three live neighbors lives on to the next generation.<br>Any live cell with more than three live neighbors dies, as if by over-population..<br>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.<br>Write a function to compute the next state (after one update) of the board given its current state.</p>
<p>Follow up:<br>Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.<br>In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?</p>
<p><strong>Thinkings:</strong></p>
<p>It’s difficult quesiont, isn’t it? We have to fully understand when cell become live or dead and try to replace them in place. One solution is to present their status using bits, the first bit represents their current status and second bit represents their next status. For example:</p>
<p>current status is live and next status will be dead is 01<br>current status is dead and next status will be live is 10</p>
<p>And then we can get the current status by:</p>
<pre><code>board[i][j] &amp; 1
</code></pre><p>Get the finnaly status by:</p>
<pre><code>board[i][j] &gt;&gt;= 1
</code></pre><p><strong>Solution:</strong></p>
<pre><code>public void gameOfLife(int[][] board) {
    int m = board.length;
    if (m == 0)
        return;
    int n = board[0].length;

    //int[][] temp = new int[m][n];


    for (int i = 0; i &lt; m; i++){
        for (int j = 0; j &lt; n; j++){
            int count = 0;
            for (int p = -1; p &lt; 2; p++)
                for (int q = -1; q &lt; 2; q++){
                    if (i+p&gt;=0 &amp;&amp; i+p&lt;m &amp;&amp; j+q&gt;=0 &amp;&amp; j+q&lt;n &amp;&amp; !(p==0 &amp;&amp; q==0)){
                        if ((board[i+p][j+q] &amp; 1) == 1)
                            count++;
                    }
                }

            if ((board[i][j] &amp; 1) == 0 &amp;&amp; count == 3){
                //temp[i][j] = 1;
                board[i][j] = 2;
            }
            else if ((board[i][j] &amp; 1) == 1 &amp;&amp; count &lt;=3 &amp;&amp; count &gt;= 2){
                    board[i][j] = 3;

            }
        }
    }

    for (int i = 0; i &lt; m; i++){
        for (int j = 0; j &lt; n; j++){
            //board[i][j] = temp[i][j];
            board[i][j] &gt;&gt;= 1;
        }
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>According to the Wikipedia’s article: “The Game of Life, also known simply as Life, is a cellular autom]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Letter Combinations of a Phone Number(Java)]]></title>
    <link href="http://yoursite.com/2016/01/27/Leetcode-Letter-Combinations-of-a-Phone-Number-Java/"/>
    <id>http://yoursite.com/2016/01/27/Leetcode-Letter-Combinations-of-a-Phone-Number-Java/</id>
    <published>2016-01-28T00:11:34.000Z</published>
    <updated>2016-01-28T00:21:10.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a digit string, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below.</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt=""></p>
<pre><code>Input:Digit string &quot;23&quot;
Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].
</code></pre><p>Note:<br>Although the above answer is in lexicographical order, your answer could be in any order you want.</p>
<p><strong>Thinking:</strong></p>
<p>We should get all the possiblities of the comibination so we need use backtracing.</p>
<p><strong>Solution:</strong></p>
<pre><code>import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

public class Solution {
    static private Map&lt;Character, char[]&gt; hmap = new HashMap&lt;Character, char[]&gt;();

    private Character two = new Character(&apos;2&apos;);
    private char[] twoC = {&apos;a&apos;, &apos;b&apos;, &apos;c&apos;};
    private Character three = new Character(&apos;3&apos;);
    private char[] threeC = {&apos;d&apos;, &apos;e&apos;, &apos;f&apos;};
    private Character four = new Character(&apos;4&apos;);
    private char[] fourC = {&apos;g&apos;, &apos;h&apos;, &apos;i&apos;};
    private Character five = new Character(&apos;5&apos;);
    private char[] fiveC = {&apos;j&apos;, &apos;k&apos;, &apos;l&apos;};
    private Character six = new Character(&apos;6&apos;);
    private char[] sixC = {&apos;m&apos;, &apos;n&apos;, &apos;o&apos;};
    private Character seven = new Character(&apos;7&apos;);
    private char[] sevenC = {&apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;};
    private Character eight = new Character(&apos;8&apos;);
    private char[] eightC = {&apos;t&apos;, &apos;u&apos;, &apos;v&apos;};
    private Character nine = new Character(&apos;9&apos;);
    private char[] nineC = {&apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;};

    public Solution(){
        hmap.put(two, twoC);
        hmap.put(three, threeC);
        hmap.put(four, fourC);
        hmap.put(five, fiveC);
        hmap.put(six, sixC);
        hmap.put(seven, sevenC);
        hmap.put(eight, eightC);
        hmap.put(nine, nineC);
    }

    public List&lt;String&gt; letterCombinations(String digits) {
        List&lt;String&gt; res = new ArrayList&lt;String&gt;();

        backTracing(digits, 0, &quot;&quot;, res);

        return res;
    }

    private void backTracing(String digits, int index, String cur, List&lt;String&gt; res){
        int l = digits.length();
        if (l == 0)
            return;
        if (index == l){
            res.add(cur);
            return;
        }


        Character tmpc = new Character(digits.charAt(index));
        if(hmap.containsKey(tmpc)){
            for (char c :hmap.get(tmpc)){
                backTracing(digits, index+1, cur+c, res);
            }
        }

    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a digit string, return all possible letter combinations that the number could represent.</p>
<p>A]]>
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Path Sum II(Java)]]></title>
    <link href="http://yoursite.com/2016/01/27/Leetcode-Path-Sum-II-Java/"/>
    <id>http://yoursite.com/2016/01/27/Leetcode-Path-Sum-II-Java/</id>
    <published>2016-01-27T22:11:58.000Z</published>
    <updated>2016-01-27T23:05:21.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p>
<p>For example:<br>Given the below binary tree and sum = 22,</p>
<pre><code>      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1
</code></pre><p>return</p>
<pre><code>[
      [5,4,11,2],
       [5,8,4,5]
]
</code></pre><p><strong>Thinking:</strong></p>
<p>We should use classic dfs method to solve this problem and record all the results.</p>
<p><strong>Solution:</strong></p>
<p>But my first version of solution is time limit exceeded:</p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) {
    List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();

    return dp(root, sum, res);
}

private List&lt;List&lt;Integer&gt;&gt; dp(TreeNode root, int sum, List&lt;Integer&gt; cur){
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    if (root == null)
        return null;
    if (root.left == null &amp;&amp; root.right == null){
        if (root.val == sum){
            cur.add(root.val);
            res.add(cur);
            return res;
        }
        else{
            return res;
        }
    }
    for (List&lt;Integer&gt; ele: dp(root.left, sum-root.val, cur)){
        if (ele != null){
            ele.add(0, root.val);
            res.add(ele);
        }
    }
    for (List&lt;Integer&gt; ele: dp(root.right, sum-root.val, cur)){
        if (ele != null){
            ele.add(0, root.val);
            res.add(ele);
        }
    }

    return res;
}
</code></pre><p>Then I have to improve the effiency of this algorithm, and the code is below:</p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) {
    List&lt;Integer&gt; cur = new ArrayList&lt;Integer&gt;();
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();

    dp(root, sum, cur, res);

    return res;
}

private void dp(TreeNode root, int sum, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; res){
    if (root == null)
        return;
    //preorder dfs

    sum -= root.val;
    if (root.left == null &amp;&amp; root.right == null){
        if (sum == 0){
            cur.add(root.val);
            List&lt;Integer&gt; tempres = new ArrayList&lt;Integer&gt;();
            tempres.addAll(cur);
            res.add(tempres);
            cur.remove(cur.size() - 1);
        }
        return;
    }
    cur.add(root.val);
    if (root.left != null){
        dp(root.left, sum, cur, res);
    }
    if (root.right != null){
        dp(root.right, sum, cur, res);
    }
    cur.remove(cur.size() - 1);
}
</code></pre><p>It’s very importatn to create a new List while put the current list data to final result, becuase if not we will only copy the address of this variable cur. Then it will be incorrect if we revise cur.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.<]]>
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://yoursite.com/2016/01/27/hello-world/"/>
    <id>http://yoursite.com/2016/01/27/hello-world/</id>
    <published>2016-01-27T22:00:19.000Z</published>
    <updated>2016-01-27T22:00:19.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start"><a href="#Quick_Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create_a_new_post"><a href="#Create_a_new_post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server"><a href="#Run_server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files"><a href="#Generate_static_files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites"><a href="#Deploy_to_remote_sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.]]>
    </summary>
    
      <category term="uncategoried" scheme="http://yoursite.com/categories/uncategoried/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Flatten Binary Tree to Linked List(Java)]]></title>
    <link href="http://yoursite.com/2016/01/27/leetcode-flatten-binary-tree-to-linked-list/"/>
    <id>http://yoursite.com/2016/01/27/leetcode-flatten-binary-tree-to-linked-list/</id>
    <published>2016-01-27T22:00:06.000Z</published>
    <updated>2016-01-27T22:00:06.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<pre><code>    1
   / \
  2   5
 / \   \
3   4   6
</code></pre><p>The flattened tree should look like:</p>
<pre><code>1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
</code></pre><p>Hint:<br>If you notice carefully in the flattened tree, each node’s right child points to the next node of a pre-order traversal.</p>
<p><strong>Thinking:</strong> </p>
<p>It’s a simple dfs question and it’s pre-order. So we need to make the left-child become right-child of root and make right-child become whole left-child’s right-child. </p>
<p><strong>Solution:</strong></p>
<pre><code>public class Solution {
    public void flatten(TreeNode root) {
        if (root == null)
            return;
        dfs(root);
    }

    public TreeNode dfs(TreeNode root){

        if (root.left == null &amp;&amp; root.right == null){
            return root;
        }

        TreeNode left = null;
        TreeNode right = null;
        TreeNode preleft = root.left;
        TreeNode preright = root.right;
        if (preleft == null){
            return dfs(preright);
        }
        else if(preright == null){
            root.left = null;
            root.right = preleft;
            return dfs(preleft);
        }
        else{
            left = dfs(preleft);
            right = dfs(preright);
            root.left = null;
            root.right = preleft;
            left.right = preright;
            return right;
        }
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<pre><code>]]>
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Triangle(Java)]]></title>
    <link href="http://yoursite.com/2016/01/27/Leetcode-Triangle/"/>
    <id>http://yoursite.com/2016/01/27/Leetcode-Triangle/</id>
    <published>2016-01-27T21:58:25.000Z</published>
    <updated>2016-01-27T21:58:25.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>
<p>For example, given the following triangle:</p>
<pre><code>[
       [2],
     [3,4],
    [6,5,7],
   [4,1,8,3]
]
</code></pre><p>The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</p>
<p>Note:<br>Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</p>
<p><strong>Thinking:</strong><br>It’s a simple dynamic programming question. The expression is dp[i][j] = min(d[i-1][j-1], d[i][j]) + triangle[i][j].</p>
<p>But the first time, my code is time exceed:</p>
<pre><code>public class Solution {
    public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) {
        int lr = triangle.size();
        if(lr == 0){
            return 0;
        }
        int lc = triangle.get(lr-1).size();
        int min = 100000;
        for(int i = 0; i &lt; lc; i++){
            int tmp = dp(triangle, lr-1, i);
            if(tmp &lt; min)
                min = tmp;
        }
        return min;
    }

    public int dp(List&lt;List&lt;Integer&gt;&gt; triangle, int row, int column){
        if(row == 0){
            return triangle.get(0).get(0);
        }
        int value = triangle.get(row).get(column);
        int size = triangle.get(row-1).size();
        if(column &gt;= size){
            return dp(triangle, row-1, column-1) + value;
        }
        else if(column - 1 &lt; 0){
            return dp(triangle, row-1, column) + value;
        }
        else{
            int res1 = dp(triangle, row-1, column-1) + value;
            int res2 = dp(triangle, row-1, column) + value;
            if(res1 &lt; res2){
                return res1;
            }
            else{
                return res2;
            }
        }
    }
}
</code></pre><p>Then I noticed the bonus, so I change my mind to use <em>iteration</em>:</p>
<pre><code>public class Solution{
    public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle){
        int lr = triangle.size();
        int[] min = new int[lr];
        int[] tempmin = new int[lr];
        min[0] = triangle.get(0).get(0);
        for(int i = 1; i &lt; lr; i++){
            tempmin[0] = min[0] + triangle.get(i).get(0);
            tempmin[i] = min[i-1] + triangle.get(i).get(i);
            for(int j = 1; j &lt; i; j++){
                int res1 = min[j-1] + triangle.get(i).get(j);
                int res2 = min[j] + triangle.get(i).get(j);
                if(res1 &lt; res2)
                    tempmin[j] = res1;
                else
                    tempmin[j] = res2;
            }
            for(int k = 0; k &lt; i+1; k++){
                min[k] = tempmin[k];
            }
        }
        int m = 100000;
        for(int i = 0; i &lt; lr; i++){
            if(min[i] &lt; m)
                m = min[i];
        }
        return m;
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numb]]>
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTTP method: get and post]]></title>
    <link href="http://yoursite.com/2016/01/26/HTTP-method-get-and-post/"/>
    <id>http://yoursite.com/2016/01/26/HTTP-method-get-and-post/</id>
    <published>2016-01-27T07:08:43.000Z</published>
    <updated>2016-01-27T21:59:18.000Z</updated>
    <content type="html"><![CDATA[<p><strong>HTTP:</strong></p>
<p>HTTP is the foundation of data commnication of the World Wide Web. The basic work method of http is request and response.</p>
<p>There are two methods of HTTP request: Get and Post.</p>
<p>Get - get request data from specific source.<br>Post - Push data which will be dealed to specific source.</p>
<p><strong>GET:</strong></p>
<p>Note that the query string (name/value pairs) is sent in the URL of a GET request:</p>
<pre><code>http://www.w3schools.com/tags/ref_httpmethods.asp
</code></pre><p>Some other notes on GET requests:</p>
<p>GET requests can be cached</p>
<p>GET requests remain in the browser history</p>
<p>GET requests can be bookmarked</p>
<p>GET requests should never be used when dealing with sensitive data</p>
<p>GET requests have length restrictions</p>
<p>GET requests should be used only to retrieve data</p>
<p><strong>POST:</strong></p>
<p>Note that the query string (name/value pairs) is sent in the HTTP message body of a POST request:</p>
<pre><code>POST /test/demo_form.asp HTTP/1.1
Host: w3schools.com
name1=value1&amp;name2=value2
</code></pre><p>Some other notes on POST requests:</p>
<p>POST requests are never cached</p>
<p>POST requests do not remain in the browser history</p>
<p>POST requests cannot be bookmarked</p>
<p>POST requests have no restrictions on data length</p>
<p><strong>Compare GET vs. POST:</strong></p>
<table>
<thead>
<tr>
<th>Tables</th>
<th style="text-align:center">GET</th>
<th style="text-align:right">POST</th>
</tr>
</thead>
<tbody>
<tr>
<td>BACK button/Reload</td>
<td style="text-align:center">Harmless</td>
<td style="text-align:right">Data will be re-submitted</td>
</tr>
<tr>
<td>Bookmarked</td>
<td style="text-align:center">can be bookmarked</td>
<td style="text-align:right">Can not be bookmarked</td>
</tr>
<tr>
<td>Cached</td>
<td style="text-align:center">Can be cached</td>
<td style="text-align:right">Can not be cached</td>
</tr>
<tr>
<td>History</td>
<td style="text-align:center">Parameters remain in browser history</td>
<td style="text-align:right">Parameters are not saved in browser history</td>
</tr>
<tr>
<td>Restrictions on data length</td>
<td style="text-align:center">Yes</td>
<td style="text-align:right">No</td>
</tr>
<tr>
<td>Security</td>
<td style="text-align:center">Less secure</td>
<td style="text-align:right">Safer</td>
</tr>
<tr>
<td>Visibility</td>
<td style="text-align:center">Visible</td>
<td style="text-align:right">Not visible in URL</td>
</tr>
</tbody>
</table>
<p>Reference: <a href="http://www.w3schools.com/tags/ref_httpmethods.asp" target="_blank" rel="external">http://www.w3schools.com/tags/ref_httpmethods.asp</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>HTTP:</strong></p>
<p>HTTP is the foundation of data commnication of the World Wide Web. The basic work method of http is request]]>
    </summary>
    
      <category term="Network" scheme="http://yoursite.com/categories/Network/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Construct Binary Tree from Preorder and Inorder Traversal(Java)]]></title>
    <link href="http://yoursite.com/2016/01/26/Leetcode-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Java/"/>
    <id>http://yoursite.com/2016/01/26/Leetcode-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Java/</id>
    <published>2016-01-27T06:28:05.000Z</published>
    <updated>2016-01-27T21:58:44.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>You may assume that duplicates do not exist in the tree.</p>
<p><strong>Thinking:</strong></p>
<p>This question is similar with Construct Binary Tree from Inorder and Postorder Traversal. We should understand the differences and the sequences of these three methods. And divide into three parts- root, left child and right child.</p>
<p><strong>Solution:</strong></p>
<pre><code>public TreeNode buildTree(int[] preorder, int[] inorder) {
    int l = preorder.length;
    if (l == 0)
        return null;


    return dp(preorder, inorder, 0, l-1, 0, l-1);
    }

    private TreeNode dp(int[] preorder, int[] inorder, int preStart, int preEnd, int inStart, int inEnd){
    if (preStart &gt; preEnd || preEnd &gt;= preorder.length || inEnd &gt;= preorder.length)
        return null;
    TreeNode root = new TreeNode(preorder[preStart]);
    int index = inStart;
    for (; index &lt; inEnd; index++){
        if (inorder[index] == preorder[preStart])
            break;
    }

    TreeNode left = dp(preorder, inorder, preStart+1, preStart+index-inStart, inStart, index-1);
    TreeNode right = dp(preorder, inorder,preStart+index-inStart+1, preEnd, index+1, inEnd);
    root.left = left;
    root.right = right;

    return root;
}    
</code></pre><p>This method can be improved by using HashMap to make it faster when fiding the index of root.<br>Reference:<a href="http://blog.csdn.net/linhuanmars/article/details/24389549" target="_blank" rel="external">http://blog.csdn.net/linhuanmars/article/details/24389549</a><br>Code:</p>
<pre><code>static HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
public TreeNode buildTree(int[] preorder, int[] inorder) {
    int l = preorder.length;
    if (l == 0)
        return null;
    for (int i = 0; i &lt; l; i++)
        map.put(inorder[i], i);

    return dp(preorder, inorder, 0, l-1, 0, l-1);
}

private TreeNode dp(int[] preorder, int[] inorder, int preStart, int preEnd, int inStart, int inEnd){
    if (preStart &gt; preEnd || inStart &gt; inEnd)
        return null;
    TreeNode root = new TreeNode(preorder[preStart]);

    int index = map.get(preorder[preStart]);

    TreeNode left = dp(preorder, inorder, preStart+1, preStart+index-inStart, inStart, index-1);
    TreeNode right = dp(preorder, inorder,preStart+index-inStart+1, preEnd, index+1, inEnd);
    root.left = left;
    root.right = right;

    return root;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>You may assu]]>
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Pow(x, n)(Java)]]></title>
    <link href="http://yoursite.com/2016/01/26/Leetcode-Pow-x-n-Java/"/>
    <id>http://yoursite.com/2016/01/26/Leetcode-Pow-x-n-Java/</id>
    <published>2016-01-27T05:24:27.000Z</published>
    <updated>2016-01-27T21:58:38.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Implement pow(x, n).</p>
<p><strong>Thinking:</strong></p>
<p>It’s a simple but not simple question. There are many solutions for this problem. But how can we find the most effienct one. We can use recursion to reduce the times of multipling and check the bound of data to reduce the times of recursions. Finally, the code is below:</p>
<pre><code>static boolean negflag = false;
public double myPow(double x, int n) {
    if (n &lt; 0){
        negflag = true;
        return 1 / dp(x, -n);
    }
    else
        return dp(x, n);

}
private double dp(double x, int n){
    if (n == 0)
        return 1;
    if (n == 1)
        return x;
    if (n == 2)
        return x * x;

    int m = n / 2;
    int k = n % 2;
    double v = dp(x, m);
    if (negflag == true &amp;&amp; v &gt; 100000)
        return 100000;
    if (negflag == false &amp;&amp; v &lt; 0.00001)
        return 0;

    if (k == 0)
        return v * v;
    else
        return v * v * x;
}
</code></pre><p>By the way, I have to metion that my python solution is like, lol:</p>
<pre><code>def myPow(self, x, n):
    return x**n
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Implement pow(x, n).</p>
<p><strong>Thinking:</strong></p>
<p>It’s a simple but not simple question. Th]]>
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Jump Game(Java)]]></title>
    <link href="http://yoursite.com/2016/01/26/Leetcode-Jump-Game-Java/"/>
    <id>http://yoursite.com/2016/01/26/Leetcode-Jump-Game-Java/</id>
    <published>2016-01-27T04:20:54.000Z</published>
    <updated>2016-01-27T21:58:33.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<p>For example:<br>A = [2,3,1,1,4], return true.</p>
<p>A = [3,2,1,0,4], return false.</p>
<p><strong>Thinking:</strong></p>
<p>It’s a problem can be solved in greedy algorithm. Because we should go as far as possible in current position until we can’t go father. And we should gurantee the value of current position + i (steps can be reached from current postion) + nums[cur + i] be as big as possible.</p>
<p><strong>Solution:</strong></p>
<pre><code>public boolean canJump(int[] nums) {
    int l = nums.length;
    if (nums[0] == 0 &amp;&amp; l &gt; 1)
        return false;
    int cur = 0;
    int temp = nums[0];
    int step = nums[0];
    int max = nums[0];
    int tempcur = 0;

    while (cur + step &lt; l-1){
        for (int i = 1; i &lt;= step; i++){
            temp = cur + i + nums[cur + i];
            if (temp &gt;= max){//current max greedy value
                max = temp;
                if (max &gt;= l)
                    return true;
                tempcur = cur + i;
            }
        }
        if (cur == tempcur)
            return false;
        cur = tempcur;
        step = nums[cur];
    }

    if (max &gt;= l-1)
        return true;
    else
        return false;
}
</code></pre><p>What’s more, we can make it easier by max the value of index. </p>
<pre><code>public boolean canJump(int[] nums) {
    if(nums.length &lt;= 1)
        return true;

    int max = nums[0]; //max stands for the largest index that can be reached.

    for(int i=0; i&lt;nums.length; i++){
        //if not enough to go to next
        if(max &lt;= i &amp;&amp; nums[i] == 0) 
            return false;

        //update max    
        if(i + nums[i] &gt; max){
            max = i + nums[i];
        }

        //max is enough to reach the end
        if(max &gt;= nums.length-1) 
            return true;
    }

    return false;    
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.<]]>
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-3Sum Closest(Java)]]></title>
    <link href="http://yoursite.com/2016/01/26/Leetcode-3Sum-Closest-Java/"/>
    <id>http://yoursite.com/2016/01/26/Leetcode-3Sum-Closest-Java/</id>
    <published>2016-01-27T00:38:28.000Z</published>
    <updated>2016-01-27T21:58:53.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<p>For example, given array S = {-1 2 1 -4}, and target = 1.</p>
<p>The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</p>
<p><strong>Thinking:</strong></p>
<p>In order to improve the performance of algorithm, we should sort the array. Because of that, we can determine where to go using current result.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int threeSumClosest(int[] nums, int target) {
    int l = nums.length;
    if (l &lt; 3)
        return 0;
    int min = Integer.MAX_VALUE;
    int res = 0;
    Arrays.sort(nums);

    for (int i = 0; i &lt; l; i++){
        int j = i + 1;
        int k = l - 1;

        while (j &lt; k){
            int sum = nums[i] + nums[j] + nums[k];
            if (sum == target)
                return sum;
            int diff = Math.abs(sum - target);
            if (diff &lt; min){
                min = diff;
                res = sum;
            }
            if (sum &gt; target)
                k--;
            else
                j++;
        }

    }
    return res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number]]>
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
</feed>
