<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Martin's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-03-26T03:17:21.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Martin]]></name>
    <email><![CDATA[martinglory1992@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Leetcode Counting Bits(Java)]]></title>
    <link href="http://yoursite.com/2016/03/25/Leetcode-Counting-Bits-Java/"/>
    <id>http://yoursite.com/2016/03/25/Leetcode-Counting-Bits-Java/</id>
    <published>2016-03-26T03:13:24.000Z</published>
    <updated>2016-03-26T03:17:21.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.</p>
<p>Example:<br>For num = 5 you should return [0,1,1,2,1,2].</p>
<p>Follow up:</p>
<p>It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?<br>Space complexity should be O(n).<br>Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.<br>Hint:</p>
<p>You should make use of what you have produced already.<br>Divide the numbers in ranges like [2-3], [4-7], [8-15] and so on. And try to generate new range from previous.<br>Or does the odd/even status of the number help you in calculating the number of 1s?</p>
<p><strong>Thinking:</strong></p>
<p>We can divide the numbers into several groups and calculate the current elements based on the prvious ones. For example, in the group of [0-3] and [4-7], the later group’s elements have always one more 1 than the previous group.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int[] countBits(int num) {
    int[] res = new int[num+1];
    res[0] = 0;

    int flag = 1;
    for (int i = 1; i &lt;= num; i++) {
        if (i / flag == 2)    flag *= 2;
        res[i] = res[i % flag] + 1;
    }
    return res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the num]]>
    </summary>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode Largest Number(Java)]]></title>
    <link href="http://yoursite.com/2016/03/10/Leetcode-Largest-Number-Java/"/>
    <id>http://yoursite.com/2016/03/10/Leetcode-Largest-Number-Java/</id>
    <published>2016-03-11T00:39:50.000Z</published>
    <updated>2016-03-11T00:44:27.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a list of non negative integers, arrange them such that they form the largest number.</p>
<p>For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330.</p>
<p>Note: The result may be very large, so you need to return a string instead of an integer.</p>
<p><strong>Thinking:</strong></p>
<p>I suppose we should sort the numbers in order. For example, if there are two nums, we convert them into strings. Then compare the connection of s1 + s2 and connection s2 + s1. Make sure the compare method. Then what we need is connecting them together.</p>
<p><strong>Solution:</strong></p>
<pre><code>public String largestNumber(int[] nums) {
    PriorityQueue&lt;String&gt; maxHeap = new PriorityQueue&lt;String&gt;(new NumComparator());
    StringBuilder res = new StringBuilder();

    for (int num: nums)
        maxHeap.add(Integer.toString(num));

    while (!maxHeap.isEmpty())
        res.append(maxHeap.poll());

    return res.toString().charAt(0) == &apos;0&apos;? &quot;0&quot; : res.toString();
}

public class NumComparator implements Comparator&lt;String&gt; {

    @Override
    public int compare(String s1, String s2) {
        String str1 = s1 + s2;
        String str2 = s2 + s1;

        return str2.compareTo(str1);
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a list of non negative integers, arrange them such that they form the largest number.</p>
<p>For ]]>
    </summary>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode Reverse Words in a String(Java)]]></title>
    <link href="http://yoursite.com/2016/03/10/Leetcode-Reverse-Words-in-a-String-Java/"/>
    <id>http://yoursite.com/2016/03/10/Leetcode-Reverse-Words-in-a-String-Java/</id>
    <published>2016-03-10T18:53:50.000Z</published>
    <updated>2016-03-10T18:56:15.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an input string, reverse the string word by word.</p>
<p>For example,<br>Given s = “the sky is blue”,<br>return “blue is sky the”.</p>
<p>Update (2015-02-12):<br>For C programmers: Try to solve it in-place in O(1) space.</p>
<p>Clarification:<br>What constitutes a word?<br>A sequence of non-space characters constitutes a word.<br>Could the input string contain leading or trailing spaces?<br>Yes. However, your reversed string should not contain leading or trailing spaces.<br>How about multiple spaces between two words?<br>Reduce them to a single space in the reversed string.</p>
<p><strong>Thinking:</strong></p>
<p>We can use Java API to easily split the String into pieces with String[] strs = s.trim().split(“\s+”). We should to notice the “\s+” match one or many whitespaces.</p>
<p><strong>Solution:</strong></p>
<pre><code>public String reverseWords(String s) {
    String[] strs = s.trim().split(&quot;\\s+&quot;);
    StringBuilder res = new StringBuilder();

    for (int i = strs.length-1; i &gt;= 0; i--) 
        res.append(strs[i] + &quot; &quot;);

    return res.toString().trim();
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given an input string, reverse the string word by word.</p>
<p>For example,<br>Given s = “the sky is bl]]>
    </summary>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode Wiggle Sort II(Java)]]></title>
    <link href="http://yoursite.com/2016/03/09/Leetcode-Wiggle-Sort-II-Java/"/>
    <id>http://yoursite.com/2016/03/09/Leetcode-Wiggle-Sort-II-Java/</id>
    <published>2016-03-10T02:09:43.000Z</published>
    <updated>2016-03-10T18:49:49.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an unsorted array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]….</p>
<p>Example:<br>(1) Given nums = [1, 5, 1, 1, 6, 4], one possible answer is [1, 4, 1, 5, 1, 6].<br>(2) Given nums = [1, 3, 2, 2, 3, 1], one possible answer is [2, 3, 1, 3, 1, 2].</p>
<p>Note:<br>You may assume all input has valid answer.</p>
<p>Follow Up:<br>Can you do it in O(n) time and/or in-place with O(1) extra space?</p>
<p><strong>Thinking:</strong></p>
<p>Firstly, we get information from the question is that we should divide all the elements into two groups. One is smaller ones, and the other is greater ones. Then we need to get the median to group them.</p>
<p>So we need the method called quickselect which is used in the kth largest element to get the median. Then rewire the element to new index which use (1+2<em>(i)) % (n|1). It(A(i) = nums[(1+2</em>(i)) % (n|1)]) means:</p>
<p>If the length of array is 10, then</p>
<p>Accessing A(0) actually accesses nums[1].<br>Accessing A(1) actually accesses nums[3].<br>Accessing A(2) actually accesses nums[5].<br>Accessing A(3) actually accesses nums[7].<br>Accessing A(4) actually accesses nums[9].<br>Accessing A(5) actually accesses nums[0].<br>Accessing A(6) actually accesses nums[2].<br>Accessing A(7) actually accesses nums[4].<br>Accessing A(8) actually accesses nums[6].<br>Accessing A(9) actually accesses nums[8].</p>
<p>We firstly put ones greater than median, then median, finally smaller than median. We’ll get the result.</p>
<p>There are some details to notice:</p>
<ol>
<li>In the rewiring process, we need to distinguish whether the length of the array is odd or even. Use the (n|1).</li>
<li>In the 3 way partition process, when move larger element to the head, we don’t need to check it again. Because the element move from the head to the current position is checked before. On the other hand, the element which is moved from the current position to tail, we need to check it again.</li>
</ol>
<p><strong>Solution:</strong></p>
<pre><code>public void wiggleSort(int[] nums) {
    int len = nums.length;
    if (len &lt; 2)    return;

    quickselect(nums, (len-1)/2);
    int mid = nums[(len-1)/2];

    int i = 0, j = len - 1, cur = 0;

    while (cur &lt;= j) {
        if (nums[(2*cur+1)%(len|1)] &gt; mid)
            swap(nums, (2*(cur++)+1)%(len|1), (2*(i++)+1)%(len|1));
        else if (nums[(2*cur+1)%(len|1)] &lt; mid)    
            swap(nums, (2*(cur)+1)%(len|1), (2*(j--)+1)%(len|1));
        else    
            cur++;
    }
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}

private void quickselect(int[] nums, int n) {
    int low = 0, high = nums.length-1;

    while (true) {
        int i = partition(nums, low, high);
        if (i == n)    return;
        else if (i &lt; n) low = i + 1;
        else    high = i - 1;
    }
}

private int partition (int[] nums, int left, int right) {
    int pivot = nums[left];
    int storeIndex = left;
    nums[left] = nums[right];
    for (int i = left; i &lt; right; i++) {
        if (nums[i] &lt;= pivot)
            swap(nums, storeIndex++, i);
    }
    nums[right] = nums[storeIndex];
    nums[storeIndex] = pivot;

    return storeIndex;
}
</code></pre><p>Reference: <a href="https://leetcode.com/discuss/77133/o-n-o-1-after-median-virtual-indexing" target="_blank" rel="external">https://leetcode.com/discuss/77133/o-n-o-1-after-median-virtual-indexing</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given an unsorted array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]….</p>]]>
    </summary>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode Range Sum Query 2D - Immutable(Java)]]></title>
    <link href="http://yoursite.com/2016/03/08/Leetcode-Range-Sum-Query-2D-Immutable-Java/"/>
    <id>http://yoursite.com/2016/03/08/Leetcode-Range-Sum-Query-2D-Immutable-Java/</id>
    <published>2016-03-09T05:18:20.000Z</published>
    <updated>2016-03-09T05:22:17.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).</p>
<p><img src="https://leetcode.com/static/images/courses/range_sum_query_2d.png" alt=""></p>
<p>Range Sum Query 2D<br>The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.</p>
<p>Example:</p>
<pre><code>Given matrix = [
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]

sumRegion(2, 1, 4, 3) -&gt; 8
sumRegion(1, 1, 2, 2) -&gt; 11
sumRegion(1, 2, 2, 4) -&gt; 12
</code></pre><p>Note:</p>
<p>1.You may assume that the matrix does not change.</p>
<p>2.There are many calls to sumRegion function.</p>
<p>3.You may assume that row1 ≤ row2 and col1 ≤ col2.</p>
<p><strong>Thinking:</strong></p>
<p>I see this problem as a matrix caculating. We should get the sum of the current i, j (row and column index) from 0, 0. Then caculate the region sum from previous stored values.</p>
<p><strong>Solution:</strong></p>
<pre><code>private int[][] sumMatrix = null;

public NumMatrix(int[][] matrix) {
    if(matrix == null || matrix.length == 0 || matrix[0].length == 0)    return;   
    int m = matrix.length;
    int n = matrix[0].length;
    this.sumMatrix = new int[m+1][n+1];

    for (int i = 1; i &lt;= m; i++) 
        for (int j = 1; j &lt;= n; j++) 
            sumMatrix[i][j] = sumMatrix[i-1][j] + sumMatrix[i][j-1] + matrix[i-1][j-1] - sumMatrix[i-1][j-1];

}

public int sumRegion(int row1, int col1, int row2, int col2) {
    return sumMatrix[row2+1][col2+1] + sumMatrix[row1][col1] - sumMatrix[row2+1][col1] - sumMatrix[row1][col2+1];
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left c]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[The Zen of Python]]></title>
    <link href="http://yoursite.com/2016/03/08/The-Zen-of-Python/"/>
    <id>http://yoursite.com/2016/03/08/The-Zen-of-Python/</id>
    <published>2016-03-09T03:46:49.000Z</published>
    <updated>2016-03-09T03:48:45.000Z</updated>
    <content type="html"><![CDATA[<p><strong>The Zen of Python:</strong></p>
<p>Beautiful is better than ugly.</p>
<p>Explicit is better than implicit.</p>
<p>Simple is better than complex.</p>
<p>Complex is better than complicated.</p>
<p>Flat is better than nested.</p>
<p>Sparse is better than dense.</p>
<p>Readability counts.</p>
<p>Special cases aren’t special enough to break the rules.</p>
<p>Although practicality beats purity.</p>
<p>Errors should never pass silently.</p>
<p>Unless explicitly silenced.</p>
<p>In the face of ambiguity, refuse the temptation to guess.</p>
<p>There should be one– and preferably only one –obvious way to do it.</p>
<p>Although that way may not be obvious at first unless you’re Dutch.</p>
<p>Now is better than never.</p>
<p>Although never is often better than <em>right</em> now.</p>
<p>If the implementation is hard to explain, it’s a bad idea.</p>
<p>If the implementation is easy to explain, it may be a good idea.</p>
<p>Namespaces are one honking great idea – let’s do more of those!</p>
<p>(Reference: <a href="https://www.python.org/dev/peps/pep-0020/" target="_blank" rel="external">https://www.python.org/dev/peps/pep-0020/</a>)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>The Zen of Python:</strong></p>
<p>Beautiful is better than ugly.</p>
<p>Explicit is better than implicit.</p>
<p>Simple is bette]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Reconstruct Itinerary(Java)]]></title>
    <link href="http://yoursite.com/2016/03/08/Leetcode-Reconstruct-Itinerary-Java/"/>
    <id>http://yoursite.com/2016/03/08/Leetcode-Reconstruct-Itinerary-Java/</id>
    <published>2016-03-08T23:43:32.000Z</published>
    <updated>2016-03-09T00:27:35.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.</p>
<p>Note:<br>If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary </p>
<p> 1.[“JFK”, “LGA”] has a smaller lexical order than [“JFK”, “LGB”].</p>
<p> 2.All airports are represented by three capital letters (IATA code).</p>
<p> 3.You may assume all tickets form at least one valid itinerary.</p>
<p>Example 1:</p>
<pre><code>tickets = [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]
</code></pre><p>Return </p>
<pre><code>[&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;].
</code></pre><p>Example 2:</p>
<pre><code>tickets = [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]
</code></pre><p>Return </p>
<pre><code>[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;].
</code></pre><p>Another possible reconstruction is [“JFK”,”SFO”,”ATL”,”JFK”,”ATL”,”SFO”]. But it is larger in lexical order.</p>
<p><strong>Thinking:</strong></p>
<p>We need to use dfs to travse all the graph and record the graph. But we need to record it in order. So it should be stored in PriorityQueue and store the route while visiting. If it’s stuck we back up but also record the previous information, because we know there are other ways to get there. Until all the edges are visited once, it’s finished.</p>
<p><strong>Solution:</strong></p>
<pre><code>List&lt;String&gt; res = new ArrayList&lt;String&gt;();
HashMap&lt;String, PriorityQueue&lt;String&gt;&gt; map = new HashMap&lt;String, PriorityQueue&lt;String&gt;&gt;();

public List&lt;String&gt; findItinerary(String[][] tickets) {
    for (String[] ticket: tickets)
        map.computeIfAbsent(ticket[0], k -&gt; new PriorityQueue&lt;String&gt;()).add(ticket[1]);
    visit(&quot;JFK&quot;);

    return res;
}

private void visit(String cur) {
    while (map.containsKey(cur) &amp;&amp; !map.get(cur).isEmpty())
        visit(map.get(cur).poll());
    res.add(0, cur);
}
</code></pre><p>Reference: <a href="https://leetcode.com/discuss/84659/short-ruby-python-java-c" target="_blank" rel="external">https://leetcode.com/discuss/84659/short-ruby-python-java-c</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reco]]>
    </summary>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Graph" scheme="http://yoursite.com/tags/Graph/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Maximum Product Subarray(Java)]]></title>
    <link href="http://yoursite.com/2016/03/07/Leetcode-Maximum-Product-Subarray-Java/"/>
    <id>http://yoursite.com/2016/03/07/Leetcode-Maximum-Product-Subarray-Java/</id>
    <published>2016-03-08T04:39:50.000Z</published>
    <updated>2016-03-08T04:42:28.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>For example, given the array [2,3,-2,4],<br>the contiguous subarray [2,3] has the largest product = 6.</p>
<p><strong>Thinking:</strong></p>
<p>This problem is similiar with the MaxSubArray. One thing we need to notice is that we should maintian another variable which is the minimum value of the negative value. When it multiple the negtive value in the array, it maybe the maximum.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int maxProduct(int[] nums) {
    int l = nums.length;
    int max = nums[0];
    int maxhere = nums[0];
    int minhere = nums[0];

    for (int i = 1; i &lt; l; i++) {
        if (nums[i] &gt;= 0) {
            maxhere = Math.max(maxhere*nums[i], nums[i]);
            minhere = Math.min(minhere*nums[i], nums[i]);
        } else {
            int temp = maxhere;
            maxhere = Math.max(minhere*nums[i], nums[i]);
            minhere = Math.min(temp*nums[i], nums[i]);
        }
        max = Math.max(maxhere, max);
    }

    return max;
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest pro]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Evaluate Reverse Polish Notation(Java)]]></title>
    <link href="http://yoursite.com/2016/03/07/Leetcode-Evaluate-Reverse-Polish-Notation-Java/"/>
    <id>http://yoursite.com/2016/03/07/Leetcode-Evaluate-Reverse-Polish-Notation-Java/</id>
    <published>2016-03-08T00:22:28.000Z</published>
    <updated>2016-03-08T00:24:39.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p>
<p>Valid operators are +, -, *, /. Each operand may be an integer or another expression.</p>
<p>Some examples:</p>
<pre><code>[&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;] -&gt; ((2 + 1) * 3) -&gt; 9
[&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;] -&gt; (4 + (13 / 5)) -&gt; 6
</code></pre><p><strong>Thinking:</strong></p>
<p>We should use stack and scan the elements of this string array. Whenever we get the operator, we pop element from the stack and push new element to the stack.</p>
<p><strong>Solutioin:</strong></p>
<pre><code>public int evalRPN(String[] tokens) {
    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();

    for (String s: tokens) {
        if (s.equals(&quot;+&quot;)) {
            int num1 = stack.pop();
            int num2 = stack.pop();
            stack.push(num1+num2);
        }
        else if (s.equals(&quot;-&quot;)) {
            int num1 = stack.pop();
            int num2 = stack.pop();
            stack.push(num2-num1);
        }
        else if (s.equals(&quot;*&quot;)) {
            int num1 = stack.pop();
            int num2 = stack.pop();
            stack.push(num1*num2);
        }
        else if (s.equals(&quot;/&quot;)) {
            int num1 = stack.pop();
            int num2 = stack.pop();
            stack.push(num2/num1);
        }
        else
            stack.push(Integer.parseInt(s));
    }

    return stack.pop();
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p>
<p>Valid operators are +]]>
    </summary>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Increasing Triplet Subsequence(Java)]]></title>
    <link href="http://yoursite.com/2016/03/07/Leetcode-Increasing-Triplet-Subsequence-Java/"/>
    <id>http://yoursite.com/2016/03/07/Leetcode-Increasing-Triplet-Subsequence-Java/</id>
    <published>2016-03-08T00:09:02.000Z</published>
    <updated>2016-03-08T00:12:16.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.</p>
<p>Formally the function should:<br>Return true if there exists i, j, k<br>such that arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤ n-1 else return false.<br>Your algorithm should run in O(n) time complexity and O(1) space complexity.</p>
<p>Examples:<br>Given [1, 2, 3, 4, 5],<br>return true.</p>
<p>Given [5, 4, 3, 2, 1],<br>return false.</p>
<p><strong>Thinking:</strong></p>
<p>We need to implement this algorithm in linear time and constant space. So we need to scan this array once and record the information needed in one time. We need to variable to record the information, the first one is the minimum of this array, and the second one is the number which is bigger than its previous elements. If one element is bigger than it, the result will be true. Otherwise, we should update the two variables’ values.</p>
<p><strong>Solution:</strong></p>
<pre><code>public boolean increasingTriplet(int[] nums) {
    int l = nums.length;
    if (l &lt; 3)    return false;
    int min = nums[0];
    int secmin = Integer.MAX_VALUE;

    for (int i = 1; i &lt; l; i++) {
        if (nums[i] &gt; secmin)    return true;
        else if (nums[i] &lt;= min) min = nums[i];
        else if (nums[i] &lt; secmin)    secmin = nums[i];
    }
    return false;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array]]>
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Shortest Path Problem]]></title>
    <link href="http://yoursite.com/2016/03/06/Shortest-Path-Problem/"/>
    <id>http://yoursite.com/2016/03/06/Shortest-Path-Problem/</id>
    <published>2016-03-06T22:37:58.000Z</published>
    <updated>2016-03-06T23:50:35.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Shorstest Path Problem Categories:</strong></p>
<ol>
<li>From a speicific start point;</li>
<li>To a specific end point;</li>
<li>Start and end with a specific point;</li>
<li>Search for all the shortest path in every pair nodes.</li>
</ol>
<p><strong>Dijkstra:</strong></p>
<p>This algorithm is aiming at caculating all the shortest paths from every point to a specific start point. And it’s a greedy algorithm.</p>
<p>Algorithm:</p>
<ol>
<li>Set the distance to the start node as infinity to all the nodes except the start node.</li>
<li>Initial a set which conclude the added nodes, and another set for unvisited nodes.</li>
<li>For the added nodes set, we find the shortest edge from adjancent nodes crossing this set in unvisited set. And add the adjancent node to the added added nodes.</li>
<li>Update the distances of nodes from start node which connect to the last added node.</li>
<li>Do step 3 and 4 repeatedly until all the nodes are in the added set.</li>
</ol>
<p>Pseudoode:</p>
<pre><code>function Dijkstra(Graph, source):

    create vertex set Q

    for each vertex v in Graph:             // Initialization
    dist[v] ← INFINITY                  // Unknown distance from source to v
    prev[v] ← UNDEFINED                 // Previous node in optimal path from source
    add v to Q                          // All nodes initially in Q (unvisited nodes)

    dist[source] ← 0                        // Distance from source to source

    while Q is not empty:
        u ← vertex in Q with min dist[u]    // Source node will be selected first
        remove u from Q 

        for each neighbor v of u:           // where v is still in Q.
            alt ← dist[u] + length(u, v)
            if alt &lt; dist[v]:               // A shorter path to v has been found
                dist[v] ← alt 
                prev[v] ← u 

    return dist[], prev[]
</code></pre><p>Java Code:</p>
<pre><code>public static void dijkstra(int[][] edges, int s, int[] dist, int[] pre) {
    int n = edges.length;

    HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(n);

    for (int i = 0; i &lt; n; i++) {
        dist[i] = Integer.MAX_VALUE;
        set.add(i);
    }
    dist[s] = 0;

    while (!set.isEmpty()) {
        int min = findMin(set, dist);
        for (int i = 0; i &lt; n; i++) {
            if (edges[min][i] != -1) { // find the neighbors of the node
                if (dist[i] &lt; dist[min] + edges[min][i]) { //relaxation
                    dist[i] = dist[min] + edges[min][i];
                    pre[i] = min;
                }
            }
        }
    }
}
private static int findMin(Set set, int[] dist) {
    int min = Integer.MAX_VALUE, minIdx = -1;
    for (int i = 0; i &lt; dist.length; i++) {
        if (set.contains(i) &amp;&amp; dist[i] &lt; min) {
            min = dist[i];
            minIdx = i;
        }
    }
    set.remove(minIdx);
    return minIdx;
}
</code></pre><p>Running Time:</p>
<p>O(E*lgv)</p>
<p>If use the Fibonacci heap -&gt;  O(V*lgV + E)</p>
<p><strong>Bellman Ford:</strong></p>
<p>Aimming at searching for the shortest path from a specific start node. It is useful also for the graph containing the negative edges. It’s a dynamic programming algorithm.</p>
<p>Algorithm:</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Shorstest Path Problem Categories:</strong></p>
<ol>
<li>From a speicific start point;</li>
<li>To a specific end point;</li>
<li]]>
    </summary>
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Maximal Square(Java)]]></title>
    <link href="http://yoursite.com/2016/02/27/Leetcode-Maximal-Square-Java/"/>
    <id>http://yoursite.com/2016/02/27/Leetcode-Maximal-Square-Java/</id>
    <published>2016-02-28T04:51:07.000Z</published>
    <updated>2016-02-28T04:54:04.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing all 1’s and return its area.</p>
<p>For example, given the following matrix:</p>
<pre><code>1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
</code></pre><p>Return 4.</p>
<p><strong>Thinking:</strong></p>
<p>IIf the [i-1][j], [i][j-1] and [i-1][j-1] all have the same length of ‘1’ edge and the [i][j] is ‘1’, the length of the square can increase.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int maximalSquare(char[][] matrix) {
    int m = matrix.length;
    if (m == 0)    return 0;
    int n = matrix[0].length;
    int res = 0;
    int[][] opt = new int[m+1][n+1];

    for (int i = 1; i &lt;= m; i++){
        for (int j = 1; j &lt;= n; j++) {
            if (matrix[i-1][j-1] == &apos;1&apos;) {
                opt[i][j] = Math.min(opt[i-1][j-1], Math.min(opt[i-1][j], opt[i][j-1])) + 1;
                res = Math.max(res, opt[i][j]);
            }
        }
    }

    return res * res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing all 1’s and return]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Reorder List(Java)]]></title>
    <link href="http://yoursite.com/2016/02/27/Leetcode-Reorder-List-Java/"/>
    <id>http://yoursite.com/2016/02/27/Leetcode-Reorder-List-Java/</id>
    <published>2016-02-28T01:01:11.000Z</published>
    <updated>2016-02-28T01:03:28.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>You must do this in-place without altering the nodes’ values.</p>
<p>For example,<br>Given {1,2,3,4}, reorder it to {1,4,2,3}.</p>
<p><strong>Thinking:</strong></p>
<p>We need three steps to finish this operation. The first one is to find the middle in the linked list. The second one is to reverse the second half of this linked list. The final one is to link these two parts again.</p>
<p><strong>Solution:</strong></p>
<pre><code>public void reorderList(ListNode head) {
    if (head == null || head.next == null)    return;
    ListNode slow = head, fast = head.next, preMiddle, preCurrent, current, p, q;

    //find the middle
    while (fast != null &amp;&amp; fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }

    //reverse the second half
    preMiddle = slow;
    preCurrent = slow.next;
    while (preCurrent.next != null) {
        current = preCurrent.next;
        preCurrent.next = current.next;
        current.next = preMiddle.next;
        preMiddle.next = current;
    }

    //connect two parts
    p = head;
    q = preMiddle.next;
    while (p != preMiddle) {
        preMiddle.next = q.next;
        q.next = p.next;
        p.next = q;
        p = q.next;
        q = preMiddle.next;
    }

}
</code></pre><p>Reference:<a href="https://leetcode.com/discuss/35599/java-solution-with-3-steps" target="_blank" rel="external">https://leetcode.com/discuss/35599/java-solution-with-3-steps</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>You mus]]>
    </summary>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Word Ladder(Java)]]></title>
    <link href="http://yoursite.com/2016/02/26/Leetcode-Word-Ladder-Java/"/>
    <id>http://yoursite.com/2016/02/26/Leetcode-Word-Ladder-Java/</id>
    <published>2016-02-27T03:18:18.000Z</published>
    <updated>2016-02-27T22:32:41.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:</p>
<p>Only one letter can be changed at a time<br>Each intermediate word must exist in the word list<br>For example,</p>
<p>Given:<br>beginWord = “hit”<br>endWord = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”]<br>As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>return its length 5.</p>
<p>Note:<br>Return 0 if there is no such transformation sequence.<br>All words have the same length.<br>All words contain only lowercase alphabetic characters.</p>
<p><strong>Thinking:</strong></p>
<p>We can search the result from the start word. At every step, we change the every index of the start string and check if it’s in the WordList. If it’s in the range, then we add it to our nodes. Do it like a BFS search. Also in order to be more efficient, we can search also from the end word.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int ladderLength(String beginWord, String endWord, Set&lt;String&gt; wordList) {
    if (beginWord.equals(endWord))    return 1;
    Set&lt;String&gt; startSet = new HashSet&lt;String&gt;();
    Set&lt;String&gt; endSet =  new HashSet&lt;String&gt;();
    int res = 1;
    startSet.add(beginWord);
    endSet.add(endWord);
    while (!wordList.isEmpty() &amp;&amp; !startSet.isEmpty() &amp;&amp; !endSet.isEmpty()) {
        res++;
        Set&lt;String&gt; tempSet = new HashSet&lt;String&gt;();
        for (String nWord: startSet) {
            wordList.remove(nWord);
            for (String ele: check(nWord, wordList)) {
                if (endSet.contains(ele))    return res;
                tempSet.add(ele);
            }
        }
        startSet = tempSet;
        tempSet = new HashSet&lt;String&gt;();
        res++;
        for (String nWord: endSet) {
            wordList.remove(nWord);
            for (String ele: check(nWord, wordList)) {
                if (startSet.contains(ele))    return res;
                tempSet.add(ele);
            }
        }
        endSet = tempSet;
    }
    return 0;
}
private List&lt;String&gt; check(String word, Set&lt;String&gt; wordList) {
    List&lt;String&gt; res = new ArrayList&lt;String&gt;();
    int len = word.length();
    if (len == 1)    {
        res.addAll(wordList);
        return res;
    }
    for (int i = 0; i &lt; len; i++) {
        char[] chs = word.toCharArray();
        for (char j = &apos;a&apos;; j &lt;= &apos;z&apos;; j++) {
            chs[i] = j;
            String temp = String.valueOf(chs);
            if (wordList.contains(temp))    res.add(temp);              
        }
    }
    return res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest tran]]>
    </summary>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Validate Binary Search Tree(Java)]]></title>
    <link href="http://yoursite.com/2016/02/26/Leetcode-Validate-Binary-Search-Tree-Java/"/>
    <id>http://yoursite.com/2016/02/26/Leetcode-Validate-Binary-Search-Tree-Java/</id>
    <published>2016-02-27T03:12:44.000Z</published>
    <updated>2016-02-27T03:17:34.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.</p>
<p><strong>Thinking:</strong></p>
<p>We should use dfs check the root of the range and both its left child and right child.</p>
<p><strong>Solution:</strong></p>
<pre><code>public boolean isValidBST(TreeNode root) {
    return helper(root, Long.MIN_VALUE, Long.MAX_VALUE);
}

private boolean helper(TreeNode root, long a, long b) {
    if (root == null)    return true;
    if (root.val &lt;= a || root.val &gt;= b)    return false;        
    return helper(root.left, a, root.val&lt;b? root.val:b) &amp;&amp; helper(root.right, root.val&gt;a? root.val:a, b);
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is define]]>
    </summary>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Decode Ways(Java)]]></title>
    <link href="http://yoursite.com/2016/02/26/Leetcode-Decode-Ways-Java/"/>
    <id>http://yoursite.com/2016/02/26/Leetcode-Decode-Ways-Java/</id>
    <published>2016-02-26T20:35:11.000Z</published>
    <updated>2016-02-26T20:41:51.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>A message containing letters from A-Z is being encoded to numbers using the following mapping:</p>
<p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>Given an encoded message containing digits, determine the total number of ways to decode it.</p>
<p>For example,<br>Given encoded message “12”, it could be decoded as “AB” (1 2) or “L” (12).</p>
<p>The number of ways decoding “12” is 2.</p>
<p><strong>Thinking:</strong></p>
<p>If we use the recursive way, we should see that the search tree will go down like check [0],[0,1], then [1],[1,2] and [2],[2,3] then [2], [2,3] and [3],[3,4] and [3],[3,4] and [4],[4,5] … There are some nodes are repeated. So we can use interation from bottom to root to store the number of paths in every index of string.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int numDecodings(String s) {
    int l = s.length();
    if (l == 0)    return 0;
    int[] counts = new int[l+1];

    counts[l] = 1;
    if (s.charAt(l-1) != &apos;0&apos;)    counts[l-1] = 1;

    for (int i = l-2; i &gt;=0; i--) {
        if (s.charAt(i) == &apos;0&apos;)    continue;
        counts[i] = Integer.parseInt(s.substring(i, i+2)) &lt;=26? counts[i+1]+counts[i+2] : counts[i+1];
    }

    return counts[0];
}
</code></pre><p>Reference: <a href="https://leetcode.com/discuss/8527/dp-solution-java-for-reference" target="_blank" rel="external">https://leetcode.com/discuss/8527/dp-solution-java-for-reference</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>A message containing letters from A-Z is being encoded to numbers using the following mapping:</p>
<p>‘]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Simplify Path(Java)]]></title>
    <link href="http://yoursite.com/2016/02/25/Leetcode-Simplify-Path-Java/"/>
    <id>http://yoursite.com/2016/02/25/Leetcode-Simplify-Path-Java/</id>
    <published>2016-02-25T22:47:27.000Z</published>
    <updated>2016-02-25T22:56:13.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an absolute path for a file (Unix-style), simplify it.</p>
<p>For example,<br>path = “/home/“, =&gt; “/home”<br>path = “/a/./b/../../c/“, =&gt; “/c”<br>click to show corner cases.</p>
<p>Corner Cases:<br>Did you consider the case where path = “/../“?<br>In this case, you should return “/“.<br>Another corner case is the path might contain multiple slashes ‘/‘ together, such as “/home//foo/“.<br>In this case, you should ignore redundant slashes and return “/home/foo”.</p>
<p><strong>Thinking:</strong></p>
<p>The file system is like a tree, and finding path of this tree is like a dfs process. So we can use stack to track the node of dfs. If the string is “..”, we go back, otherwise go to the given dirctory.</p>
<p><strong>Solution:</strong></p>
<pre><code>public String simplifyPath(String path) {
    Stack&lt;String&gt; stack = new Stack&lt;String&gt;();
    String[] paths = path.split(&quot;/&quot;);

    for (String p: paths) {
        p = p.trim();
        if (p.equals(&quot;&quot;) || p.equals(&quot;.&quot;))    continue;
        if (p.equals(&quot;..&quot;))    {
            if (!stack.isEmpty()) {
                stack.pop();
            }
            continue;
        }
        stack.push(p);
    }

    StringBuilder res = new StringBuilder();
    while (!stack.isEmpty()) 
        res.insert(0, &quot;/&quot;.concat(stack.pop()));


    return res.length() == 0? &quot;/&quot;:res.toString();
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given an absolute path for a file (Unix-style), simplify it.</p>
<p>For example,<br>path = “/home/“, =&]]>
    </summary>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Word Search(Java)]]></title>
    <link href="http://yoursite.com/2016/02/25/Leetcode-Word-Search-Java/"/>
    <id>http://yoursite.com/2016/02/25/Leetcode-Word-Search-Java/</id>
    <published>2016-02-25T21:44:36.000Z</published>
    <updated>2016-02-25T21:49:05.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p>For example,<br>Given board =</p>
<p>[<br>  [‘A’,’B’,’C’,’E’],<br>  [‘S’,’F’,’C’,’S’],<br>  [‘A’,’D’,’E’,’E’]<br>]<br>word = “ABCCED”, -&gt; returns true,<br>word = “SEE”, -&gt; returns true,<br>word = “ABCB”, -&gt; returns false.</p>
<p><strong>Thinking:</strong></p>
<p>I assume it’s graph and do dfs in this 2d array. Start from every point and search the result until find the solution or failure. In this process, we need to record the visitied set. In my solution, I used the hashset. But in more efficient way, we can use bit manipulate to mask the visited element.</p>
<p><strong>Solution:</strong></p>
<p>My solution(use HashSet):</p>
<pre><code>public boolean exist(char[][] board, String word) {
    int m = board.length;
    if (m == 0)    return false;
    int n = board[0].length;
    Set&lt;Integer&gt; record = new HashSet&lt;Integer&gt;();
    for (int i = 0; i &lt; m; i++)
        for (int j = 0; j &lt; n; j++)
            if (backtracking(board, word, 0, i, j, record))    return true;
    return false;
}

private boolean backtracking(char[][] board, String word, int index, int i, int j, Set&lt;Integer&gt; record) {
    if (board[i][j] == word.charAt(index) &amp;&amp; !record.contains(i*board[0].length+j)){
        if (index == word.length()-1)    return true;
        boolean res = false;
        record.add(i*board[0].length+j);
        if (i-1&gt;=0)    res |= backtracking(board, word, index+1, i-1, j, record);
        if (!res &amp;&amp; i+1&lt;board.length) res |= backtracking(board, word, index+1, i+1, j, record);
        if (!res &amp;&amp; j-1&gt;=0)    res |= backtracking(board, word, index+1, i, j-1, record);
        if (!res &amp;&amp; j+1&lt;board[0].length) res |= backtracking(board, word, index+1, i, j+1, record);
        record.remove(i*board[0].length+j);
        return res;
    }
    return false;
}
</code></pre><p>use the mask:</p>
<pre><code>public boolean exist(char[][] board, String word) {
    char[] w = word.toCharArray();
    for (int y=0; y&lt;board.length; y++) {
        for (int x=0; x&lt;board[y].length; x++) {
            if (exist(board, y, x, w, 0)) return true;
        }
    }
    return false;
}

private boolean exist(char[][] board, int y, int x, char[] word, int i) {
    if (i == word.length) return true;
    if (y&lt;0 || x&lt;0 || y == board.length || x == board[y].length) return false;
    if (board[y][x] != word[i]) return false;
        board[y][x] ^= 256;
    boolean exist = exist(board, y, x+1, word, i+1)
    || exist(board, y, x-1, word, i+1)
    || exist(board, y+1, x, word, i+1)
    || exist(board, y-1, x, word, i+1);
    board[y][x] ^= 256;
    return exist;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed fr]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Spiral Matrix(Java)]]></title>
    <link href="http://yoursite.com/2016/02/23/Leetcode-Spiral-Matrix-Java/"/>
    <id>http://yoursite.com/2016/02/23/Leetcode-Spiral-Matrix-Java/</id>
    <published>2016-02-24T04:12:38.000Z</published>
    <updated>2016-02-24T04:14:10.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p>
<p>For example,<br>Given the following matrix:</p>
<pre><code>[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
</code></pre><p>You should return [1,2,3,6,9,8,7,4,5].</p>
<p><strong>Thinking:</strong></p>
<p>There are four directions can go, move according to the order of right, down, left, up and check the bound of moving.</p>
<p><strong>Solution:</strong></p>
<pre><code>public List&lt;Integer&gt; spiralOrder(int[][] matrix) {
    List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
    int m = matrix.length;
    if (m == 0)    return res;
    int n = matrix[0].length;
    int direction = 0;//0right, 1down, 2left, 3up
    int i = 0, j = 0;//position
    int c0 = 1, c1 = 1, c2 = 0, c3 = 1;//row and column limit

    while (c0 + c2 - 1 &lt;= n &amp;&amp; c1 + c3 - 1 &lt;= m) {
        res.add(matrix[i][j]);
        switch (direction) {
        case 0:
            if (j == n-c0){
                direction = (direction+1) % 4;
                c0++;
                res.remove(res.size()-1);
            }
            else
                j++;
            break;
        case 1:
            if (i == m-c1){
                direction = (direction+1) % 4;
                c1++;
                res.remove(res.size()-1);
            }
            else
                i++;
            break;
        case 2:
            if (j == c2){
                direction = (direction+1) % 4;
                c2++;
                res.remove(res.size()-1);
            }
            else
                j--;
            break;
        case 3:
            if (i == c3){
                direction = (direction+1) % 4;
                c3++;
                res.remove(res.size()-1);
            }
            else
                i--;
            break;
        }
    }
    res.add(matrix[i][j]);

    return res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Multiply Strings(Java)]]></title>
    <link href="http://yoursite.com/2016/02/23/Leetcode-Multiply-Strings-Java/"/>
    <id>http://yoursite.com/2016/02/23/Leetcode-Multiply-Strings-Java/</id>
    <published>2016-02-24T03:09:09.000Z</published>
    <updated>2016-02-24T03:20:12.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given two numbers represented as strings, return multiplication of the numbers as a string.</p>
<p>Note: The numbers can be arbitrarily large and are non-negative.</p>
<p><strong>Thinking:</strong></p>
<p>Simulate the process of multiplying.</p>
<p><img src="https://drscdn.500px.org/photo/130178585/m%3D2048/300d71f784f679d5e70fadda8ad7d68f" alt=""></p>
<p><strong>Solution:</strong> (Record the result from low digits to high digits in array)</p>
<pre><code>public String multiply(String num1, String num2) {
    int l1 = num1.length(), l2 = num2.length();
    int[] res = new int[l1+l2];

    for (int i = l1-1; i &gt;= 0; i--) {
        for (int j = l2-1; j &gt;= 0; j--){
            int index = l1+l2-i-j-2;
            res[index] += (num1.charAt(i) - &apos;0&apos;) * (num2.charAt(j) - &apos;0&apos;);
            res[index+1] += res[index] / 10;
            res[index] = res[index] % 10;
        }
    }

    StringBuilder fres = new StringBuilder();
    for (int i = res.length-1; i &gt;= 0; i--)
        if (!(fres.length() == 0 &amp;&amp; res[i] == 0))   fres.append(res[i]);

    return fres.length() == 0? &quot;0&quot;:fres.toString();
}
</code></pre><p>A little improvement which record the result from high to low digits in array:</p>
<p>public String multiply(String num1, String num2) {<br>    int m = num1.length(), n = num2.length();<br>    int[] pos = new int[m + n];</p>
<pre><code>for(int i = m - 1; i &gt;= 0; i--) {
    for(int j = n - 1; j &gt;= 0; j--) {
        int mul = (num1.charAt(i) - &apos;0&apos;) * (num2.charAt(j) - &apos;0&apos;); 
        int p1 = i + j, p2 = i + j + 1;
        int sum = mul + pos[p2];

        pos[p1] += sum / 10;
        pos[p2] = (sum) % 10;
    }
}  

StringBuilder sb = new StringBuilder();
for(int p : pos) if(!(sb.length() == 0 &amp;&amp; p == 0)) sb.append(p);
return sb.length() == 0 ? &quot;0&quot; : sb.toString();
</code></pre><p>}</p>
<p>Reference: <a href="https://leetcode.com/discuss/71593/easiest-java-solution-with-graph-explanation" target="_blank" rel="external">https://leetcode.com/discuss/71593/easiest-java-solution-with-graph-explanation</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given two numbers represented as strings, return multiplication of the numbers as a string.</p>
<p>Note]]>
    </summary>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
</feed>
