<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Martin's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-02-15T00:17:51.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Martin]]></name>
    <email><![CDATA[martinglory1992@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Leetcode-Coin Change(Java)]]></title>
    <link href="http://yoursite.com/2016/02/14/Leetcode-Coin-Change-Java/"/>
    <id>http://yoursite.com/2016/02/14/Leetcode-Coin-Change-Java/</id>
    <published>2016-02-15T00:11:50.000Z</published>
    <updated>2016-02-15T00:17:51.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p>
<p>Example 1:<br>coins = [1, 2, 5], amount = 11<br>return 3 (11 = 5 + 5 + 1)</p>
<p>Example 2:<br>coins = [2], amount = 3<br>return -1.</p>
<p>Note:<br>You may assume that you have an infinite number of each kind of coin.</p>
<p><strong>Thinking:</strong></p>
<p>In order to solve this problem, we can use dp which check whether choose current coin to make sure it’s minimum. But using function recursively will waste a lot of time. So we need to use extra space avoiding waste time. Then, we should build up a dp array accroding to the amount of money. Then update the dp value of different amout from zero to the target amout. The DP expression is: dp[i + coins[j]] = Math.min(dp[i + coins[j]], dp[i] + 1)</p>
<p><strong>Solution:</strong></p>
<pre><code>public int coinChange(int[] coins, int amount) {
    int dp[] = new int[amount + 1];
    for (int i = 1; i &lt;= amount; i++) dp[i] = Integer.MAX_VALUE-1;
    for (int i = 0; i &lt;= amount; i++) {
        for (int j = 0; j &lt; coins.length; j++) {
            if (i + coins[j] &lt;= amount)
                dp[i + coins[j]] = Math.min(dp[i + coins[j]], dp[i] + 1);
        }
    }
    return dp[amount] == Integer.MAX_VALUE-1 ? -1 : dp[amount];
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>You are given coins of different denominations and a total amount of money amount. Write a function to ]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Some basic problems]]></title>
    <link href="http://yoursite.com/2016/02/13/Some-basic-problems/"/>
    <id>http://yoursite.com/2016/02/13/Some-basic-problems/</id>
    <published>2016-02-13T23:55:10.000Z</published>
    <updated>2016-02-13T23:56:22.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li>Hanoi:</li>
</ol>
<p><img src="http://my.csdn.net/uploads/201204/23/1335186818_5426.jpg" alt=""></p>
<pre><code>public  void move(int n,char a,char b,char c){  

    if(n==1){  
        System.out.println(&quot;move from &quot;+a+&quot; to &quot;+c);  
    }else{  
        move(n-1, a,c,b);  
        move(1, a, b, c);  
        move(n-1, b, a, c);  
    }  
}  
</code></pre><ol>
<li>Queue:</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<ol>
<li>Hanoi:</li>
</ol>
<p><img src="http://my.csdn.net/uploads/201204/23/1335186818_5426.jpg" alt=""></p>
<pre><code>public  void move(i]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Some thoughts about interview]]></title>
    <link href="http://yoursite.com/2016/02/13/Some-thoughts-about-interview/"/>
    <id>http://yoursite.com/2016/02/13/Some-thoughts-about-interview/</id>
    <published>2016-02-13T22:52:22.000Z</published>
    <updated>2016-02-14T00:01:24.000Z</updated>
    <content type="html"><![CDATA[<p>These days, I have been asked by some questions in interviews. These are not quite difficult questions, but I suppose I didn’t behavior well. There are some reasons I think, and I have to improve it:</p>
<ol>
<li>I am not familiar with the simple and basic question so that I’m not very sure about the solution’s correctness and I have to review it again and again.</li>
<li>My code is not so effienct and some of the interviewers had to remind me that. That’s really terrible but I think they are very nice to let me know that.</li>
<li>My code is not so clean because I didn’t keep a clean mind that time. I suppose it’s kind of nervous that time though I didn’t realize that and I want to solve that problem too hurry. I need to relax my minds next time.</li>
<li>What’s worse, I didn’t have nice communication with interviewers. Because of my bad English and bad preperation for interview. Sorry about that.</li>
</ol>
<p>And below are some questions I have to review:</p>
<ol>
<li>How to realize a queue or stack using array or linkedlist</li>
<li>Binary search and whenever mentioning the sorted array, I think it should come into my mind immediately the binary search</li>
<li>Graph theory about the DFS and BFS</li>
<li>What’s difference between .equals and == in Java</li>
<li>Heap and stack in java</li>
<li>Some detials and desing thoughts of my projects</li>
<li>ood  object oriented design principles (<a href="https://scotch.io/bar-talk/s-o-l-i-d-the-first-five-principles-of-object-oriented-design" target="_blank" rel="external">https://scotch.io/bar-talk/s-o-l-i-d-the-first-five-principles-of-object-oriented-design</a>)</li>
<li>The comparasion between the methods of shortest path (<a href="http://developer.51cto.com/art/201105/262170.htm" target="_blank" rel="external">http://developer.51cto.com/art/201105/262170.htm</a>)</li>
<li>Hanoi (<a href="http://blog.csdn.net/zhutulang/article/details/7491390" target="_blank" rel="external">http://blog.csdn.net/zhutulang/article/details/7491390</a>)</li>
<li>Maze (<a href="http://baobaoyangzhou.blog.163.com/blog/static/11783125020104147195273/" target="_blank" rel="external">http://baobaoyangzhou.blog.163.com/blog/static/11783125020104147195273/</a>)</li>
<li>The realization of DFS not using recursive (<a href="http://blog.csdn.net/lalor/article/details/6845788" target="_blank" rel="external">http://blog.csdn.net/lalor/article/details/6845788</a>) which use stack</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>These days, I have been asked by some questions in interviews. These are not quite difficult questions, but I suppose I didn’t behavior w]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Majority Element II(Java)]]></title>
    <link href="http://yoursite.com/2016/02/10/Leetcode-Majority-Element-II-Java/"/>
    <id>http://yoursite.com/2016/02/10/Leetcode-Majority-Element-II-Java/</id>
    <published>2016-02-11T02:32:38.000Z</published>
    <updated>2016-02-11T02:46:22.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space.</p>
<p>Hint:</p>
<p>How many majority elements could it possibly have?</p>
<p><strong>Thinking:</strong></p>
<p>This question is similar with Majority Element which can be solved by Boyer–Moore majority vote algorithm.</p>
<p><strong>Solution:</strong></p>
<pre><code>public List&lt;Integer&gt; majorityElement(int[] nums) {
    List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
    int count1 = 0, count2 = 0, can1 = 0, can2 = 1;

    for (int num: nums){
        if (num == can1)
            count1++;
        else if (num == can2)
            count2++;
        else if (count1 == 0){
            can1 = num;
            count1 = 1;
        }
        else if (count2 == 0){
            can2 = num;
            count2 = 1;
        }
        else{
            count1--;
            count2--;
        }
    }
    count1 = 0;
    count2 = 0;
    for (int num: nums){
        if (num == can1)
            count1++;
        else if (num == can2)
            count2++;
    }

    if (count1 &gt; nums.length / 3)
        res.add(can1);
    if (count2 &gt; nums.length / 3 &amp;&amp; can1 != can2)
        res.add(can2);

    return res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm ]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Implement Trie (Prefix Tree)(Java)]]></title>
    <link href="http://yoursite.com/2016/02/10/Leetcode-Implement-Trie-Prefix-Tree-Java/"/>
    <id>http://yoursite.com/2016/02/10/Leetcode-Implement-Trie-Prefix-Tree-Java/</id>
    <published>2016-02-11T01:06:45.000Z</published>
    <updated>2016-02-11T01:08:44.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Implement a trie with insert, search, and startsWith methods.</p>
<p>Note:<br>You may assume that all inputs are consist of lowercase letters a-z.</p>
<p><strong>Thinking:</strong></p>
<p>I assume every node has no val, but edges do. So I keep a HashMap for everynode. What’s more, in order to determine whether this node is a leave, I add another boolean value.</p>
<p><strong>Solution:</strong></p>
<pre><code>import java.util.HashMap;

class TrieNode {
    HashMap&lt;Character, TrieNode&gt; edges = new HashMap&lt;Character, TrieNode&gt;();
    boolean leave = false;
    // Initialize your data structure here.
    public TrieNode() {
    }
}

public class Trie {
    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    // Inserts a word into the trie.
    public void insert(String word) {
        TrieNode cur = root;
        for (char c: word.toCharArray()){
            if (!cur.edges.containsKey(c)){
                TrieNode newNode = new TrieNode();
                cur.edges.put(c, newNode);
                cur = newNode;

            }
            else {
                cur = cur.edges.get(c);
            }
        }
        cur.leave = true;
    }

    // Returns if the word is in the trie.
    public boolean search(String word) {
        TrieNode cur = root;
        for (char c: word.toCharArray()){
            if (!cur.edges.containsKey(c)){
                return false;
            }
            else{
                cur = cur.edges.get(c);
            }
        }
        return cur.leave;
    }

    // Returns if there is any word in the trie
    // that starts with the given prefix.
    public boolean startsWith(String prefix) {
        TrieNode cur = root;
        for (char c: prefix.toCharArray()){
            if (!cur.edges.containsKey(c)){
                return false;
            }
            else{
                cur = cur.edges.get(c);
            }
        }
        return true;
    }
}

// Your Trie object will be instantiated and called as such:
// Trie trie = new Trie();
// trie.insert(&quot;somestring&quot;);
// trie.search(&quot;key&quot;);
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Implement a trie with insert, search, and startsWith methods.</p>
<p>Note:<br>You may assume that all i]]>
    </summary>
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
      <category term="Trie" scheme="http://yoursite.com/tags/Trie/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Sqrt(x)(Java)]]></title>
    <link href="http://yoursite.com/2016/02/10/Leetcode-Sqrt-x-Java/"/>
    <id>http://yoursite.com/2016/02/10/Leetcode-Sqrt-x-Java/</id>
    <published>2016-02-11T00:33:22.000Z</published>
    <updated>2016-02-11T00:34:52.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Implement int sqrt(int x).</p>
<p>Compute and return the square root of x.</p>
<p><strong>Thinking:</strong></p>
<p>We can get the answer using bianry search from the range of integer.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int mySqrt(int x) {
    if ( x &lt;= 1 )
        return x;
    int low = 1;
    int high = Integer.MAX_VALUE;
    while (true){
        int mid = low + (high - low) / 2; //in order to avoid overflow
        if (mid &gt; x / mid){
            high = mid - 1;
        }else{
            if ( (mid+1) &gt; x/(mid+1))
                return mid;
            low = mid + 1;
        }
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Implement int sqrt(int x).</p>
<p>Compute and return the square root of x.</p>
<p><strong>Thinking:</st]]>
    </summary>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Course Schedule(Java)]]></title>
    <link href="http://yoursite.com/2016/02/10/Leetcode-Course-Schedule-Java/"/>
    <id>http://yoursite.com/2016/02/10/Leetcode-Course-Schedule-Java/</id>
    <published>2016-02-10T23:16:31.000Z</published>
    <updated>2016-02-11T00:03:03.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>There are a total of n courses you have to take, labeled from 0 to n - 1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p>
<p>For example:</p>
<p>2, [[1,0]]<br>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.</p>
<p>2, [[1,0],[0,1]]<br>There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</p>
<p>Note:<br>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.</p>
<p>click to show more hints.</p>
<p>Hints:<br>This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.<br>Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.<br>Topological sort could also be done via BFS.</p>
<p><strong>Thinking:</strong></p>
<p>We can search it from a arbitary node, can search by DFS. If there is a cycle, we will meet the visited nodes once DFS. So we need a array to hold the visited record. By the way, if we want a topological sort, we can hold a current value which is number of nodes initially and decrese one only when meet a sink node.</p>
<p>For BFS, we can find the nodes whose indegree or outdegree is zero, and search from them. If there is a cycle, the number of nodes searched will less than the exact number because in a cycle no nodes’ indegree or outdegree is zero.</p>
<p><strong>Solution:</strong></p>
<p>DFS:</p>
<pre><code>public boolean canFinish(int numCourses, int[][] prerequisites) {
    if (numCourses &lt;= 1)
        return true;
    ArrayList&lt;HashSet&lt;Integer&gt;&gt; edges = new ArrayList&lt;HashSet&lt;Integer&gt;&gt;(numCourses);
    boolean[] visited = new boolean[numCourses];

    for (int i = 0; i &lt; numCourses; i++)
        edges.add(new HashSet&lt;Integer&gt;());

    for (int[] pre: prerequisites){
        edges.get(pre[0]).add(pre[1]);
    }

    for (int i = 0; i &lt; numCourses; i++){
        if (edges.get(i).size() != 0)
            if (!dfs(edges, i, visited))
                return false;
    }

    return true;
}

private boolean dfs(ArrayList&lt;HashSet&lt;Integer&gt;&gt; edges, int i, boolean[] visited){
    if (visited[i] == true)
        return false;
    visited[i] = true;
    while (edges.get(i).size() != 0){
        int j = edges.get(i).iterator().next();

        if (!dfs(edges, j, visited))
            return false;

        edges.get(i).remove(j);
    }
    visited[i] = false; //there is a cycle only when once DFS, so we change it back when onece DFS is finished
    return true;
}
</code></pre><p>BFS:</p>
<pre><code>    public boolean canFinishBFS(int numCourses, int[][] prerequisites) {
    if (numCourses &lt;= 1)
        return true;
    ArrayList&lt;HashSet&lt;Integer&gt;&gt; edges = new ArrayList&lt;HashSet&lt;Integer&gt;&gt;(numCourses);
    int[] inDegree = new int[numCourses];
    Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;();
    int count = 0;

    for (int i = 0; i &lt; numCourses; i++)
        edges.add(new HashSet&lt;Integer&gt;());

    for (int[] pre: prerequisites){
        if (!edges.get(pre[0]).contains(pre[1])){
            edges.get(pre[0]).add(pre[1]);
            inDegree[pre[1]]++;
        }
    }

    for (int i = 0; i &lt; inDegree.length; i++)
        if (inDegree[i] == 0)
            q.add(i);

    while (!q.isEmpty()){
        int i = q.poll();
        count++;
        while (edges.get(i).size() != 0){
            int j = edges.get(i).iterator().next();
            if (--inDegree[j] == 0)
                q.add(j);
            edges.get(i).remove(j);
        }
    }

    return count == numCourses;
}
</code></pre><p>Simpler and more concise BFS solution:</p>
<p>Reference: <a href="https://leetcode.com/discuss/35578/easy-bfs-topological-sort-java" target="_blank" rel="external">https://leetcode.com/discuss/35578/easy-bfs-topological-sort-java</a></p>
<pre><code>public boolean canFinish(int numCourses, int[][] prerequisites) {
    int[][] matrix = new int[numCourses][numCourses]; // i -&gt; j
    int[] indegree = new int[numCourses];

    for (int i=0; i&lt;prerequisites.length; i++) {
        int ready = prerequisites[i][0];
        int pre = prerequisites[i][1];
        if (matrix[pre][ready] == 0)
            indegree[ready]++; //duplicate case
        matrix[pre][ready] = 1;
    }

    int count = 0;
    Queue&lt;Integer&gt; queue = new LinkedList();
    for (int i=0; i&lt;indegree.length; i++) {
        if (indegree[i] == 0) queue.offer(i);
    }
    while (!queue.isEmpty()) {
        int course = queue.poll();
        count++;
        for (int i=0; i&lt;numCourses; i++) {
            if (matrix[course][i] != 0) {
                if (--indegree[i] == 0)
                    queue.offer(i);
            }
        }
    }
    return count == numCourses;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>There are a total of n courses you have to take, labeled from 0 to n - 1.</p>
<p>Some courses may have ]]>
    </summary>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Graph" scheme="http://yoursite.com/tags/Graph/"/>
    
      <category term="Topological Sort" scheme="http://yoursite.com/tags/Topological-Sort/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Minimum Height Trees(Java)]]></title>
    <link href="http://yoursite.com/2016/02/09/Leetcode-Minimum-Height-Trees-Java/"/>
    <id>http://yoursite.com/2016/02/09/Leetcode-Minimum-Height-Trees-Java/</id>
    <published>2016-02-10T07:10:01.000Z</published>
    <updated>2016-02-10T07:13:33.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.</p>
<p>Format<br>The graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels).</p>
<p>You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.</p>
<p>Example 1:</p>
<p>Given n = 4, edges = [[1, 0], [1, 2], [1, 3]]</p>
<pre><code>  0
  |
  1
 / \
2   3
</code></pre><p>return [1]</p>
<p>Example 2:</p>
<p>Given n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</p>
<pre><code>0  1  2
 \ | /
   3
   |
   4
   |
   5
</code></pre><p>return [3, 4]</p>
<p>Hint:</p>
<p>How many MHTs can a graph have at most?<br>Note:</p>
<p>(1) According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.”</p>
<p>(2) The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.</p>
<p><strong>Thinking:</strong></p>
<p>We should track the path from every leaves until there are only one or two nodes left. In other words, in the middle of the graph will be the root of the minimum height tree.</p>
<p><strong>Solution:</strong></p>
<pre><code>public List&lt;Integer&gt; findMinHeightTrees(int n, int[][] edges) {
    if (n == 1){
        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
        res.add(0);
        return res;
    }
    List&lt;Integer&gt; leaves = new ArrayList&lt;Integer&gt;();
    List&lt;Set&lt;Integer&gt;&gt; adj = new ArrayList&lt;Set&lt;Integer&gt;&gt;(n);
    for (int i = 0; i &lt; n; i++)
        adj.add(new HashSet&lt;Integer&gt;());
    for (int[] edge: edges){
        adj.get(edge[0]).add(edge[1]);
        adj.get(edge[1]).add(edge[0]);
    }
    for (int i = 0; i &lt; n; i++){
        if (adj.get(i).size() == 1)
            leaves.add(i);
    }

    while (n &gt; 2){
        n -= leaves.size();
        List&lt;Integer&gt; newLeaves = new ArrayList&lt;Integer&gt;();
        for (int i: leaves){
            int j = adj.get(i).iterator().next();
            adj.get(j).remove(i);
            if (adj.get(j).size() == 1)
                newLeaves.add(j);
        }
        leaves = newLeaves;
    }

    return leaves;
}
</code></pre><p>Reference:<a href="https://leetcode.com/discuss/71763/share-some-thoughts" target="_blank" rel="external">https://leetcode.com/discuss/71763/share-some-thoughts</a></p>
<p>My previous code(LTE):</p>
<pre><code>public List&lt;Integer&gt; findMinHeightTrees(int n, int[][] edges) {
    List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
    int min = Integer.MAX_VALUE;
    int res1 = -1;
    int res2 = -1;

    for (int i = 0; i &lt; n; i++){
        int temp = bfs(n, i, edges);
        if (temp &lt; min){
            min = temp;
            res1 = i;
        }
        else if (temp == min){
            res2 = i;
        }
    }

    if (res1 != -1)
        res.add(res1);
    if (res2 != -1)
        res.add(res2);

    return res;
}

private int bfs(int n, int i, int[][] edges){
    int height = 0;
    boolean[] used = new boolean[edges.length];
    Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;();
    q.add(i);

    while (!q.isEmpty()){
        int num = q.size();
        while (num &gt; 0){
            int temp = q.poll();
            for (int j = 0; j &lt; edges.length; j++){
                if (edges[j][0] == temp || edges[j][1] == temp){
                    if (used[j] == false){
                        if (edges[j][0] == temp)
                            q.add(edges[j][1]);
                        else
                            q.add(edges[j][0]);
                        used[j] = true;
                    }
                }
            }
            num--;
        }
        height++;
    }

    return height;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>For a undirected graph with tree characteristics, we can choose any node as the root. The result graph ]]>
    </summary>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="Graph" scheme="http://yoursite.com/tags/Graph/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Next Permutation(Java)]]></title>
    <link href="http://yoursite.com/2016/02/09/Leetcode-Next-Permutation-Java/"/>
    <id>http://yoursite.com/2016/02/09/Leetcode-Next-Permutation-Java/</id>
    <published>2016-02-10T03:38:47.000Z</published>
    <updated>2016-02-12T05:44:37.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place, do not allocate extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
<pre><code>1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
</code></pre><p><strong>Thinking:</strong></p>
<p>The method can be described as below:</p>
<p><img src="http://4.bp.blogspot.com/-4zN0u5JG0vs/UN0xPEkP5yI/AAAAAAAAG9Q/O48ZfwB1i_c/s640/Picture4.png" alt=""></p>
<p><strong>Solution:</strong></p>
<pre><code>public void nextPermutation(int[] nums) {
    if (nums == null || nums.length == 0)
        return;
    int i = nums.length - 2;
    while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i+1]){
        i--;
    }

    if (i == -1){
        reverse(nums, 0, nums.length-1);
        return;
    }

    int j = i+1;
    while (j &lt; nums.length &amp;&amp; nums[j] &gt; nums[i]){
        j++;
    }
    j--;
    swap(nums, i, j);
    reverse(nums, i+1, nums.length-1);

    return;
}
private void swap(int[] nums, int i, int j){
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
private void reverse(int[] nums, int i, int j){
    while (i &lt; j){
        swap(nums, i++, j--);
    }
}
</code></pre><p>Reference:<a href="http://fisherlei.blogspot.com/2012/12/leetcode-next-permutation.html" target="_blank" rel="external">http://fisherlei.blogspot.com/2012/12/leetcode-next-permutation.html</a><br><a href="http://www.cnblogs.com/springfor/p/3896245.html" target="_blank" rel="external">http://www.cnblogs.com/springfor/p/3896245.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutatio]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Minimum Size Subarray Sum(Java)]]></title>
    <link href="http://yoursite.com/2016/02/09/Leetcode-Minimum-Size-Subarray-Sum-Java/"/>
    <id>http://yoursite.com/2016/02/09/Leetcode-Minimum-Size-Subarray-Sum-Java/</id>
    <published>2016-02-10T02:56:42.000Z</published>
    <updated>2016-02-10T03:12:51.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an array of n positive integers and a positive integer s, find the minimal length of a subarray of which the sum ≥ s. If there isn’t one, return 0 instead.</p>
<p>For example, given the array [2,3,1,2,4,3] and s = 7,<br>the subarray [4,3] has the minimal length under the problem constraint.</p>
<p>click to show more practice.</p>
<p>More practice:<br>If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).</p>
<p><strong>Thinking:</strong></p>
<p>My method is to hold two pointers, one for current index and the other is for the start pointer. Once we find the sum is bigger than target, we increse the startIndex until its sum is smaller than target. Do it while find the minmun of the length.</p>
<p>But there is still more effienct way to solve this problem. We don’t need to reset the startIndex and sum, we just keep it. And it will be the O(n) solution. (Which called a minmum window method I suppose.)</p>
<p>What’s more, binary search is also valid for this problem. Since all elements are positive, the cumulative sum must be strictly increasing. Then, a subarray sum can expressed as the difference between two cumulative sum. Hence, given a start index for the cumulative sum array, the other end index can be searched using binary search.</p>
<p><strong>Solution:</strong></p>
<p>First version:</p>
<pre><code>public int minSubArrayLen(int s, int[] nums) {
    int min = Integer.MAX_VALUE;
    boolean flag = false;
    int temp = 0;
    int startIndex = 0;

    for ( int i = 0; i &lt; nums.length; i++ ){
         temp += nums[i];
         if (temp &gt;= s){
             while (temp &gt;= s){
                 flag = true;
                 temp -= nums[startIndex++];
             }
             int len = i - startIndex + 2;
             i = startIndex-1;
             if (len &lt; min)
                 min = len;
             temp = 0;
         }

    }
    if (flag)
        return min;
    else
        return 0;
}
</code></pre><p>Revised version:</p>
<pre><code>public int minSubArrayLen(int s, int[] nums) {
    int min = Integer.MAX_VALUE;
    boolean flag = false;
    int temp = 0;
    int startIndex = 0;

    for ( int i = 0; i &lt; nums.length; i++ ){
         temp += nums[i];
         if (temp &gt;= s){
             while (temp &gt;= s){
                 flag = true;
                 temp -= nums[startIndex++];
             }
             int len = i - startIndex + 2;
             if (len &lt; min)
                 min = len;
         }

    }
    if (flag)
        return min;
    else
        return 0;
}
</code></pre><p>Reference Code:(Including O(n) and O(nlgn))<br>Reference:<a href="https://leetcode.com/discuss/35378/solutions-java-with-time-complexity-nlogn-with-explanation" target="_blank" rel="external">https://leetcode.com/discuss/35378/solutions-java-with-time-complexity-nlogn-with-explanation</a></p>
<pre><code>public int minSubArrayLen(int s, int[] nums) {
    return solveNLogN(s, nums);
}

private int solveN(int s, int[] nums) {
    int start = 0, end = 0, sum = 0, minLen = Integer.MAX_VALUE;
    while (end &lt; nums.length) {
        while (end &lt; nums.length &amp;&amp; sum &lt; s) sum += nums[end++];
        if (sum &lt; s) break;
        while (start &lt; end &amp;&amp; sum &gt;= s) sum -= nums[start++];
        if (end - start + 1 &lt; minLen) minLen = end - start + 1;
    }
    return minLen == Integer.MAX_VALUE ? 0 : minLen;
}

private int solveNLogN(int s, int[] nums) {
    int[] sums = new int[nums.length + 1];
    for (int i = 1; i &lt; sums.length; i++) sums[i] = sums[i - 1] + nums[i - 1];
    int minLen = Integer.MAX_VALUE;
    for (int i = 0; i &lt; sums.length; i++) {
        int end = binarySearch(i + 1, sums.length - 1, sums[i] + s, sums);
        if (end == sums.length) break;
        if (end - i &lt; minLen) minLen = end - i;
    }
    return minLen == Integer.MAX_VALUE ? 0 : minLen;
}

private int binarySearch(int lo, int hi, int key, int[] sums) {
    while (lo &lt;= hi) {
       int mid = (lo + hi) / 2;
       if (sums[mid] &gt;= key){
           hi = mid - 1;
       } else {
           lo = mid + 1;
       }
    }
    return lo;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given an array of n positive integers and a positive integer s, find the minimal length of a subarray o]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Ugly Number II(Java)]]></title>
    <link href="http://yoursite.com/2016/02/09/Leetcode-Ugly-Number-II-Java/"/>
    <id>http://yoursite.com/2016/02/09/Leetcode-Ugly-Number-II-Java/</id>
    <published>2016-02-10T01:26:40.000Z</published>
    <updated>2016-02-10T01:31:31.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Write a program to find the n-th ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.</p>
<p>Note that 1 is typically treated as an ugly number.</p>
<p>Hint:</p>
<p>The naive approach is to call isUgly for every number until you reach the nth one. Most numbers are not ugly. Try to focus your effort on generating only the ugly ones.<br>An ugly number must be multiplied by either 2, 3, or 5 from a smaller ugly number.<br>The key is how to maintain the order of the ugly numbers. Try a similar approach of merging from three sorted lists: L1, L2, and L3.<br>Assume you have Uk, the kth ugly number. Then Uk+1 must be Min(L1 <em> 2, L2 </em> 3, L3 * 5).</p>
<p><strong>Thinking:</strong></p>
<p>The main idea of this question is to maintain a min heap and get the minimum from the heap once. Because we can see that, the ugly numbers are as below:</p>
<pre><code>(1) 1×2, 2×2, 3×2, 4×2, 5×2, …
(2) 1×3, 2×3, 3×3, 4×3, 5×3, …
(3) 1×5, 2×5, 3×5, 4×5, 5×5, …
</code></pre><p>Furthermore, we can record different factor’s index in the primes in order to make the algorithm more effienct.</p>
<p><strong>Solution:</strong></p>
<p>(LTE)</p>
<pre><code>public int nthUglyNumber1(int n){
    List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
    PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;Integer&gt;();
    heap.add(1);
    int[] primes = {2, 3, 5};
    while (res.size() != n) {
        int num = heap.poll();
        if (res.size() == 0 || num != res.get(res.size()-1))
            res.add(num);
        for ( int j = 0; j &lt; 3; j++){
            heap.add(num * primes[j]);
        }
    }

    return res.get(n-1);
}
</code></pre><p>(AC)</p>
<pre><code>public int nthUglyNumber2(int n) {
    List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
    res.add(1);
    int[] index = new int[3];
    int[] list = new int[3];
    int[] primes = {2, 3, 5};
    list[0] = 1;
    list[1] = 1;
    list[2] = 1;

    for (int i = 1; i &lt; n; i++){
        for (int j = 0; j &lt; 3; j++){
            list[j] = res.get(index[j]) * primes[j];
        }
        res.add(Math.min(Math.min(list[0], list[1]), list[2]));
        for (int j = 0; j &lt; 3; j++){
            if (list[j] == res.get(res.size()-1))
                index[j]++;
        }
    }

    return res.get(n-1);
}
</code></pre><p>Reference: <a href="https://leetcode.com/discuss/52716/o-n-java-solution" target="_blank" rel="external">https://leetcode.com/discuss/52716/o-n-java-solution</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Write a program to find the n-th ugly number.</p>
<p>Ugly numbers are positive numbers whose prime fact]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Serialize and Deserialize Binary Tree(Java)]]></title>
    <link href="http://yoursite.com/2016/02/09/Leetcode-Serialize-and-Deserialize-Binary-Tree-Java/"/>
    <id>http://yoursite.com/2016/02/09/Leetcode-Serialize-and-Deserialize-Binary-Tree-Java/</id>
    <published>2016-02-09T19:47:14.000Z</published>
    <updated>2016-02-09T20:24:45.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>
<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<p>For example, you may serialize the following tree</p>
<pre><code>  1
 / \
2   3
   / \
  4   5
</code></pre><p>as “[1,2,3,null,null,4,5]”, just the same as how LeetCode OJ serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.<br>Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p>
<p><strong>Thinking:</strong></p>
<p>There are serveral thinkings emerged in my mind when I first saw this question. Firstly, I want to finishi the normal method which is the same as the Leetcode presenting. But it is LTE. Then I searched on the Internet and found my solution’s lack and then solved it.</p>
<p><strong>Solution:</strong></p>
<p>Previous Code:</p>
<pre><code>//normal method
// Encodes a tree to a single string.
public String serialize(TreeNode root) {
    String res = &quot;&quot;;
    if (root == null)
        return res;
    Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;();
    q.add(root);
    res += root.val + &quot;,&quot;;
    while (!q.isEmpty()){
        int num = q.size();
        String nullstr = &quot;&quot;;
        while (num &gt; 0){
            TreeNode n = q.poll();
            if (n.left != null){
                q.add(n.left);
                res += nullstr + n.left.val + &quot;,&quot;;
            }
            else{
                nullstr += &quot;null,&quot;;
            }
            if (n.right != null){
                q.add(n.right);
                res += nullstr + n.right.val + &quot;,&quot;;
            }
            else{
                nullstr += &quot;null,&quot;;
            }
            num--;
        }
    }

    return res;
}

// Decodes your encoded data to tree.
public TreeNode deserialize(String data) {
    TreeNode root;
    if(data.length() == 0)
        return null;
    String[] strs = data.split(&quot;,&quot;);
    root = new TreeNode(Integer.parseInt(strs[0]));
    bfs(root, strs, 1, true);
    bfs(root, strs, 2, false);

    return root;
}
private void bfs(TreeNode node, String[] strs, int index, boolean left){
    if (index &gt;= strs.length)
        return;
    if (strs[index].equals(&quot;null&quot;))
        return;
    TreeNode newNode = new TreeNode(Integer.parseInt(strs[index]));
    if (left){
        node.left = newNode;
    }
    else{
        node.right = newNode;
    }
    bfs(newNode, strs, index*2+1, true);
    bfs(newNode, strs, index*2+2, false);
}
</code></pre><p>Reference Code(<a href="http://blog.csdn.net/ljiabin/article/details/49474445" target="_blank" rel="external">http://blog.csdn.net/ljiabin/article/details/49474445</a>):</p>
<pre><code>public String serialize(TreeNode root) {
    StringBuilder sb = new StringBuilder();

    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();
    queue.offer(root);

    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        if (node == null) {
            sb.append(&quot;null,&quot;);
        } else {
            sb.append(String.valueOf(node.val) + &quot;,&quot;);
            queue.offer(node.left);
            queue.offer(node.right);
        }
    }

    return sb.toString();
}

// Decodes your encoded data to tree.
public TreeNode deserialize(String data) {
    if (data.isEmpty()) return null;

    String[] vals = data.split(&quot;,&quot;);
    int[] nums = new int[vals.length];
    TreeNode[] nodes = new TreeNode[vals.length];

    for (int i = 0; i &lt; vals.length; i++) {
        if (i &gt; 0) {
            nums[i] = nums[i - 1];
        }
        if (vals[i].equals(&quot;null&quot;)) {
            nodes[i] = null;
            nums[i]++;
        } else {
            nodes[i] = new TreeNode(Integer.parseInt(vals[i]));
        }
    }

    for (int i = 0; i &lt; vals.length; i++) {
        if (nodes[i] == null) {
            continue;
        }
        nodes[i].left = nodes[2 * (i - nums[i]) + 1];
        nodes[i].right = nodes[2 * (i - nums[i]) + 2];
    }

    return nodes[0];
}
</code></pre><p>}</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Serialization is the process of converting a data structure or object into a sequence of bits so that i]]>
    </summary>
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Remove Duplicates from Sorted List II(Java)]]></title>
    <link href="http://yoursite.com/2016/02/08/Leetcode-Remove-Duplicates-from-Sorted-List-II-Java/"/>
    <id>http://yoursite.com/2016/02/08/Leetcode-Remove-Duplicates-from-Sorted-List-II-Java/</id>
    <published>2016-02-09T05:11:32.000Z</published>
    <updated>2016-02-09T05:15:49.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p>
<p>For example,<br>Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.<br>Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3.</p>
<p><strong>Thinking:</strong></p>
<p>It’s similar with other linked list question. We should build a dummy node before the head. Hold three pointers to operate the next pointer of these nodes.</p>
<p><strong>Solution:</strong></p>
<pre><code>public ListNode deleteDuplicates(ListNode head) {
    if (head == null)
        return head;
    ListNode dummy = new ListNode(head.val-1);
    dummy.next = head;
    ListNode pre = dummy;
    ListNode p = head;
    ListNode next = head.next;
    while (next != null){
        if (p.val == next.val){
            while (next != null &amp;&amp; p.val == next.val){
                next = next.next;
            }
            pre.next = next;
            if (next == null){
                break;
            } else{
                p = next;
                next = next.next;
            }
        } else{
            pre = p;
            p = p.next;
            next = next.next;
        }
    }

    return dummy.next;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers]]>
    </summary>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Group Anagrams(Java)]]></title>
    <link href="http://yoursite.com/2016/02/08/Leetcode-Group-Anagrams-Java/"/>
    <id>http://yoursite.com/2016/02/08/Leetcode-Group-Anagrams-Java/</id>
    <published>2016-02-09T05:02:42.000Z</published>
    <updated>2016-02-09T05:10:09.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an array of strings, group anagrams together.</p>
<p>For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>Return:</p>
<pre><code>[
  [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;],
  [&quot;nat&quot;,&quot;tan&quot;],
  [&quot;bat&quot;]
]
</code></pre><p>Note:<br>For the return value, each inner list’s elements must follow the lexicographic order.<br>All inputs will be in lower-case.</p>
<p><strong>Thinking:</strong></p>
<p>This question took me a lot of time. First, I want to get a String from the list, and check its anagrams with the rest of the list. And write the algorithm about the anagrams check. But time exceed. Then I try to change my thinking mode of this problem. We should consider the whole String as a element, and if two strings are anagrams, their new string with sorting are the same. So if we use a hashmap to store its previous string and sorted string, the problem will be easy to solve. So we build a hashmap, its key is the string element from the list, and its value is a new list which contains its key’s anagrams. Finally, we get the results from the hashmap and sort them by Collections.sort method.</p>
<p><strong>Solution:</strong></p>
<pre><code>public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) {
    int count = strs.length;
    List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;List&lt;String&gt;&gt;();
    if (count == 0)
        return res;
    HashMap&lt;String, List&lt;String&gt;&gt; hash = new HashMap&lt;String, List&lt;String&gt;&gt;();

    for (String str: strs){
        char[] ca = str.toCharArray();
        Arrays.sort(ca);
        String temp = new String(ca);
        if (hash.containsKey(temp)){
            hash.get(temp).add(str);
        }else{
            List&lt;String&gt; tempres = new ArrayList&lt;String&gt;();
            tempres.add(str);
            hash.put(temp, tempres);
        }
    }

    for (List&lt;String&gt; l: hash.values()){
        Collections.sort(l);
        res.add(l);
    }

    return res;
}
</code></pre><p>Reference:<a href="https://en.wikipedia.org/wiki/Anagram" target="_blank" rel="external">https://en.wikipedia.org/wiki/Anagram</a><br><a href="http://javaconceptoftheday.com/anagram-program-in-java/" target="_blank" rel="external">http://javaconceptoftheday.com/anagram-program-in-java/</a><br><a href="http://www.cnblogs.com/springfor/p/3874667.html" target="_blank" rel="external">http://www.cnblogs.com/springfor/p/3874667.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given an array of strings, group anagrams together.</p>
<p>For example, given: [“eat”, “tea”, “tan”, “a]]>
    </summary>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Number of Islands(Java)]]></title>
    <link href="http://yoursite.com/2016/02/05/Leetcode-Number-of-Islands-Java/"/>
    <id>http://yoursite.com/2016/02/05/Leetcode-Number-of-Islands-Java/</id>
    <published>2016-02-06T07:08:03.000Z</published>
    <updated>2016-02-06T07:10:51.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p>Example 1:</p>
<pre><code>11110
11010
11000
00000
</code></pre><p>Answer: 1</p>
<p>Example 2:</p>
<pre><code>11000
11000
00100
00011
</code></pre><p>Answer: 3</p>
<p><strong>Thinking:</strong></p>
<p>If we find a island that we didn’t find before, we will use DFS or BFS find the whole land and change its value which will avoid find it again next time.</p>
<p><strong>Solution:</strong></p>
<pre><code>private int m, n;

public int numIslands(char[][] grid) {
    m = grid.length;
    if (m == 0) return 0;
    n = grid[0].length;
    if (n == 0) return 0;

    int ans = 0;
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (grid[i][j] != &apos;1&apos;) continue;

            ans++;
            dfs(grid, i, j);
        }
    }
    return ans;
}


public void dfs(char[][] grid, int i, int j) {
    if (i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n) return;

    if (grid[i][j] == &apos;1&apos;) {
        grid[i][j] = &apos;2&apos;;
        dfs(grid, i - 1, j);
        dfs(grid, i + 1, j);
        dfs(grid, i, j - 1);
        dfs(grid, i, j + 1);
    }
}
</code></pre><p>Reference: <a href="http://blog.csdn.net/ljiabin/article/details/44975717" target="_blank" rel="external">http://blog.csdn.net/ljiabin/article/details/44975717</a></p>
<p><strong>My Stupid Solution::</strong></p>
<pre><code>int res = 0;
public int numIslands(char[][] grid) {
    int rl = grid.length;
    if (rl == 0)
        return 0;
    int cl = grid[0].length;
    int[][] record = new int[rl][cl];
    int[][] visited = new int[rl][cl];


    for (int i = 0; i &lt; rl; i++) {
        for (int j = 0; j &lt; cl; j++) {
            dfsCheck(i, j, grid, record, visited);
        }
    }
    return res;
}

private void dfsCheck(int m, int n, char[][] grid, int[][] record, int[][] visited){
    if (visited[m][n] == 1)
        return;
    visited[m][n] = 1;
    int flag = 0;
    if (grid[m][n] == &apos;1&apos;){
        if (record[m][n] == 0){
            for (int i = -1; i &lt; 2; i++){
                for (int j = -1; j &lt; 2; j++){
                    if (m+i&gt;=0 &amp;&amp; m+i &lt;grid.length &amp;&amp; n+j&gt;=0 &amp;&amp; n+j&lt;grid[0].length &amp;&amp; (i+j == -1 || i+j == 1)){
                        if (record[m+i][n+j] != 0){
                            record[m][n] = record[m+i][n+j];
                            flag = 1;
                        }
                    }
                }
            }
            if (flag == 0)
                record[m][n] = ++res;
        }

        //extension
        for (int i = -1; i &lt; 2; i++){
            for (int j = -1; j &lt; 2; j++){
                if (m+i&gt;=0 &amp;&amp; m+i &lt;grid.length &amp;&amp; n+j&gt;=0 &amp;&amp; n+j&lt;grid[0].length &amp;&amp; (i+j == -1 || i+j == 1)){
                    if (grid[m+i][n+j] == &apos;1&apos; &amp;&amp; visited[m+i][n+j] == 0)
                        dfsCheck(m+i, n+j, grid, record, visited);
                }
            }
        }
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surround]]>
    </summary>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Gas Station(Java)]]></title>
    <link href="http://yoursite.com/2016/02/05/Leetcode-Gas-Station-Java/"/>
    <id>http://yoursite.com/2016/02/05/Leetcode-Gas-Station-Java/</id>
    <published>2016-02-06T05:53:09.000Z</published>
    <updated>2016-02-06T05:57:44.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].</p>
<p>You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.</p>
<p>Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1.</p>
<p>Note:<br>The solution is guaranteed to be unique.</p>
<p><strong>Thinking:</strong></p>
<p>Nomally, it can be sovled in n^2 time complexity, check every station whether it is possible. But it will be LTE, so we need a greedy method to sovle this problem. In fact, if previous result of total gas is larger than 0, and current gas station don’t meet the needs, it means all of the previous gas station is not valid. What’s more, it assumes there is only one solution, so what we need to do is to record the fisrt valid station index. In order to check whether it is valid, we also need another variable total to determine whether the set is valid.</p>
<p><strong>Solution1:</strong>(LTM)</p>
<pre><code>public int canCompleteCircuit1(int[] gas, int[] cost) {
    int len = gas.length;

    for (int i = 0; i &lt; len; i++){
        int curGas = 0;
        for (int j = i; ; j++){
            curGas += gas[j%len];
            curGas -= cost[j%len];
            if (curGas &lt; 0)
                break;
            if (j - len == i - 1){
                return i;
            }
        }
    }

    return -1;
}
</code></pre><p><strong>Solution2:</strong>(Greedy)</p>
<pre><code>public int canCompleteCircuit(int[] gas, int[] cost) {
    int len = gas.length;
    int curSum = 0;
    int total = 0;
    int index = 0;

    for (int i = 0; i &lt; len; i++){
        curSum += gas[i] - cost[i];
        total += gas[i] - cost[i];
        if (curSum &lt; 0){
            curSum = 0;
            index = i + 1;
        }
    }
    if (total &lt; 0)
        return -1;
    else
        return index;

}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].</p>
<p]]>
    </summary>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git Note]]></title>
    <link href="http://yoursite.com/2016/02/02/Git-Note/"/>
    <id>http://yoursite.com/2016/02/02/Git-Note/</id>
    <published>2016-02-03T03:13:02.000Z</published>
    <updated>2016-02-03T06:10:46.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li>git branch [-a] look at the branches you’ve visited</li>
<li>git branch <branch_name> create a new branch from the current commit version</branch_name></li>
<li>git checkout -b <branch_name></branch_name></li>
<li>git -d branch_name</li>
<li>git merge</li>
<li>git stash</li>
<li>git push -f</li>
<li>git checkout <commit_id></commit_id></li>
<li>git checkout -b new_master</li>
<li>git branch -d master</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<ol>
<li>git branch [-a] look at the branches you’ve visited</li>
<li>git branch <branch_name> create a new branch from the current commit v]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Restore IP Addresses(Java)]]></title>
    <link href="http://yoursite.com/2016/02/02/Leetcode-Restore-IP-Addresses-Java/"/>
    <id>http://yoursite.com/2016/02/02/Leetcode-Restore-IP-Addresses-Java/</id>
    <published>2016-02-02T23:49:57.000Z</published>
    <updated>2016-02-02T23:53:47.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p>
<p>For example:<br>Given “25525511135”,</p>
<p>return [“255.255.11.135”, “255.255.111.35”]. (Order does not matter)</p>
<p><strong>Thinking:</strong></p>
<p>Valid IP address is between 0 and 255, so we can once detect one to three digits of the string. What’s more, it’s not valid if there is number like “001”. Use bactracing select one to three digits once, and go farther until all the substrings are selected and there are four parts of the result. Then put the result in the list. We should also detect the length of the String because if the length is not between 4 and 12, it’s invalid.</p>
<p><strong>Solution:</strong></p>
<pre><code>public List&lt;String&gt; restoreIpAddresses(String s) {
    List&lt;String&gt; res = new ArrayList&lt;String&gt;();

    if (s.length() &lt; 4)
        return res;
    if (s.length() &gt; 12)
        return res;

    backtracing(s, 0, new ArrayList&lt;String&gt;(), res);

    return res;
}

public void backtracing(String s, int start, List&lt;String&gt; tempres, List&lt;String&gt; res){
    if (start == s.length()){
        if (tempres.size() == 4){
            String tempstr = &quot;&quot;;
            tempstr = tempres.get(0) + &quot;.&quot; + tempres.get(1) + &quot;.&quot; + tempres.get(2) + &quot;.&quot; + tempres.get(3);
            res.add(tempstr);
        }
        else{
            return;
        }
    }

    for (int i = start+1; i &lt;= s.length(); i++){
        if (s.charAt(start) == &apos;0&apos; &amp;&amp; i != start+1)
            continue;
        if (i - start &gt; 3)
            break;
        int num = Integer.parseInt(s.substring(start, i));
        if (num &gt; 255)
            break;
        else{
            tempres.add(s.substring(start, i));
            backtracing(s, i, tempres, res);
            tempres.remove(tempres.size() - 1);
        }
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a string containing only digits, restore it by returning all possible valid IP address combinatio]]>
    </summary>
    
      <category term="Backtracing" scheme="http://yoursite.com/tags/Backtracing/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Combination Sum II(Java)]]></title>
    <link href="http://yoursite.com/2016/02/02/Leetcode-Combination-Sum-II-Java/"/>
    <id>http://yoursite.com/2016/02/02/Leetcode-Combination-Sum-II-Java/</id>
    <published>2016-02-02T23:09:18.000Z</published>
    <updated>2016-02-02T23:15:50.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p>
<p>Each number in C may only be used once in the combination.</p>
<p>Note:<br>All numbers (including target) will be positive integers.<br>Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).<br>The solution set must not contain duplicate combinations.<br>For example, given candidate set 10,1,2,7,6,1,5 and target 8,<br>A solution set is:<br>[1, 7]<br>[1, 2, 5]<br>[2, 6]<br>[1, 1, 6] </p>
<p><strong>Thinking:</strong></p>
<p>We should use backtracing to trace all the possible answers. In order to remove duplicate, there are two methods. One is to use hashset, the other is to build a visited array, if the same value is not visited, then don’t visit the value. And there two ways to backtracing, one is to use the return value, and the other is to pass the fucntion value.</p>
<p><strong>Solution1:</strong></p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) {
    Arrays.sort(candidates);
    return backtracing(candidates, target, 0);
}

public List&lt;List&lt;Integer&gt;&gt; backtracing(int [] candidates, int target, int left){
    HashSet&lt;List&lt;Integer&gt;&gt; tres = new HashSet&lt;List&lt;Integer&gt;&gt;();
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    int right = candidates.length-1;

    if (left &gt; right){
        return res;
    }
    if (target &lt; candidates[left]){
        return res;
    }
    if (target == candidates[left]){
        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        list.add(candidates[left]);
        res.add(list);
        return res;
    }
    if (left == right){
        return res;
    }

    for (int i = left; i &lt;= right; i++){
        for (List&lt;Integer&gt; list: backtracing(candidates, target-candidates[i], i+1)){
            list.add(0, candidates[i]);
            tres.add(list);
        }
        for (List&lt;Integer&gt; list: backtracing(candidates, target, i+1)){
            tres.add(list);
        }
    }

    res.addAll(tres);
    return res;
}
</code></pre><p><strong>Solution2:</strong></p>
<pre><code>public static ArrayList&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) {  
    ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();  
    ArrayList&lt;Integer&gt; item = new ArrayList&lt;Integer&gt;();
    if(candidates == null || candidates.length==0)  
        return res; 

    Arrays.sort(candidates);  
    boolean [] visited = new boolean[candidates.length];
    helper(candidates,target, 0, item ,res, visited);  
    return res;  
}  

private static void helper(int[] candidates, int target, int start, List&lt;Integer&gt; item,   
ArrayList&lt;List&lt;Integer&gt;&gt; res, boolean[] visited){  
    if(target&lt;0)  
        return;  
    if(target==0){  
        res.add(new ArrayList&lt;Integer&gt;(item));  
        return;
    }

    for(int i=start;i&lt;candidates.length;i++){
        if(!visited[i]){
            if(i&gt;0 &amp;&amp; candidates[i] == candidates[i-1] &amp;&amp; visited[i-1]==false)//deal with dupicate
                continue;  
            item.add(candidates[i]);
            visited[i]=true;
            int newtarget = target - candidates[i];
            helper(candidates,newtarget,i+1,item,res,visited);  
            visited[i]=false;
            item.remove(item.size()-1);  
        }
    }  
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C ]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Backtracing" scheme="http://yoursite.com/tags/Backtracing/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Reverse Linked List II(Java)]]></title>
    <link href="http://yoursite.com/2016/02/02/Leetcode-Reverse-Linked-List-II-Java/"/>
    <id>http://yoursite.com/2016/02/02/Leetcode-Reverse-Linked-List-II-Java/</id>
    <published>2016-02-02T21:50:10.000Z</published>
    <updated>2016-02-02T23:09:54.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p>
<p>For example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,</p>
<p>return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL.</p>
<p>Note:<br>Given m, n satisfy the following condition:<br>1 ≤ m ≤ n ≤ length of list.</p>
<p><strong>Thinking:</strong></p>
<p>It’s similar with Reverse Linked List, only thing different is to limit the range. So we should to find the start of the reversed linked list and record its previous node. Also, we should add a dummy node for easily operator with the first node. Then use three points as usual pre, cur and next to operate and change the nodes’ next pointers.</p>
<p><strong>Solution:</strong></p>
<pre><code>public ListNode reverseBetween(ListNode head, int m, int n) {
    if (m == n)
        return head;
    ListNode prehead = new ListNode(0);//dummy
    prehead.next = head;
    ListNode pre = prehead;
    ListNode cur = head;
    int idx = 1;

    while (idx &lt; m) {
        pre = cur;
        cur = cur.next;
        idx++;
    }
    ListNode prerever = pre;
    ListNode next = null;
    pre = cur;
    cur = cur.next;
    while (idx &lt; n) {
        next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
        idx++;
    }
    prerever.next.next = cur;
    prerever.next = pre;


    return prehead.next;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p>
<p>For example:<br>Give]]>
    </summary>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
</feed>
