<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Martin's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-02-25T22:56:13.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Martin]]></name>
    <email><![CDATA[martinglory1992@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Leetcode-Simplify Path(Java)]]></title>
    <link href="http://yoursite.com/2016/02/25/Leetcode-Simplify-Path-Java/"/>
    <id>http://yoursite.com/2016/02/25/Leetcode-Simplify-Path-Java/</id>
    <published>2016-02-25T22:47:27.000Z</published>
    <updated>2016-02-25T22:56:13.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an absolute path for a file (Unix-style), simplify it.</p>
<p>For example,<br>path = “/home/“, =&gt; “/home”<br>path = “/a/./b/../../c/“, =&gt; “/c”<br>click to show corner cases.</p>
<p>Corner Cases:<br>Did you consider the case where path = “/../“?<br>In this case, you should return “/“.<br>Another corner case is the path might contain multiple slashes ‘/‘ together, such as “/home//foo/“.<br>In this case, you should ignore redundant slashes and return “/home/foo”.</p>
<p><strong>Thinking:</strong></p>
<p>The file system is like a tree, and finding path of this tree is like a dfs process. So we can use stack to track the node of dfs. If the string is “..”, we go back, otherwise go to the given dirctory.</p>
<p><strong>Solution:</strong></p>
<pre><code>public String simplifyPath(String path) {
    Stack&lt;String&gt; stack = new Stack&lt;String&gt;();
    String[] paths = path.split(&quot;/&quot;);

    for (String p: paths) {
        p = p.trim();
        if (p.equals(&quot;&quot;) || p.equals(&quot;.&quot;))    continue;
        if (p.equals(&quot;..&quot;))    {
            if (!stack.isEmpty()) {
                stack.pop();
            }
            continue;
        }
        stack.push(p);
    }

    StringBuilder res = new StringBuilder();
    while (!stack.isEmpty()) 
        res.insert(0, &quot;/&quot;.concat(stack.pop()));


    return res.length() == 0? &quot;/&quot;:res.toString();
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given an absolute path for a file (Unix-style), simplify it.</p>
<p>For example,<br>path = “/home/“, =&]]>
    </summary>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Word Search(Java)]]></title>
    <link href="http://yoursite.com/2016/02/25/Leetcode-Word-Search-Java/"/>
    <id>http://yoursite.com/2016/02/25/Leetcode-Word-Search-Java/</id>
    <published>2016-02-25T21:44:36.000Z</published>
    <updated>2016-02-25T21:49:05.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p>For example,<br>Given board =</p>
<p>[<br>  [‘A’,’B’,’C’,’E’],<br>  [‘S’,’F’,’C’,’S’],<br>  [‘A’,’D’,’E’,’E’]<br>]<br>word = “ABCCED”, -&gt; returns true,<br>word = “SEE”, -&gt; returns true,<br>word = “ABCB”, -&gt; returns false.</p>
<p><strong>Thinking:</strong></p>
<p>I assume it’s graph and do dfs in this 2d array. Start from every point and search the result until find the solution or failure. In this process, we need to record the visitied set. In my solution, I used the hashset. But in more efficient way, we can use bit manipulate to mask the visited element.</p>
<p><strong>Solution:</strong></p>
<p>My solution(use HashSet):</p>
<pre><code>public boolean exist(char[][] board, String word) {
    int m = board.length;
    if (m == 0)    return false;
    int n = board[0].length;
    Set&lt;Integer&gt; record = new HashSet&lt;Integer&gt;();
    for (int i = 0; i &lt; m; i++)
        for (int j = 0; j &lt; n; j++)
            if (backtracking(board, word, 0, i, j, record))    return true;
    return false;
}

private boolean backtracking(char[][] board, String word, int index, int i, int j, Set&lt;Integer&gt; record) {
    if (board[i][j] == word.charAt(index) &amp;&amp; !record.contains(i*board[0].length+j)){
        if (index == word.length()-1)    return true;
        boolean res = false;
        record.add(i*board[0].length+j);
        if (i-1&gt;=0)    res |= backtracking(board, word, index+1, i-1, j, record);
        if (!res &amp;&amp; i+1&lt;board.length) res |= backtracking(board, word, index+1, i+1, j, record);
        if (!res &amp;&amp; j-1&gt;=0)    res |= backtracking(board, word, index+1, i, j-1, record);
        if (!res &amp;&amp; j+1&lt;board[0].length) res |= backtracking(board, word, index+1, i, j+1, record);
        record.remove(i*board[0].length+j);
        return res;
    }
    return false;
}
</code></pre><p>use the mask:</p>
<pre><code>public boolean exist(char[][] board, String word) {
    char[] w = word.toCharArray();
    for (int y=0; y&lt;board.length; y++) {
        for (int x=0; x&lt;board[y].length; x++) {
            if (exist(board, y, x, w, 0)) return true;
        }
    }
    return false;
}

private boolean exist(char[][] board, int y, int x, char[] word, int i) {
    if (i == word.length) return true;
    if (y&lt;0 || x&lt;0 || y == board.length || x == board[y].length) return false;
    if (board[y][x] != word[i]) return false;
        board[y][x] ^= 256;
    boolean exist = exist(board, y, x+1, word, i+1)
    || exist(board, y, x-1, word, i+1)
    || exist(board, y+1, x, word, i+1)
    || exist(board, y-1, x, word, i+1);
    board[y][x] ^= 256;
    return exist;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed fr]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Spiral Matrix(Java)]]></title>
    <link href="http://yoursite.com/2016/02/23/Leetcode-Spiral-Matrix-Java/"/>
    <id>http://yoursite.com/2016/02/23/Leetcode-Spiral-Matrix-Java/</id>
    <published>2016-02-24T04:12:38.000Z</published>
    <updated>2016-02-24T04:14:10.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p>
<p>For example,<br>Given the following matrix:</p>
<pre><code>[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
</code></pre><p>You should return [1,2,3,6,9,8,7,4,5].</p>
<p><strong>Thinking:</strong></p>
<p>There are four directions can go, move according to the order of right, down, left, up and check the bound of moving.</p>
<p><strong>Solution:</strong></p>
<pre><code>public List&lt;Integer&gt; spiralOrder(int[][] matrix) {
    List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
    int m = matrix.length;
    if (m == 0)    return res;
    int n = matrix[0].length;
    int direction = 0;//0right, 1down, 2left, 3up
    int i = 0, j = 0;//position
    int c0 = 1, c1 = 1, c2 = 0, c3 = 1;//row and column limit

    while (c0 + c2 - 1 &lt;= n &amp;&amp; c1 + c3 - 1 &lt;= m) {
        res.add(matrix[i][j]);
        switch (direction) {
        case 0:
            if (j == n-c0){
                direction = (direction+1) % 4;
                c0++;
                res.remove(res.size()-1);
            }
            else
                j++;
            break;
        case 1:
            if (i == m-c1){
                direction = (direction+1) % 4;
                c1++;
                res.remove(res.size()-1);
            }
            else
                i++;
            break;
        case 2:
            if (j == c2){
                direction = (direction+1) % 4;
                c2++;
                res.remove(res.size()-1);
            }
            else
                j--;
            break;
        case 3:
            if (i == c3){
                direction = (direction+1) % 4;
                c3++;
                res.remove(res.size()-1);
            }
            else
                i--;
            break;
        }
    }
    res.add(matrix[i][j]);

    return res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Multiply Strings(Java)]]></title>
    <link href="http://yoursite.com/2016/02/23/Leetcode-Multiply-Strings-Java/"/>
    <id>http://yoursite.com/2016/02/23/Leetcode-Multiply-Strings-Java/</id>
    <published>2016-02-24T03:09:09.000Z</published>
    <updated>2016-02-24T03:20:12.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given two numbers represented as strings, return multiplication of the numbers as a string.</p>
<p>Note: The numbers can be arbitrarily large and are non-negative.</p>
<p><strong>Thinking:</strong></p>
<p>Simulate the process of multiplying.</p>
<p><img src="https://drscdn.500px.org/photo/130178585/m%3D2048/300d71f784f679d5e70fadda8ad7d68f" alt=""></p>
<p><strong>Solution:</strong> (Record the result from low digits to high digits in array)</p>
<pre><code>public String multiply(String num1, String num2) {
    int l1 = num1.length(), l2 = num2.length();
    int[] res = new int[l1+l2];

    for (int i = l1-1; i &gt;= 0; i--) {
        for (int j = l2-1; j &gt;= 0; j--){
            int index = l1+l2-i-j-2;
            res[index] += (num1.charAt(i) - &apos;0&apos;) * (num2.charAt(j) - &apos;0&apos;);
            res[index+1] += res[index] / 10;
            res[index] = res[index] % 10;
        }
    }

    StringBuilder fres = new StringBuilder();
    for (int i = res.length-1; i &gt;= 0; i--)
        if (!(fres.length() == 0 &amp;&amp; res[i] == 0))   fres.append(res[i]);

    return fres.length() == 0? &quot;0&quot;:fres.toString();
}
</code></pre><p>A little improvement which record the result from high to low digits in array:</p>
<p>public String multiply(String num1, String num2) {<br>    int m = num1.length(), n = num2.length();<br>    int[] pos = new int[m + n];</p>
<pre><code>for(int i = m - 1; i &gt;= 0; i--) {
    for(int j = n - 1; j &gt;= 0; j--) {
        int mul = (num1.charAt(i) - &apos;0&apos;) * (num2.charAt(j) - &apos;0&apos;); 
        int p1 = i + j, p2 = i + j + 1;
        int sum = mul + pos[p2];

        pos[p1] += sum / 10;
        pos[p2] = (sum) % 10;
    }
}  

StringBuilder sb = new StringBuilder();
for(int p : pos) if(!(sb.length() == 0 &amp;&amp; p == 0)) sb.append(p);
return sb.length() == 0 ? &quot;0&quot; : sb.toString();
</code></pre><p>}</p>
<p>Reference: <a href="https://leetcode.com/discuss/71593/easiest-java-solution-with-graph-explanation" target="_blank" rel="external">https://leetcode.com/discuss/71593/easiest-java-solution-with-graph-explanation</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given two numbers represented as strings, return multiplication of the numbers as a string.</p>
<p>Note]]>
    </summary>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Rotate List(Java)]]></title>
    <link href="http://yoursite.com/2016/02/23/Leetcode-Rotate-List-Java/"/>
    <id>http://yoursite.com/2016/02/23/Leetcode-Rotate-List-Java/</id>
    <published>2016-02-24T00:27:32.000Z</published>
    <updated>2016-02-24T00:29:56.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a list, rotate the list to the right by k places, where k is non-negative.</p>
<p>For example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,<br>return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.</p>
<p><strong>Thinking:</strong></p>
<p>Firstly, count the length of the linked list. Then get the n-k th node. Finnaly, change the pointer of it and the tail.</p>
<p><strong>Solution:</strong></p>
<pre><code>public ListNode rotateRight(ListNode head, int k) {
    if (head == null || head.next == null)    return head;
    ListNode p = head;
    int count = 1;
    while (p.next != null) {
        p = p.next;
        count++;
    }
    if (k == count)    return head;
    p.next = head;
    p = head;
    for (int i = 1; i &lt; count - k%count; i++) {
        p = p.next;
    }
    ListNode nhead = p.next;
    p.next = null;

    return nhead;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a list, rotate the list to the right by k places, where k is non-negative.</p>
<p>For example:<br]]>
    </summary>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Remove Duplicate Letters(Java)]]></title>
    <link href="http://yoursite.com/2016/02/23/Leetcode-Remove-Duplicate-Letters-Java/"/>
    <id>http://yoursite.com/2016/02/23/Leetcode-Remove-Duplicate-Letters-Java/</id>
    <published>2016-02-23T21:56:43.000Z</published>
    <updated>2016-02-23T22:59:13.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.</p>
<p>Example:<br>Given “bcabc”<br>Return “abc”</p>
<p>Given “cbacdcbc”<br>Return “acdb”</p>
<p><strong>Thinking:</strong></p>
<p>Record the times characters emerges in the list and check from left to right.Record the smallest character postion of the list until find the unique character, then delete the bigger characters before smallest one and delete smallest from the rest of list.</p>
<p><strong>Solution:</strong></p>
<pre><code>public String removeDuplicateLetters(String s) {
    int[] count = new int[26];
    int smallest = 0;
    if (s.length() == 0)    return &quot;&quot;;
    for (char c: s.toCharArray())    count[c-&apos;a&apos;]++;
    for (int i = 0; i &lt; s.length(); i++){
        if (s.charAt(i) &lt; s.charAt(smallest))    smallest = i;
        if (--count[s.charAt(i) - &apos;a&apos;] == 0)    break;
    }
    return s.charAt(smallest) + removeDuplicateLetters(s.substring(smallest+1).replaceAll(s.charAt(smallest)+&quot;&quot;, &quot;&quot;));
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a string which contains only lowercase letters, remove duplicate letters so that every letter app]]>
    </summary>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Number of Digit One(Java)]]></title>
    <link href="http://yoursite.com/2016/02/23/Leetcode-Number-of-Digit-One-Java/"/>
    <id>http://yoursite.com/2016/02/23/Leetcode-Number-of-Digit-One-Java/</id>
    <published>2016-02-23T21:51:33.000Z</published>
    <updated>2016-02-23T21:56:23.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.</p>
<p>For example:<br>Given n = 13,<br>Return 6, because digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.</p>
<p>Hint:</p>
<p>Beware of overflow.</p>
<p><strong>Thinking:</strong></p>
<p>This is question to find formula. We should notice that: </p>
<pre><code>1                   1                                                                                     [1, 9]

11                 10  11  12  13  14  15  16  17  18  19                              [10, 19]

1                   21                                                                                   [20, 29]

1                   31                                                                                   [30, 39]

1                   41                                                                                   [40, 49]

1                   51                                                                                   [50, 59]

1                   61                                                                                   [60, 69]

1                   71                                                                                   [70, 79]

1                   81                                                                                   [80, 89]

1                   91                                                                                   [90, 99]

11                 100  101  102  103  104  105  106  107  108  109          [100, 109]

21                 110  111  112  113  114  115  116  117  118  119             [110, 119]

11                 120  121  122  123  124  125  126  127  128  129          [120, 129]
</code></pre><p>We should divide it into three situations in every digit division: one is bigger than 2, another is equal to 1 and the rest is less than 0. </p>
<p><strong>Solution:</strong></p>
<pre><code>public int countDigitOne(int n) {
    int res = 0;
    for (long m = 1; m &lt;= n; m*=10) {
        res += (n/m + 8) / 10 * m + (n/m % 10 == 1? n%m+1:0);
    }
    return res;
}
</code></pre><p>Reference: <a href="https://leetcode.com/discuss/44281/4-lines-o-log-n-c-java-python" target="_blank" rel="external">https://leetcode.com/discuss/44281/4-lines-o-log-n-c-java-python</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than ]]>
    </summary>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Basic Calculator II(Java)]]></title>
    <link href="http://yoursite.com/2016/02/22/Leetcode-Basic-Calculator-II-Java/"/>
    <id>http://yoursite.com/2016/02/22/Leetcode-Basic-Calculator-II-Java/</id>
    <published>2016-02-23T06:37:46.000Z</published>
    <updated>2016-02-23T06:40:55.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Implement a basic calculator to evaluate a simple expression string.</p>
<p>The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero.</p>
<p>You may assume that the given expression is always valid.</p>
<p>Some examples:</p>
<pre><code>&quot;3+2*2&quot; = 7
&quot; 3/2 &quot; = 1
&quot; 3+5 / 2 &quot; = 5
</code></pre><p>Note: Do not use the eval built-in library function.</p>
<p><strong>Thinking:</strong></p>
<p>An efficient way to solve this problem is to use stack get last num for an operation. And in order to delay the operation after get the two numbers, we need a op variable to record the last op until find the second number. What’s more, accroding to their op, numbers push into the stack in different ways. Finnaly, we just need to get the element from stack and add them all.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int calculate(String s) {
    Stack&lt;Long&gt; stack = new Stack&lt;Long&gt;();

    int i = 0;
    char op = &apos;+&apos;;
    long num = 0;

    while (i &lt; s.length()) {
        if (Character.isDigit(s.charAt(i))) {
            while (i &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i)))
                num = num * 10 + s.charAt(i++) - &apos;0&apos;;
        }
        else if (s.charAt(i) == &apos; &apos;)
            i++;
        else {
            if (op == &apos;+&apos;)
                stack.push(num);
            else if (op == &apos;-&apos;)
                stack.push(-num);
            else if (op == &apos;*&apos;)
                stack.push(stack.pop() * num);
            else if (op == &apos;/&apos;)
                stack.push(stack.pop() / num);
            num = 0;
            op = s.charAt(i++);
        }
    }

    if (op == &apos;+&apos;)
        stack.push(num);
    else if (op == &apos;-&apos;)
        stack.push(-num);
    else if (op == &apos;*&apos;)
        stack.push(stack.pop() * num);
    else if (op == &apos;/&apos;)
        stack.push(stack.pop() / num);

    int res = 0;
    for (Long n: stack)
        res += n;

    return res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Implement a basic calculator to evaluate a simple expression string.</p>
<p>The expression string conta]]>
    </summary>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Repeated DNA Sequences(Java)]]></title>
    <link href="http://yoursite.com/2016/02/22/Leetcode-Repeated-DNA-Sequences-Java/"/>
    <id>http://yoursite.com/2016/02/22/Leetcode-Repeated-DNA-Sequences-Java/</id>
    <published>2016-02-23T04:11:24.000Z</published>
    <updated>2016-02-23T05:09:08.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.</p>
<p>Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.</p>
<p>For example,</p>
<pre><code>Given s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;,

Return:
[&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;].
</code></pre><p><strong>Thinking:</strong></p>
<p>Because it limits the length of repeated substrings, so we can travse the list one time from the left to right. Pick substring from the list to check whether this substring emerge beofe.</p>
<p><strong>Solution:</strong></p>
<pre><code>public List&lt;String&gt; findRepeatedDnaSequences(String s) {
    HashSet&lt;String&gt; set = new HashSet&lt;String&gt;();
    List&lt;String&gt; res = new ArrayList&lt;String&gt;();

    for (int i = 0; i+10 &lt;= s.length(); i ++) {
        String temp = s.substring(i, i+10);
        if (!set.contains(temp)) {
            set.add(temp);
        }
        else {
            if (!res.contains(temp))
                res.add(temp);
        }
    }

    return res;
}
</code></pre><p>More efficient way:(which use the bits to represent map fucntion, reference: <a href="https://leetcode.com/discuss/25399/clean-java-solution-hashmap-bits-manipulation" target="_blank" rel="external">https://leetcode.com/discuss/25399/clean-java-solution-hashmap-bits-manipulation</a>)</p>
<pre><code>public List&lt;String&gt; findRepeatedDnaSequences(String s) {
    HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();
    HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();
    HashSet&lt;Integer&gt; second = new HashSet&lt;Integer&gt;();
    List&lt;String&gt; res = new ArrayList&lt;String&gt;();

    if (s.length() &lt; 10)    return res;

    map.put(&apos;A&apos;, 0);
    map.put(&apos;C&apos;, 1);
    map.put(&apos;G&apos;, 2);
    map.put(&apos;T&apos;, 3);

    int v = 0;

    for (int i = 0; i &lt; s.length(); i++) {
        v &lt;&lt;= 2;
        v |= map.get(s.charAt(i));
        v &amp;= 0xfffff;
        if (i &lt; 9)    continue;
        if (!set.add(v) &amp;&amp; second.add(v)) {
            res.add(s.substring(i-9, i+1));
        }
    }

    return res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”]]>
    </summary>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Count Complete Tree Nodes(Java)]]></title>
    <link href="http://yoursite.com/2016/02/22/Leetcode-Count-Complete-Tree-Nodes-Java/"/>
    <id>http://yoursite.com/2016/02/22/Leetcode-Count-Complete-Tree-Nodes-Java/</id>
    <published>2016-02-23T03:49:47.000Z</published>
    <updated>2016-02-23T03:55:33.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a complete binary tree, count the number of nodes.</p>
<p>Definition of a complete binary tree from Wikipedia:<br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p>
<p><strong>Thinking:</strong></p>
<p>Firstly, I want to traverse the tree, but we can do better. Because we know its structure is special. For example, if this root’s height is this root’s right child’s height minus 1, its left subtree must be a full tree. So we need to caclulate the rest nodes which remain in its right subtree. Otherwise, we need to go to left.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int countNodes(TreeNode root) {
    int h = height(root);
    if (h == 0)
        return 0;
    if (h == height(root.right)+1){
        return (1 &lt;&lt; (h-1)) + countNodes(root.right);
    } else {
        return (1 &lt;&lt; (h-2)) + countNodes(root.left);
    }
}

private int height(TreeNode root) {
    return root == null? 0 : 1 + height(root.left);
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a complete binary tree, count the number of nodes.</p>
<p>Definition of a complete binary tree fr]]>
    </summary>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Sort List(Java)]]></title>
    <link href="http://yoursite.com/2016/02/22/Leetcode-Sort-List-Java/"/>
    <id>http://yoursite.com/2016/02/22/Leetcode-Sort-List-Java/</id>
    <published>2016-02-23T01:27:44.000Z</published>
    <updated>2016-02-23T02:06:43.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Sort a linked list in O(n log n) time using constant space complexity.</p>
<p><strong>Thinking:</strong></p>
<p>There are three basic algorithm to sort in n*logn time. They are merge sort, heap sort and quick sort. And I implement the sort method in merge sort. In order to do this, I have to implement the function such as getLength, get the mid node, merge and so on.</p>
<p>Basic idea of merge sort is to divide a list into two lists, and make them sorted then merge them together.</p>
<p><strong>Solution:</strong></p>
<pre><code>//merge
public ListNode sortList(ListNode head) {
    int len = getLength(head);
    if (len == 0)    return null;
    ListNode nhead = mergeSort(head, len);
    addTail(nhead, len);
    return nhead;
}

private ListNode mergeSort(ListNode head, int n) {
    if (n &lt;= 1)
        return head;
    ListNode mid = getNode(head, n/2);
    ListNode nhead = mergeSort(head, n/2);
    ListNode nmid = mergeSort(mid, n - n/2);
    return merge(nhead, nmid, n);
}

private int getLength(ListNode head) {
    int l = 0;

    while (head != null) {
        head = head.next;
        l++;
    }

    return l;
}

private ListNode getNode(ListNode head, int index) {
    while (index &gt; 0) {
        head = head.next;
        index--;
    }

    return head;
}

private ListNode merge(ListNode p1, ListNode p2, int len) {
    ListNode dummy = new ListNode(0);
    ListNode p = dummy;
    int l1 = 0;
    int l2 = 0;
    while (l1 &lt; len/2 &amp;&amp; l2 &lt; len - len/2) {
        if (p1.val &lt; p2.val) {
            p.next = p1;
            p1 = p1.next;
            p = p.next;
            l1++;
        } else {
            p.next = p2;
            p2 = p2.next;
            p = p.next;
            l2++;
        }
    }
    if (l1 == len/2) {
        p.next = p2;
    } else {
        p.next = p1;
    }
    return dummy.next;
}

private void addTail(ListNode head, int n) {
    while (n &gt; 1) {
        head = head.next;
        n--;
    }
    head.next = null;
}
</code></pre><p>More efficient method:<br>Reference:<a href="https://leetcode.com/discuss/1709/have-pretty-mergesort-method-anyone-speed-reduce-memory-usage" target="_blank" rel="external">https://leetcode.com/discuss/1709/have-pretty-mergesort-method-anyone-speed-reduce-memory-usage</a></p>
<p>It use the fast pointer and slow pointer to find the middle index of the linked list. Add a null to the first half to implement the merge operation.</p>
<pre><code>public ListNode sortList(ListNode head) {
    if (head == null || head.next == null)
        return head;
    ListNode f = head.next.next;
    ListNode p = head;
    while (f != null &amp;&amp; f.next != null) {
        p = p.next;
        f =  f.next.next;
    }
    ListNode h2 = sortList(p.next);
    p.next = null;
    return merge(sortList(head), h2);
}
public ListNode merge(ListNode h1, ListNode h2) {
    ListNode hn = new ListNode(Integer.MIN_VALUE);
    ListNode c = hn;
    while (h1 != null &amp;&amp; h2 != null) {
        if (h1.val &lt; h2.val) {
            c.next = h1;
            h1 = h1.next;
        }
        else {
            c.next = h2;
            h2 = h2.next;
        }
        c = c.next;
    }
    if (h1 != null)
        c.next = h1;
    if (h2 != null)
        c.next = h2;
    return hn.next;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Sort a linked list in O(n log n) time using constant space complexity.</p>
<p><strong>Thinking:</strong]]>
    </summary>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Permutation Sequence(Java)]]></title>
    <link href="http://yoursite.com/2016/02/22/Leetcode-Permutation-Sequence-Java/"/>
    <id>http://yoursite.com/2016/02/22/Leetcode-Permutation-Sequence-Java/</id>
    <published>2016-02-22T23:33:08.000Z</published>
    <updated>2016-02-22T23:49:50.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p>
<p>By listing and labeling all of the permutations in order,<br>We get the following sequence (ie, for n = 3):</p>
<p>“123”<br>“132”<br>“213”<br>“231”<br>“312”<br>“321”<br>Given n and k, return the kth permutation sequence.</p>
<p>Note: Given n will be between 1 and 9 inclusive.</p>
<p><strong>Thinking:</strong></p>
<p>We can conclude the position of the element in the searching tree according to the k. For example, there are n subtrees in the first level, so the k/(n-1) means picking the k/(n-1) th element in the array. And delete the element from the element, pick the next one. Do this recursively.</p>
<p><strong>Solution:</strong></p>
<pre><code>public String getPermutation(int n, int k) {
    ArrayList&lt;Integer&gt; nums = new ArrayList&lt;Integer&gt;();
    int fac = 1;
    int[] pos = new int[n+1];
    for (int i = 1; i &lt;= n; i++){
        nums.add(i);
        fac *= i;
    }
    fac /= n;
    k -= 1;
    for (int i = 1; i &lt; n; i++){
        pos[i] = k / fac;
        k %= fac;
        fac /= (n-i);
    }
    StringBuilder res = new StringBuilder();
    for (int i = 1; i &lt;= n; i++){
        res.append(nums.remove(pos[i]));
    }

    return res.toString();
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p>
<p>By listing and labeling all of t]]>
    </summary>
    
      <category term="BackTracking" scheme="http://yoursite.com/tags/BackTracking/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Longest Substring Without Repeating Characters(Java)]]></title>
    <link href="http://yoursite.com/2016/02/21/Leetcode-Longest-Substring-Without-Repeating-Characters-Java/"/>
    <id>http://yoursite.com/2016/02/21/Leetcode-Longest-Substring-Without-Repeating-Characters-Java/</id>
    <published>2016-02-22T03:48:17.000Z</published>
    <updated>2016-02-22T22:49:44.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for “abcabcbb” is “abc”, which the length is 3. For “bbbbb” the longest substring is “b”, with the length of 1.</p>
<p><strong>Thinking:</strong></p>
<p>The basic idea is to maintain a hashmap to keep the exsiting characters. If there is a character appered in the hashmap, then move the index to the last position it emerged. Hold two pointers: one is to record the substring’s start position and the other is to record the substring’s end position. And the pointers can only move forward.</p>
<p><strong>Solution:</strong></p>
<pre><code>public int lengthOfLongestSubstring(String s) {
    HashMap&lt;Character, Integer&gt; alphabeta = new HashMap&lt;Character, Integer&gt;();
    int max = 0;
    int count = 0;
    int idx = 0;

    while (idx+count &lt; s.length()) {

        if (!alphabeta.containsKey(s.charAt(idx + count))) {
            alphabeta.put(s.charAt(idx + count), idx+count);
            count++;
        }
        else {
            idx = alphabeta.get(s.charAt(idx + count)) + 1;
            alphabeta = new HashMap&lt;Character, Integer&gt;();
            count = 0;
        }
        max = Math.max(max, count);
    }

    return max;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a string, find the length of the longest substring without repeating characters. For example, the]]>
    </summary>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Two Points" scheme="http://yoursite.com/tags/Two-Points/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Longest Palindromic Substring(Java)]]></title>
    <link href="http://yoursite.com/2016/02/21/Leetcode-Longest-Palindromic-Substring-Java/"/>
    <id>http://yoursite.com/2016/02/21/Leetcode-Longest-Palindromic-Substring-Java/</id>
    <published>2016-02-22T03:45:14.000Z</published>
    <updated>2016-02-22T03:47:32.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.</p>
<p><strong>Thinking:</strong></p>
<p>Run from left to right and check each element in different index. The check method is select a index, and expand its range to two sides of it. Record the max value and max substring.</p>
<p><strong>Solution:</strong></p>
<pre><code>int max = 1;
String res = &quot;&quot;;
public String longestPalindrome(String s) {
    if (s.length() &lt; 2)
        return s;
    for (int i = 0; i &lt; s.length() - max/2; i++){

        if (i+1&lt;s.length() &amp;&amp; s.charAt(i) == s.charAt(i+1)){
            check(s, i-1, i+2, 2);
        }

        check(s, i-1, i+1, 1);
    }

    return res;
}

private void check(String s, int i, int j, int len){
    int count = len;
    while (i &gt;= 0 &amp;&amp; j &lt; s.length()){
        if (s.charAt(i) == s.charAt(j))
            count += 2;
        else
            break;
        i--;
        j++;
    }
    if (count &gt; max){
        res = s.substring(i+1, j);
        max = count;
    }

}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length o]]>
    </summary>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Add Two Numbers(Java)]]></title>
    <link href="http://yoursite.com/2016/02/21/Leetcode-Add-Two-Numbers-Java/"/>
    <id>http://yoursite.com/2016/02/21/Leetcode-Add-Two-Numbers-Java/</id>
    <published>2016-02-22T02:07:11.000Z</published>
    <updated>2016-02-22T02:09:17.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8</p>
<p><strong>Thinking:</strong></p>
<p>It’s like a problem adding two numbers from the low digits to high digits. We need two variable to record the sum of current digit and whether it will incresce the next digit. Then what we should care about is to traverse the linked list and check whether it’s null pointer.</p>
<p><strong>Solution:</strong></p>
<pre><code>public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    int num1 = 0;
    int num2 = 0;
    int sum = 0;
    int flag = 0;

    if (l1 != null){
        num1 = l1.val;
        l1 = l1.next;
    }
    if (l2 != null){
        num2 = l2.val;
        l2 = l2.next;
    }
    sum = (num1 + num2) % 10;
    flag = (num1 + num2) / 10;
    ListNode head = new ListNode(sum);
    ListNode p = head;

    while (l1 != null || l2 != null){
        num1 = 0;
        num2 = 0;
        if (l1 != null) {
            num1 = l1.val;
            l1 = l1.next;
        }
        if (l2 != null) {
            num2 = l2.val;
            l2 = l2.next;
        }

        sum = (num1 + num2 + flag) % 10;
        flag = (num1 + num2 + flag) / 10;
        p.next = new ListNode(sum);
        p = p.next;
    }

    if (flag == 1)
        p.next = new ListNode(1);

    return head;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse ]]>
    </summary>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Word Break(Java)]]></title>
    <link href="http://yoursite.com/2016/02/21/Leetcode-Word-Break-Java/"/>
    <id>http://yoursite.com/2016/02/21/Leetcode-Word-Break-Java/</id>
    <published>2016-02-22T01:44:47.000Z</published>
    <updated>2016-02-22T01:48:12.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p>For example, given<br>s = “leetcode”,<br>dict = [“leet”, “code”].</p>
<p>Return true because “leetcode” can be segmented as “leet code”.</p>
<p><strong>Thinking:</strong></p>
<p>This question can be solved in dynamic programming. We can get parts of the string once and check if it’s in the dictionary words and then check the left. And we can store the result of previous substring with index in the array.</p>
<p><strong>Solution:</strong></p>
<pre><code>public boolean wordBreak(String s, Set&lt;String&gt; wordDict) {
    boolean[] valid = new boolean[s.length()+1];

    valid[0] = true;

    for (int i = 1; i &lt;= s.length(); i++) {
        for (int j = i-1; j &gt;= 0; j--){
            if (valid[j] &amp;&amp; wordDict.contains(s.substring(j, i))){
                valid[i] = true;
                break;
            }
        }
    }

    return valid[s.length()];
</code></pre><p>Reference: <a href="https://leetcode.com/discuss/18904/java-implementation-using-dp-in-two-ways" target="_blank" rel="external">https://leetcode.com/discuss/18904/java-implementation-using-dp-in-two-ways</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Clone Graph(Java)]]></title>
    <link href="http://yoursite.com/2016/02/21/Leetcode-Clone-Graph-Java/"/>
    <id>http://yoursite.com/2016/02/21/Leetcode-Clone-Graph-Java/</id>
    <published>2016-02-22T00:46:04.000Z</published>
    <updated>2016-02-22T00:48:14.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.</p>
<p>OJ’s undirected graph serialization:<br>Nodes are labeled uniquely.</p>
<p>We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.<br>As an example, consider the serialized graph {0,1,2#1,2#2,2}.</p>
<p>The graph has a total of three nodes, and therefore contains three parts as separated by #.</p>
<p>First node is labeled as 0. Connect node 0 to both nodes 1 and 2.<br>Second node is labeled as 1. Connect node 1 to node 2.<br>Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.<br>Visually, the graph looks like the following:</p>
<pre><code>   1
  / \
 /   \
0 --- 2
     / \
     \_/
</code></pre><p><strong>Thinking:</strong></p>
<p>In order to clone this graph, we need to traverse the graph either using DFS or BFS. In my solution, I use DFS and graph search which will hold a HashMap to record the explored nodes.</p>
<p><strong>Solution:</strong></p>
<pre><code>HashMap&lt;Integer, UndirectedGraphNode&gt; exploredSet = new HashMap&lt;Integer, UndirectedGraphNode&gt;();
public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
    return clone(node);
}

private UndirectedGraphNode clone(UndirectedGraphNode node){
    if (node == null) return null;
    UndirectedGraphNode newNode = new UndirectedGraphNode(node.label);

    exploredSet.put(node.label, newNode);

    for (UndirectedGraphNode n: node.neighbors) {
        if (exploredSet.containsKey(n.label)) {
            newNode.neighbors.add(exploredSet.get(n.label));
        } else {
            newNode.neighbors.add(clone(n));
        }
    }

    return newNode;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.</p>
<p>]]>
    </summary>
    
      <category term="Graph, DFS, BFS" scheme="http://yoursite.com/tags/Graph-DFS-BFS/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Additive Number(Java)]]></title>
    <link href="http://yoursite.com/2016/02/21/Leetcode-Additive-Number-Java/"/>
    <id>http://yoursite.com/2016/02/21/Leetcode-Additive-Number-Java/</id>
    <published>2016-02-22T00:23:12.000Z</published>
    <updated>2016-02-22T00:27:17.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>Additive number is a string whose digits can form additive sequence.</p>
<p>A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.</p>
<p>For example:<br>“112358” is an additive number because the digits can form an additive sequence: 1, 1, 2, 3, 5, 8.</p>
<p>1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8<br>“199100199” is also an additive number, the additive sequence is: 1, 99, 100, 199.<br>1 + 99 = 100, 99 + 100 = 199<br>Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.</p>
<p>Given a string containing only digits ‘0’-‘9’, write a function to determine if it’s an additive number.</p>
<p>Follow up:<br>How would you handle overflow for very large input integers?</p>
<p><strong>Thinking:</strong></p>
<p>I noticed that it’s only different in the first time in the iteration becuase we know nothing about the first element. But when found it, we can use the previous two elements to check the next one. So in the first function, we enumerate the first two elements, and check the rest string if it’s valid recursively.</p>
<p><strong>Solution:</strong></p>
<pre><code>public boolean isAdditiveNumber(String num) {

    int len = num.length();

    long num1 = 0;
    long num2 = 0;
    //find the first two elements first
    for (int i = 1; 2*i+1 &lt;= len; i++){
        for (int j = 1; Math.max(i, j) &lt;= len-i-j; j++){
            if (num.charAt(0) == &apos;0&apos; &amp;&amp; i &gt; 1)    return false;//if first char is 0, then it only can be 0
            num1 = Long.parseLong(num.substring(0, i));
            if (num.charAt(i) == &apos;0&apos; &amp;&amp; j &gt; 1)    break;//if second element start with 0, then it only can be 0
            num2 = Long.parseLong(num.substring(i, i+j));
            if (isValid(num1, num2, i+j, num))//check the rest recursively
                return true;
        }
    }

    return false;
}

private boolean isValid(long i, long j, int start, String num){
    if (start == num.length())    return true;//no rest chars left, success
    if (num.charAt(start) == &apos;0&apos;)    return false;
    long sum = 0;
    for (int idx = start+1; idx &lt;= num.length(); idx++){
        sum = Long.parseLong(num.substring(start, idx));
        if (sum - i &gt; j)
            return false;
        if (sum - i == j)
            return isValid(j, sum, idx, num);
    }
    return false;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>Additive number is a string whose digits can form additive sequence.</p>
<p>A valid additive sequence s]]>
    </summary>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Leetcode-Coin Change(Java)]]></title>
    <link href="http://yoursite.com/2016/02/14/Leetcode-Coin-Change-Java/"/>
    <id>http://yoursite.com/2016/02/14/Leetcode-Coin-Change-Java/</id>
    <published>2016-02-15T00:11:50.000Z</published>
    <updated>2016-02-15T00:17:51.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Question:</strong></p>
<p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p>
<p>Example 1:<br>coins = [1, 2, 5], amount = 11<br>return 3 (11 = 5 + 5 + 1)</p>
<p>Example 2:<br>coins = [2], amount = 3<br>return -1.</p>
<p>Note:<br>You may assume that you have an infinite number of each kind of coin.</p>
<p><strong>Thinking:</strong></p>
<p>In order to solve this problem, we can use dp which check whether choose current coin to make sure it’s minimum. But using function recursively will waste a lot of time. So we need to use extra space avoiding waste time. Then, we should build up a dp array accroding to the amount of money. Then update the dp value of different amout from zero to the target amout. The DP expression is: dp[i + coins[j]] = Math.min(dp[i + coins[j]], dp[i] + 1)</p>
<p><strong>Solution:</strong></p>
<pre><code>public int coinChange(int[] coins, int amount) {
    int dp[] = new int[amount + 1];
    for (int i = 1; i &lt;= amount; i++) dp[i] = Integer.MAX_VALUE-1;
    for (int i = 0; i &lt;= amount; i++) {
        for (int j = 0; j &lt; coins.length; j++) {
            if (i + coins[j] &lt;= amount)
                dp[i + coins[j]] = Math.min(dp[i + coins[j]], dp[i] + 1);
        }
    }
    return dp[amount] == Integer.MAX_VALUE-1 ? -1 : dp[amount];
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Question:</strong></p>
<p>You are given coins of different denominations and a total amount of money amount. Write a function to ]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Some basic problems]]></title>
    <link href="http://yoursite.com/2016/02/13/Some-basic-problems/"/>
    <id>http://yoursite.com/2016/02/13/Some-basic-problems/</id>
    <published>2016-02-13T23:55:10.000Z</published>
    <updated>2016-02-13T23:56:22.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li>Hanoi:</li>
</ol>
<p><img src="http://my.csdn.net/uploads/201204/23/1335186818_5426.jpg" alt=""></p>
<pre><code>public  void move(int n,char a,char b,char c){  

    if(n==1){  
        System.out.println(&quot;move from &quot;+a+&quot; to &quot;+c);  
    }else{  
        move(n-1, a,c,b);  
        move(1, a, b, c);  
        move(n-1, b, a, c);  
    }  
}  
</code></pre><ol>
<li>Queue:</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<ol>
<li>Hanoi:</li>
</ol>
<p><img src="http://my.csdn.net/uploads/201204/23/1335186818_5426.jpg" alt=""></p>
<pre><code>public  void move(i]]>
    </summary>
    
  </entry>
  
</feed>
